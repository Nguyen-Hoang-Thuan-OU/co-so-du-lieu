[NHẬP MÔN CƠ SỞ DỮ LIỆU VỚI MICROSOFT SQL SERVER]

	"Trứng rán cần mỡ, bắp cần bơ, ỨNG DỤNG CẦN CƠ SỞ DỮ LIỆU"

								   (Database)
									^
									|
									|
						 SQL >			V
(Ngôn ngữ lập trình) <------------------[Internet]--------------> (DBMS - Server)
			< Text / Data					^
									|
								SQL >	|
(SSMS - Client) <-----------------------[Internet]-----------------------
		   < Text / Data

==========================================================================================

[ÔN TẬP KHÁI NIỆM]

* Thông tin (Information): Là tất cả các sự việc, sự kiện, ý tưởng, phán đoán,...
	- Phản ánh về tự nhiên và xã hội (thế giới vật chất) thông qua ngôn từ (con số, chữ viết, ký hiệu), âm thanh, hình ảnh,...
	- Tác động lên giác quan của con người để làm tăng thêm những hiểu biết có được về một đối tượng nào đó.

	-> Những hiểu biết về một đối tượng nào đó.

--------------------------------------------------------------------------------

* Dữ liệu (Data): Là những thông tin nguyên thủy (thô), chưa qua xử lý, không có ý nghĩa rõ ràng.
	- Có thể là số liệu, ký tự, hình ảnh, âm thanh, video hoặc bất kỳ dạng nào của thông tin chưa được xử lý.
	- Mô tả hình thức để thể hiện thông tin hay hoạt động nào đó lên những phương tiện mang tin (dữ liệu được thể hiện thông qua tờ giấy, bức ảnh, chiếc loa,...).
	- Là những thông tin đã được đưa vào thiết bị lưu trữ.

	-> Là thông tin, nhưng được biểu diễn khác đi.

------------------------------------------------------------

Phân loại dữ liệu theo tính chất:

	1. Tĩnh (Static): Không có hoặc rất ít khi có sự thay đổi theo thời gian.
		Ví dụ: Tên, ngày sinh, số CCCD,...

	2. Động (Dynamic): Thường xuyên có sự thay đổi theo thời gian.
		Ví dụ: Tuổi, doanh thu, số lượng hàng trong kho,...

------------------------------------------------------------

Phân loại dữ liệu theo cấu trúc:

	1. Không có cấu trúc / Phi cấu trúc (UnStructured): Là dữ liệu không theo một định dạng cụ thể và không thể được lưu trữ trong một hệ thống hoặc cơ sở dữ liệu truyền thống.
		- Là các tập tin hình ảnh, âm thanh, văn bản,...
		- Chiếm 80% tổng dữ liệu của doanh nghiệp.
			+ Tốn nhiều dung lượng bộ nhớ.
			+ Khó quản lý và bảo mật dữ liệu.

	2. Có cấu trúc (Structured): Dữ liệu ở định dạng chuẩn hoá để con người và phần mềm dễ dàng truy cập.
		- Thường ở dạng bảng (Table), bao gồm các hàng (Row) và cột (Column) xác định rõ ràng các thuộc tính dữ liệu.
		- Là các con số, chuỗi và ngày-tháng-năm.
		- Chỉ chiếm 20% tổng dữ liệu của doanh nghiệp.
			+ Đây là những giá trị thực sự có giá trị sử dụng.
			+ Tốn ít dung lượng bộ nhớ hơn.
			+ Dễ dàng quản lý và bảo mật dữ liệu hơn.

Khi dữ liệu được để lung tung sẽ giống như "mò kim đáy biển" vì chúng đang được tổ chức không theo cấu trúc.
	- Nếu có một dữ liệu quan trọng cần lưu trữ, việc lưu trữ trong một nơi không có cấu trúc sẽ tiêu tốn rất nhiều thời gian trong việc tìm kiếm về sau này.
	- Vì vậy, cần phải sắp xếp dữ liệu theo một cấu trúc để giúp việc truy cập trở nên dễ dàng hơn.

--------------------------------------------------------------------------------

Mọi sự việc diễn ra xung quanh chúng ta đều tạo ra thông tin.
	- Về cơ bản, con người có thể sử dụng các giác quan để thu thập thông tin.
	- Nhưng với nhu cầu muốn biết thêm nhiều hơn, hiểu thế giới quanh mình rõ hơn và đúng hơn, con người đã tạo ra nhiều loại thiết bị thu nhận các tín hiệu từ thế giới xung quanh.
	- Các loại thiết bị nhu nhận tín hiệu này sẽ trả về dữ liệu.
	- Dữ liệu sau đó sẽ được lưu vào thiết bị lưu trữ hoặc được gửi đi qua đường truyền dữ liệu.
	- Từ dữ liệu, thông qua quá trình xử lý, chúng ta có thể rút ra được nhiều thông tin khác nhau.

	-> Con người tiếp nhận dữ liệu qua các giác quan để chuyển thành thông tin.

	Ví dụ:

				Con người
				đến tham quan			Chuyển thành
				trực tiếp			thông tin
	"Hội An có Chùa Cầu --------------------> [Giác quan] ------------------> Não bộ
	với mái vòm cong				^
	rất độc đáo"					|
		|					|
		|					|
		--------------------------------> [Hình ảnh về Chùa Cầu]
		   Thiết bị thu nhận tín hiệu
		   (Máy ảnh, điện thoại...)

Mối quan hệ giữa thông tin và dữ liệu:

	- Thông tin -> dữ liệu:
		+ Quá trình nói, viết, vẽ, cử chỉ,... sẽ chuyển thông tin trong não bộ thành dữ liệu để lưu trữ hay gửi đi khi trao đổi thông tin.
		+ Thông tin có thể được biểu diễn dưới các dạng / hình thức (dữ liệu) khác nhau.
		(Nhiều dữ liệu cùng biểu diễn một thông tin.)

		Ví dụ 1: Để mô tả về ngôi nhà (thông tin), chúng ta có thể chuyển thông tin thành dữ liệu dưới dạng:
			- Hình ảnh: Vẽ tranh.
			- Văn bản: Viết văn.
			- Âm thanh: Sáng tác bài hát.
			-> Chuyển thông tin thành dữ liệu dưới nhiều dạng khác nhau.

		Ví dụ 2: Để tránh làm phiền người khác nơi đông người, để trao đổi thông tin, ta có thể sử dụng các dấu hiệu: gật/lắc đầu, mỉm cười,...
			-> Thông tin được trao đổi dưới nhiều dạng khác nhau.

	- Dữ liệu -> Thông tin:
		+ Dữ liệu là nguồn thông tin, có nhiều cách thức khác nhau để thể hiện thông tin, nên văn bản chữ và số, hình vẽ, hình ảnh, âm thanh, video,... đều là dữ liệu.
		+ Từ dữ liệu có thể rút ra nhiều thông tin khác nhau nhờ vào quá trình xử lý.
		(Một dữ liệu chứa nhiều thông tin.)

		Ví dụ 1: Từ bước tranh, bài văn, bài hát,... (dữ liệu) về ngôi nhà, ta có thể rút ra được nhiều thông tin khác nhau:
			- Ngôi nhà có đẹp hay không?
			- Chủ nhà theo đuổi phong cách gì?
			-> Rút ra được nhiều thông tin từ dữ liệu.

		Ví dụ 2: Dũng gửi mảnh giấy (dữ liệu) cho Hoàng: "Tan học chờ tớ ở cổng trường nhé!".
			- Dòng chữ trên mảnh giấy là dữ liệu văn bản, nội dung dòng chữ là thông tin (mảnh giấy là cách biểu diễn thông tin dưới dạng văn bản).
			- Nếu Hoàng đọc được mảnh giấy, thông qua nét chữ, kiểu viết,... Hoàng sẽ biết là do Dũng gửi và Dũng muốn hẹn gặp mình ở cổng trường sau khi tan học.
			- Nhưng nếu một người khác đọc mảnh giấy, người này sẽ không biết được người gửi và nhận là ai, chỉ biết có một cuộc hẹn diễn ra ở cổng trường khi tan học.
			-> Rút ra được nhiều thông tin từ dữ liệu.

		Ví dụ 3: Khi nghe một đoạn âm thanh (dữ liệu), ta có thể rút ra được những thông tin:
			- Nội dung của đoạn âm thanh.
			- Chất giọng (vùng miền) của người nói.
			- Cảm xúc của người nói.
			-> Rút ra được nhiều thông tin từ dữ liệu.

	-> Thông tin và dữ liệu có tính độc lập tương đối.
		- Một thông tin có thể được thể hiện dưới nhiều dạng dữ liệu.
		- Một dữ liệu có thể chứa nhiều thông tin.

--------------------------------------------------------------------------------

* Thông tin hữu ích / Thông tin có giá trị gia tăng (Value added information): Các dữ liệu đã qua xử lý (phân loại, phân tích, sắp xếp, tổng hợp, tính toán, chọn lựa,...) để thu được những thông tin có giá trị cao hơn.
	- Khi dữ liệu được thu thập từ các nguồn khác nhau, nó cần được xử lý để loại bỏ nhiễu, đảm bảo tính chính xác và đáng tin cậy.
	- Sau đó, phân tích dữ liệu có thể được thực hiện để tìm ra mẫu, xu hướng hoặc quan hệ giữa các yếu tố khác nhau.
	- Thông qua quy trình phân tích, các phương pháp và công cụ thích hợp được áp dụng để giải mã dữ liệu và tạo ra thông tin ý nghĩa.
	- Các kỹ thuật, như máy học, khai phá dữ liệu, phân tích thống kê và mô hình hóa, có thể được sử dụng để xác định các mẫu ẩn, tìm kiếm thông tin quan trọng và đưa ra dự đoán.
	- Sau khi dữ liệu đã được xử lý và phân tích, các thông tin quan trọng và giá trị được tổng hợp lại thành một cách dễ hiểu.
	- Giúp mang lại hiểu biết và kiến thức để giải quyết vấn đề, đưa ra quyết định hoặc truyền đạt ý kiến.

	Ví dụ 1: Từ bảng điểm tổng kết các môn học của học sinh cả lớp, cần tìm ra 3 học sinh có điểm trung bình môn học cao nhất lớp để làm danh sách đề nghị nhà trường tuyên dương và khen thưởng.
		- Thông tin đầu vào: Tên học sinh và điểm tổng kết các môn của học sinh.
		- Dữ liệu đầu vào: Bảng điểm liệt kê tên (văn bản) và điểm trung bình (số).
		- Thông tin đầu ra: 3 học sinh có điểm trung bình môn học cao nhất lớp.
		- Dữ liệu đầu ra: Danh sách tên (văn bản) của 3 học sinh.
		-> Nhận bảng điểm để xử lý và cho ra danh sách tương ứng để khen thưởng.

	Ví dụ 2: Tóm tắt quá trình dữ liệu trở thành thông tin hữu ích.

		[Dữ liệu]					[Thông tin hữu ích]

		Điểm số của		     Xử lý		- Điểm trung bình của sinh viên
		tất cả sinh viên	--------------->	- Sinh viên có điểm cao nhất

--------------------------------------------------------------------------------

* Tri thức / Kiến thức (Knowledge): Là các hiểu biết hoặc kĩ năng về một điều gì đó, có được nhờ trải nghiệm thực tế hoặc học tập.

==========================================================================================

[CƠ SỞ DỮ LIỆU & CÁC THUẬT NGỮ LIÊN QUAN]

Con người đã lưu trữ và sử dụng dữ liệu từ lâu, nhưng gần đây con người bắt đầu lưu trữ một lượng lớn dữ liệu ở định dạng dễ dàng truy xuất.
	+ Kể từ khi bắt đầu nền văn minh, người Babylon cổ đại đã khắc thông tin lên những tấm đất sét.
	+ Lượng dữ liệu được ghi chép lại tăng lên khi phát minh ra hệ số Ả Rập và thêm một bước nhảy vọt khác khi máy tin được phát minh.
	+ Với mỗi tiến bộ công nghệ, lượng dữ liệu lại càng tăng lên và việc lưu trữ để sử dụng cũng tăng theo.

Trong tin học, để máy tính xử lý được thông tin, thông tin đó phải được chuyển thành dữ liệu trong máy tính (dữ liệu số hoá).

Khi số lượng dữ liệu ngày càng lớn, đặc biệt là trong các hệ thống thương mai điện tử khi số lượng dữ liệu được tăng liên tục mỗi ngày (kể cả những hành động đơn giản như lưu lại lịch sử xem sản phẩm cũng sẽ phát sinh dữ liệu).
	- 80% dữ liệu của doanh nghiệp sẽ ở dạng phi cấu trúc.
	- Để quản lý (lưu trữ, thao tác (thêm-sửa-xoá) và truy xuất (xem)) một lượng dữ liệu.
		+ Cần phải biến những dữ liệu phi cấu trúc thành dữ liệu có cấu trúc.
		+ Cần phải sử dụng thêm những hệ thống hỗ trợ quản lý.
	- Phục vụ cho nhu cầu khai thác thông tin của một hoặc nhiều người (mà chủ yếu là nhiều người).

	-> Dữ liệu cần được lưu một cách có cấu trúc và có cơ chế cho phép truy xuất nhanh.

--------------------------------------------------------------------------------

* Quản lý dữ liệu: Là các hành động liên quan đến việc lập kế hoạch, phát triển, thực hiện và quản trị các hệ thống để thu thập, lưu trữ, bảo mật, truy xuất và xử lý dữ liệu.

Để giải quyết một bài toán, có hai việc mà chúng ta cần quan tâm:
	1. Phương pháp để quản lý dữ liệu.
	2. Thuật toán tương ứng để xử lý dữ liệu.

Khi nhắc đến các phương pháp để quản lý dữ liệu, ta có các hệ thống quản lý dữ liệu: Mỗi ứng dụng khác nhau sẽ phát sinh ra những dữ liệu khác nhau và yêu cầu một hệ thống để quản lý toàn bộ dữ liệu.

	1. Hệ thống quản lý bằng tập tin: Mỗi ứng dụng sẽ có nhiều tập tin và mỗi người dùng sẽ có một tập tin riêng để lưu trữ và quản lý thông tin dựa theo nhu cầu riêng của mình (quản lý không tập trung).
		- Là hệ thống lưu trữ không có cấu trúc.
		- Dữ liệu sẽ không có liên kết với nhau.

		* Ưu điểm:
			- Có thể sử dụng được ngay mà không cần cài đặt thêm phần mềm.
			- Tốc độ phản hồi khi truy xuất sẽ rất nhanh.

		* Nhược điểm:

			- Trùng lặp, dư thừa và mâu thuẫn dữ liệu: Toàn bộ những thông tin cần thiết sẽ được đưa vào cùng một tập tin.
				+ Tuy cùng nói về một thông tin, nhưng mỗi người sẽ sở hữu một tập tin riêng và có toàn quyền trên tập tin đó.
				+ Cấu trúc lưu trữ có thể khác nhau dù cho nhiều người cùng lưu trữ về cùng một loại dữ liệu giống nhau.
				+ Việc sửa đổi dữ liệu sẽ không được diễn ra đồng bộ, làm mất đi tính toàn vẹn dữ liệu.

				Ví dụ: Cùng một tập tin về một loại dữ liệu, nhưng những người dùng thuộc những phân hệ khác nhau (kế toán, bán hàng,...) sẽ có những cách khác nhau để lưu trữ.
					- Khi lưu trữ dữ liệu về ngày-tháng-năm.
						+ Sẽ có người thích lưu trữ theo định dạng: ngày/tháng/năm.
						+ Sẽ có người thích lưu trữ theo định dạng: năm/tháng/ngày.

					- Khi lưu trữ dữ liệu về giới tính.
						+ Sẽ có người thích lưu trữ theo định dạng: Nam / Nữ / Khác.
						+ Sẽ có người thích lưu trữ theo định dạng: 0 / 1 / 2.

			- Hạn chế chia sẻ và truy cập đồng thời: Dữ liệu sẽ không được quản lý tập trung tại một nơi và không hỗ trợ truy cập đồng thời từ nhiều người dùng.
				+ Để chia sẻ được tập tin, bắt buộc phải có một máy chia sẻ dữ liệu qua mạng.
				+ Nếu nhiều người cần truy cập dữ liệu cùng một lúc sẽ dễ gây ra vấn đề về tính nhất quán của dữ liệu, nên cần phải sắp xếp thứ tự khi nhiều người cùng sử dụng một tập tin được chia sẻ qua mạng.

			- Bảo mật: Việc kiểm soát quyền truy cập vào tập tin có thể phức tạp và không an toàn vì một máy tính trong hệ thống mạng có thể bị nhiễm mã độc và lây lan cho những máy khác đang truy cập để lấy dữ liệu trong cùng mạng.

			- Sao lưu và phục hồi: Phụ thuộc phần lớn vào hệ điều hành với các thao tác sao chép và dán tập tin sang một ổ đĩa khác.
				+ Việc sao lưu và phục hồi dữ liệu từ tập tin có thể mất nhiều thời gian và công sức hơn vì dữ liệu được phân tán ở nhiều nơi.
				+ Khó được thực hiện một cách thường xuyên (theo thời gian thực) khi có người dùng đang sử dụng.

			- Tính linh hoạt: Hệ thống tập tin có giới hạn về khả năng mở rộng và linh hoạt trong việc xử lý các yêu cầu dữ liệu phức tạp.

	2. Hệ thống quản lý bằng cơ sở dữ liệu: Dữ liệu được lưu trữ tập trung tại một nơi và chia sẻ cho nhiều người cùng sử dụng.
		- Dữ liệu sẽ được tổ chức, chuẩn hoá và lưu trữ có cấu trúc.
		- Giúp quản lý dữ liệu một cách hiệu quả và nhanh chóng.

Khi lập trình, dữ liệu chỉ được lưu trữ tạm thời trong các biến trên RAM, sau khi kết thúc chương trình thì toàn bộ dữ liệu sẽ bị mất đi.
	- Để lưu trữ lại dữ liệu, cách đơn giản nhất là sử dụng một tập tin văn bản.
	- Nhưng tập tin văn bản không thích hợp để sử dụng trong một hệ thống có nhiều người dùng cùng truy cập vào một tài nguyên.
	- Vì vậy, trong các hệ thống lớn, cơ sở dữ liệu thường được sử dụng để lưu trữ dữ liệu.

--------------------------------------------------------------------------------

	* Data: Dữ liệu.
	* Base: Nền tảng, khu vực, không gian.
		-> Cơ sở dữ liệu / Không gian để lưu trữ dữ liệu.
* Cơ sở dữ liệu (Database - DB): Giống như một chiếc thùng hoặc tủ đồ, nơi chuyên được sử dụng để lưu những dữ liệu có tổ chức liên quan đến nhau (dữ liệu bên trong được cất một cách ngăn nắp trong các kệ - bảng).

	- Là một tập hợp các dữ liệu...
		+ Phải có liên quan với nhau, nhưng không phải là một tập dữ liệu tuỳ tiện.
		+ Được tổ chức theo một cách có hệ thống (có cấu trúc, có liên quan luận lý và ràng buộc với nhau) và theo một mô hình.
		+ Cho phép lưu trữ, truy xuất và thao tác (xem-thêm-sửa-xoá) dữ liệu một cách hiệu quả.

		Ví dụ 1: Cơ sở dữ liệu Bệnh Viện lưu trữ bác sĩ, bệnh nhân, chẩn đoán, điều trị của bệnh nhân, hóa đơn của bệnh nhân...
			-> Các dữ liệu có liên quan với nhau.

		Ví dụ 2: Để quản lý dữ liệu về việc sở hữu ô tô, ta cần một số thông tin:
			- Công dân: Thông tin về công dân có thể sở hữu ô tô.
			- Ô tô: Thông số về ô tô.
			- Thông tin sở hữu: Là sự liên kết (mối liên quan) giữa công dân và ô tô, cho biết thông tin về việc sở hữu ô tô của công dân.

			-> Các dữ liệu có liên quan với nhau.

	- Yêu cầu cần có để được gọi là một cơ sở dữ liệu:
		+ Dữ liệu được mô hình hóa theo cấu trúc, được tổ chức để hỗ trợ tìm kiếm.
		+ Là sự kết hợp giữa dữ liệu và một hệ thống quản lý (tìm kiếm, truy vấn, in báo cáo,...).
		+ Dữ liệu sẽ không bị mất, trừ khi bị xoá.
		+ Dữ liệu lưu trữ có mối quan hệ (Relational / Relationship) với nhau.
		+ Các cơ sở dữ liệu có khả năng kết nối với nhau (Relational / Relationship).
		+ Hỗ trợ nhiều người dùng cùng một lúc.
		+ Dễ dàng mở rộng, chứa nhiều dữ liệu mà không tốn quá nhiều dung lượng, nhờ vào khả năng liên kết các cơ sở dữ liệu.
		+ Quản lý truy cập bằng cách cấp quyền truy cập riêng biệt cho từng cột thuộc tính trong một bảng thay vì cấp quyền truy cập cho toàn bộ bảng.

	- Để xem-thêm-sửa-xoá dữ liệu, hầu hết các cơ sở dữ liệu đều sử dụng ngôn ngữ truy vấn có cấu trúc (Structured Query Language - SQL).

	-> Tập hợp những dữ liệu được tổ chức có cấu trúc và liên quan với nhau.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Cơ sở dữ liệu gồm nhiều dữ liệu liên quan với nhau,	│
│	được lưu trữ có cấu trúc để dễ dàng truy xuất		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------------------------------------

"Một tập tin văn bản hoặc một bảng tính (Spreadsheet) chứa nhiều dữ liệu có được xem là cơ sở dữ liệu không?"

Có rất nhiều thảo luận về việc được hay không được xem là một cơ sở dữ liệu, nhưng hướng giải thích sau đây sẽ tập trung vào việc một tập tin dữ liệu (Flat File) không được xem là cơ sở dữ liệu.
	- Là loại dữ liệu không có cấu trúc, hoặc kể cả khi một bảng tính có cấu trúc hàng và cột, nó vẫn không được xem là cơ sở dữ liệu.
	- Tập tin dữ liệu không chứa liên kết đến bất kì tập tin nào khác.
	- Tại một thời điểm, chỉ cho phép duy nhất một người dùng tương tác.
	- Không thể lựa chọn dữ liệu để hiển thị, chỉ được phép hoặc hiển thị hết hoặc không cho truy cập.

------------------------------------------------------------

Đặc tính / Đặc trưng (lợi ích) của cơ sở dữ liệu:

	- Tính tự mô tả: Hệ CSDL không chỉ chứa mỗi CSDL, mà còn chứa chi tiết về mô tả của CSDL (cấu trúc tập tin, kiểu dữ liệu, ràng buộc dữ liệu, miền giá trị,...).
		+ Thông tin mô tả cấu trúc đầy đủ của CSDL được lưu trữ trong bản liệt kê mục lục (Catalog).
		+ Dữ liệu của catalog được gọi là siêu dữ liệu (Metadata - dữ liệu cung cấp thông tin về một dữ liệu khác, cụ thể là thông tin về đặc tả của CSDL).
		+ Nhờ vào thông tin cấu trúc được lưu trong catalog mà các ứng dụng có thể hiểu được và có thể truy xuất đến CSDL.

		-> Phải tự mô tả cấu trúc và ràng buộc được để nơi khác sử dụng.

	- Tính độc lập giữa ứng dụng và dữ liệu: Cho phép thay đổi cấu trúc hoặc dữ liệu (thêm-sửa-xoá) trong CSDL mà không cần phải thay đổi ứng dụng đang sử dụng CSDL.
		+ Độc lập dữ liệu mức luận lý: Cấu trúc mức luận lý của CSDL thay đổi (ví dụ: thêm cột vào bảng, xoá bảng,...) sẽ không ảnh hưởng đến ứng dụng.
		+ Độc lập dữ liệu mức vật lý: Cấu trúc vật lý của CSDL thay đổi (ví dụ: đổi HQTCSDL, đổi cách tổ chức dữ liệu, đưa dữ liệu từ ổ đĩa lên "mây",...) sẽ không ảnh hưởng đến ứng dụng. 

		-> CSDL có thay đổi cũng không ảnh hưởng đến ứng dụng.

	- Tính trừu tượng dữ liệu: Dữ liệu chỉ được biểu diễn ở mức ý niệm, chi tiết về cách thức lưu trữ sẽ được che giấu.
		- Hỗ trợ cho tính độc lập, tách biệt giữa ứng dụng và dữ liệu khi toàn bộ những câu lệnh truy vấn sẽ được lưu trữ trong CSDL thay vì trong ứng dụng.
			+ Mỗi khi có thay đổi gì trong dữ liệu, những truy vấn liên quan sẽ được thực hiện trực tiếp tại hệ quản trị cơ sở dữ liệu, sẽ không cần phải chỉnh sửa trong ứng dụng.
		- Dữ liệu được trừu tượng hoá bằng cách xác định mô hình dữ liệu (tìm ra: thực thể, thuộc tính và mối kết hợp), sau đó đưa cho máy để máy hiểu về ý tưởng và cách thức lưu trữ.

		-> Đảm bảo tính độc lập, che giấu đi chi tiết thiết kế CSDL.

	- Tính nhất quán dữ liệu: Dữ liệu được lưu tập trung ở một nơi nên sẽ tránh được tình trạng trùng lặp và thiếu nhất quán trong thông tin.
		+ Phải có cơ chế điều khiển truy xuất dữ liệu hợp lý để tránh tranh chấp dữ liệu và đảm bảo dữ liệu luôn đúng tại mọi thời điểm.
		+ Phải xây dựng CSDL thoả được các tính chất trong dạng chuẩn.

		-> Dữ liệu phải luôn thống nhất để tránh xung đột.

	- Đa khung nhìn dữ liệu: CSDL cho phép nhiều người dùng khác nhau (với những mục đích khác nhau) cùng sử dụng.
		+ Mỗi người dùng, với những phân quyền khác nhau, sẽ có một cách nhìn (View) khác nhau về dữ liệu.
		+ Cách nhìn / Góc nhìn / Khung nhìn / Giao diện (View) có thể là một phần (hàng và cột) sẵn có trong CSDL được rút trích ra hoặc yêu cầu phải tổng hợp và tính toán từ CSDL mà thành.

		-> Cung cấp nhiều góc nhìn tương ứng với những loại người dùng khác nhau.

------------------------------------------------------------

Những nhóm người sử dụng cơ sở dữ liệu:

	1. Người thiết kế cơ sở dữ liệu (Database Designer): Phân tích yêu cầu phần mềm và thiết kế ra cơ sở dữ liệu để lập trình viên sử dụng.
		- Trao đổi với người dùng để nắm bắt yêu cầu phần mềm và đưa ra sơ đồ thiết kế (từ ý niệm đến vật lý) để thoả mãn yêu cầu.
		- Lựa chọn cấu trúc và HQTCSDL phù hợp để lưu trữ dữ liệu.
		- Quyết định những dữ liệu nào cần được lưu trữ và những dữ liệu này có liên quan với nhau như thế nào.
		- Định nghĩa các chỉ mục (Index) và phương pháp lập chỉ mục để tối ưu quá trình khai thác CSDL.

	2. Người quản trị cơ sở dữ liệu (Database Administrator - DBA): Tuy không phải là người trực tiếp tạo ra cơ sở dữ liệu, nhưng lại là người xử lý những vấn đề xoay quanh cơ sở dữ liệu như:
		- Đảm bảo máy tính (phần cứng) và HQTCSDL (phần mềm) được hoạt động thông suốt.
		- Phân quyền, giới hạn và thu hồi quyền truy cập của người dùng để ngăn chặn những truy cập không được phép.
		- Tổ chức sao lưu và phục hồi dữ liệu để tránh rủi ro về mất mát dữ liệu trong những trường hợp: ổ đĩa bị hỏng, hệ điều hành bị hỏng, máy chủ bị hỏng, mất điện, thiên tai,...
		- Bảo mật cơ sở dữ liệu khỏi những cuộc tấn công mạng.

	3. Người dùng cuối (End-user): Đa phần đều là những người sử dụng ứng dụng (thông qua giao diện của ứng dụng) để truy cập vào dữ liệu trong cơ sở dữ liệu.

		3.1. Người sử dụng ít (Casual User / Temporary User): Thường là những người quản lý, ít có nhu cầu truy cập vào CSDL, nhưng nếu có thì thường yêu cầu những câu truy vấn phức tạp.

		3.2. Người sử dụng thường xuyên (Naive / Parametric End User): Thường xuyên phải sử dụng CSDL nhưng không yêu cầu phải có những hiểu biết về HQTCSDL, có thể sử dụng thông qua giao diện của một ứng dụng nào đó.

		3.3. Người sử dụng đặc biệt (Sophisticated User): Người có kiến thức sâu rộng về CSDL (ví dụ: BA, nhà khoa học,...) và có thể sử dụng SQL để tương tác với HQTCSDL để truy vấn phức tạp.

		3.4. Người sử dụng cá nhân (Stand-alone User): Người sử dụng các ứng dụng để phục vụ công việc cá nhân (ví dụ: quản lý thuế cá nhân, quản lý bảo hiểm xã hội,...).

	4. Người lập trình (Developer): Viết ra các chương trình có kết nối đến cơ sở dữ liệu.

------------------------------------------------------------

Phân loại mô hình cơ sở dữ liệu:

	- Thế hệ đầu tiên (truyền thống):
		+ CSDL phân cấp (Hierarchical).
		+ CSDL mạng (Network).

	- Thế hệ thứ hai:
		+ CSDL quan hệ (Relational).

	- Thế hệ thứ ba:
		+ CSDL hướng đối tượng (Object-Oriented).

------------------------------------------------------------

Trong thời đại ngày nay, mọi hành xử của những ứng dụng mà chúng ta đang sử dụng, đằng sau nó hầu hết đều là cơ sở dữ liệu.
	- Tất cả các lĩnh vực trong cuộc sống như kinh doanh, ngân hàng và tài chính, giáo dục, hành chính, giải trí..., đều phát sinh rất nhiều dữ liệu cần đến cơ sở dữ liệu.
	- Thậm chí, trong dữ liệu lớn, trí tuệ nhân tạo..., cơ sở dữ liệu là điều bắt buộc phải có vì đây là cơ sở để khai thác, tìm quy luật và đưa ra quyết định.
	- Để tương tác được với cơ sở dữ liệu (Server), ta sẽ có hai cách:
		1. Sử dụng ngôn ngữ lập trình để gọi đến cơ sở dữ liệu trong code.
		2. Sử dụng câu lệnh / cú pháp để tương tác trực tiếp với dữ liệu.

Có thể xem các thuật ngữ Server, Servcie, Database Instance, Database Engine, Database Server... là một và đều nói về nơi chứa dữ liệu, một loại dịch vụ (Service) chạy ngầm (background) để phục vụ cho những nơi khác (Client).

--------------------------------------------------------------------------------

* Hệ quản trị cơ sở dữ liệu / Hệ thống quản lý cơ sở dữ liệu (Database Management System - DBMS): Là một ứng dụng hỗ trợ phân tích, thiết kế và quản lý tự động các cơ sở dữ liệu (lưu trữ, xem-thêm-sửa-xoá thông tin trong một nhóm dữ liệu nhất định).

	- Chuyên cung cấp giao diện để người dùng sử dụng những tiện ích như:
		+ Định nghĩa: Tạo ra cấu trúc của dữ liệu (cấu trúc hàng và cột) và các mô tả chi tiết về dữ liệu (kiểu dữ liệu, mối quan hệ giữa các bảng và các ràng buộc).
		+ Xây dụng: Đưa dữ liệu vào bảng và lưu vào bộ nhớ, dựa vào cấu trúc đã định nghĩa trước (nhập giá trị vào đúng cột đã thiết kế).
		+ Xử lý / Thao tác: Truy vấn (xem-thêm-sửa-xoá) dữ liệu và thực hiện tổng hợp, tạo báo cáo.

		-> Thiết kế cấu trúc và khai thác dữ liệu.

	- Đồng thời, giúp các DBA thuận tiện trong việc sao lưu, phục hồi, giám sát hiệu suất, báo cáo dữ liệu, kiểm soát đa truy cập và bảo mật.

		-> (Tạo,) Quản lý và duy trì cơ sở dữ liệu.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Hệ quản trị cơ sở dữ liệu là phần mềm		│
│	giúp tương tác với dữ liệu trong cơ sở dữ liệu	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

Một số đặc điểm (và tiêu chuẩn) của HQTCSDL:

	- Tăng tính chia sẻ dữ liệu khi dữ liệu được quản lý tập trung tại một nơi (Server).
		+ Nhưng vẫn bảo mật dữ liệu bằng cách giới hạn khả năng truy cập (phân quyền) của người dùng hoặc ứng dụng vào dữ liệu.
		+ Đồng thời giải quyết tranh chấp khi cả hai người dùng cùng truy cập và chỉnh sửa trên một dữ liệu, người đến trước sẽ có được quyền tương tác và đặt một khoá cho dữ liệu, người đến sau sẽ không thể chỉnh sửa được vì dữ liệu đang tạm thời bị khoá.

	- Đảm bảo các ràng buộc toàn vẹn (Integrity Constraint), đề ra các quy tắc bắt buộc (Rule) phải tuân theo để dữ liệu phản ảnh đúng với thực tế.

	- Tránh được việc dư thừa và trùng lặp dữ liệu tại nhiều nơi (tối thiểu hoá dư thừa thông tin).
		+ Các dòng thông tin trong cùng một bảng không được phép lặp lại, nhiều người dùng cùng lưu một thông tin thì chỉ có một dòng thông tin được lưu vào cơ sở dữ liệu.
		+ Dựa vào các mối quan hệ giữa các thực thể, xác định những thuộc tính nào của bảng này được phép "chay" sang bảng khác để làm tham chiếu (không phải lưu toàn bộ thuộc tính của bảng này vào bảng khác).
		+ Hạn chế những mẫu tin ma (Phantom Row) khi dữ liệu tự động có mặc dù không thêm.

	- Tăng tính chính xác, nhất quán và chất lượng của dữ liệu khi dữ liệu đã có cấu trúc (được lưu trữ theo hàng và cột), mỗi cột chỉ lưu trữ đúng kiểu dữ liệu mà mình được quy định.

	- Giảm chi phí sao lưu, bảo trì và phục hồi khi gặp sự cố về mất mát dữ liệu hoặc những hư hỏng về phần cứng và phần mềm.

	- Bảo mật và bảo vệ dữ liệu:
		+ Cung cấp các cơ chế bảo mật bằng cách phân quyền và giới hạn quyền truy cập thông qua 4 mức bảo mật.
			1. Máy chủ: Phân quyền truy cập vào máy chủ dữ liệu (bằng tài khoản và mật khẩu).
			2. Cơ sở dữ liệu: Sau khi đã truy cập được vào máy chủ dữ liệu, phân quyền truy cập và tương tác với từng cơ sở dữ liệu.
			3. Bảng: Phân quyền truy cập và tương tác với từng bảng trong cơ sở dữ liệu.
			4. Trường dữ liệu: Phân quyền truy cập và tương tác với từng trường trong bảng.
		+ Bảo vệ dữ liệu bên trong khi có xảy ra tấn công (tạo nên nhiều lớp bảo mật và dữ liệu sẽ không được đính kèm chung với ứng dụng nữa).

Bên cạnh SQL Server của Microsoft, ta còn có nhiều HQTCSDL khác, nhưng tất cả đều sử dụng SQL với cùng một ý tưởng và cách thức hoạt động.

	Vi dụ: Oracle Database, IBM Db2, MongoDB, PostgreSQL, MySQL, Redis, SQLite...
	
------------------------------------------------------------

* Hệ quản trị cơ sở dữ liệu quan hệ (Relational Database Management System - RDBMS): Là dạng phổ biến nhất của HQTCSDL.

	- Hệ thống quản lý cơ sở dữ liệu theo mô hình dữ liệu quan hệ (Relational Data Model).

	- Nhấn mạnh vào tính chất quan hệ giữa các bảng và hỗ trợ các ràng buộc quan hệ giữa các bảng thông qua các khóa chính và khóa ngoại.

	- Yêu cầu tuân thủ theo các quy tắc được gọi là dạng chuẩn (Normal form / Database normalization).

------------------------------------------------------------

Vì là một phần mềm nên Database Engine (HQTCSDL) còn hỗ trợ:

	1. Lập trình (Programming): giống như một môi trường lập trình khi có thể sử dụng các câu lệnh rẻ nhánh...

	2. Kiểu dữ liệu (Data type): hỗ trợ nhiều kiểu dữ liệu khác nhau để có thể lưu được hết tất cả các dữ liệu.

		* Kiểu chuỗi & nhị phân:

			- BINARY: Kích thước tối đa 8000 kí tự.
			- VARBINARY: Kích thước tối đa 8000 kí tự.

			- CHAR: Kích thước tối đa 8000 kí tự.
				+ Xin bao nhiêu, cấp cố định bấy nhiêu.
				+ Chỉ sử dụng khi thật sự biết rõ độ dài cần lưu trữ, vì những kí tự đã xin cấp phát nhưng không sử dụng sẽ tự động được thay bằng những kí tự khoảng trắng về phía bên phải.
				+ Tuy tốn dung lượng, nhưng lại cấp phát rất nhanh vì đã biết trước kích thước cần sử dụng, không cần phải tốn thời gian và tài nguyên để tính toán.
				+ Không chứa kí tự trong bảng mã Unicode.

			- NCHAR: Kích thước tối đa 4000 kí tự.
				- 'N' giúp lưu những kí tự trong bảng mã Unicode.
				- Giống CHAR, nhưng kích thước tối đa ít hơn vì có hỗ trợ lưu trữ những kí tự Unicode.

			- VARCHAR: Kích thước tối đa 8000 kí tự.
				+ Sử dụng bao nhiêu thì cấp bấy niêu, dù trước đó có xin nhiều hơn (biến thiên độ dài).
				+ Giúp tiết kiệm về mặt lưu trữ, nhưng lại tốn về mặt xử lý khi phải tìm vùng nhớ trên ổ đĩa khớp với dung lượng cần sử dụng.
				+ Không chứa kí tự trong bảng mã Unicode.

			- NVARCHAR: Kích thước tối đa 4000 kí tự.
				- 'N' giúp lưu những kí tự trong bảng mã Unicode.
				- Được sử dụng phổ biến nhất, đặc biệt là khi xây dựng những ứng dụng sử dụng cho nhiều quốc gia khác nhau.

			- TEXT: Kích thước tối đa 2 GB.
			- NTEXT:  Kích thước tối đa 1.073.741.823 byte.
			- IMAGE

		* Kiểu số:

			- BIT: Chỉ bao gồm 0, 1 hoặc NULL.
			- DECIMAL
			- NUMERIC
			- FLOAT
			- REAL
			- TINYINT: Từ 0 .. 255.
			- SMALLINT: Từ -32.768 .. 32.767.
			- INT: Từ 2.147.483.648 .. 2.147.483.647.
			- BIGINT
			- MONEY
			- SMALLMONEY

		* Kiểu ngày & giờ:

			- DATE: Có định dạng là yyyy-MM-dd.
			- DATETIME: Có định dạng là yyyy-MM-dd hh:mm:ss[.mmm].
			- DATETIME2
			- DATETIMEOFFSET
			- SMALLDATETIME
			- TIME: Có định dạng là hh:mm:ss.

		(* Tham khảo thêm: https://youtu.be/JitD06kpNpI?si=zA1HDIiIST8pcGGJ&t=479 - Cô Võ Thị Hồng Tuyết - Thực hành tạo bảng và mỗi quan hệ trên SQL Server)

	3. Hàm (Function): có cung một số hàm đã được xây dựng sẵn và chỉ trả về giá trị, ta chỉ việc gọi lên để sử dụng.

		Ví dụ: ABS(), GETDATE(), YEAR(), MONTH()...

	4. Câu lệnh để xử lý dữ liệu (SQL): các câu lệnh được dùng để xử lý những dữ liệu nằm trong bảng.

	5. Toán tử so sánh (Comparison Operator): =, >, >=, <, <=, !=, <>

		- Nếu có nhiều điều kiện lọc đi kèm, có thể sử dụng thêm những toán tử luận lý (Logical Operators).

			* Biểu thức (Expression): Là sự kết hợp giữa các ký hiệu (hằng số, biến số, hàm số, dấu ngoặc, dấu chấm, dấu thay đổi độ ưu tiên...) để tạo nên một công thức toán học.
				Ví dụ: "3 + 7" sẽ là biểu thức gồm có 3 và 7 kết hợp với nhau bằng phép toán cộng.

			* Mệnh đề (Clause): Một câu phát biểu hoặc một biểu thức so sánh (+, -, >, <, =, IS...) với ý nghĩa đúng / sai.
				Ví dụ: "Số 8 là số chẵn" là một mệnh đề đúng.

		- Đặc biệt, để thay thế cho toán tử khác (!= và <>) với nhiệm vụ đảo ngược một điều đang diễn ra, ta có thể sử dụng đảo mệnh đề bằng toán tử NOT.
			+ Toán tử NOT sẽ thường đi kèm với mệnh đề.

	-> Cuối cùng vẫn chỉ trả về dữ liệu thô.

------------------------------------------------------------

* Phân loại HQTCSDL:

	1. Dựa trên mô hình dữ liệu: Song hành với sự ra đời và phát triển của công nghệ thông tin, được phân chia thành các thế hệ dựa theo cấu trúc dữ liệu trong CSDL.

		- Thế hệ đầu tiên:
			+ Hệ thống CSDL phân cấp (Hierarchical).
			+ Hệ thống CSDL mạng (Network).

		- Thế hệ thứ hai:
			+ Hệ thống CSDL quan hệ (Relational).

		- Thế hệ thứ ba:
			+ Hệ thống CSDL hướng đối tượng (Object-Oriented).

	2. Dựa trên số người dùng: HQTCSDL có thể được phân loại dựa trên số lượng người dùng mà nó hỗ trợ.
		- Hệ thống đơn người dùng (Single-user): Hỗ trợ một người dùng tại một thời điểm.
		- Hệ thống đa người dùng (Multi-user): Hỗ trợ nhiều người dùng đồng thời.

	3. Dựa trên vị trí đặt (phân phối) hệ thống:
		- Hệ thống tập trung (Centralized): CSDL và HQTCSDL được tập trung tại một nơi để những ứng dụng khác cùng sử dụng.
		- Hệ thống phân tán (Distributed): CSDL và HQTCSDL được phân tán khắp nơi và kết nối bằng mạng máy tính.
		- Hệ thống phân tán đồng nhất (Homogeneous Distributed): Các ứng dụng sẽ sử dụng cùng một HQTCSDL.
		- Hệ thống phân tán không đồng nhất (Heterogeneous Distributed): Các ứng dụng sẽ sử dụng các HQTCSDL khác nhau, nhưng sẽ có chung một ứng dụng để trao đổi dữ liệu.

Tuỳ thuộc vào dữ liệu, loại ngôn ngữ lập trình và ứng dụng mà sẽ có một hệ cơ sở dữ liệu tương ứng.
	- Vì hệ cơ sở dữ liệu sẽ quyết định hình thức lưu trữ dữ liệu và quyết định cơ chế mà ứng dụng sẽ tương tác với cơ sở dữ liệu.

--------------------------------------------------------------------------------

* Hệ cơ sở dữ liệu (Database System) = (Cơ sở dữ liệu + HQTCSDL + Ứng dụng) + Người dùng CSDL.

--------------------------------------------------------------------------------

* Ngôn ngữ thủ tục (Procedural Language): Thường để ám chỉ các ngôn ngữ lập trình khi người dùng phải chỉ định cả WHAT (yêu cầu) và HOW (các bước thực hiện).
	- Các bước đã thiết kế sẽ được thực thi tuần tự.
	- Được thiết kế như thế nào thì sẽ tự thực thi đúng như vậy, không thể tự phát sinh thêm các bước nếu không được con người thiết kế.
	- Mục đích là để giải quyết các yêu cầu đã đề ra.

	Ví dụ: Các bước để tính giai thừa bằng ngôn ngữ C.

		int main() {

			// Bước 1: Nhập một số nguyên dương n từ bàn phím.
			int n;
			printf("Hay nhap mot so nguyen duong: ");
			scanf("%d", &n);

			// Bước 2: Bắt đầu tính giai thừa.
			int acc = 1;

			// 2.1. Kiểm tra điều kiện đặc biệt
			if (n == 0 || n == 1)
				return 1;

			// 2.2. Sử dụng vòng lặp từ 2..n để tính giai thừa
			for (int i = 2; i <= n; i++)
				acc *= i;
			
			// Bước 3: Hiển thị kết quả tính.
			printf("%d! = %d\n", n, acc);

			return 0;			
		}

* Ngôn ngữ phi thủ tục (Non-procedural Language / Applicative Language / Functional Language): Người chỉ cần chỉ định WHAT (yêu cầu), không cần chỉ định HOW (các bước thực hiện).

	Ví dụ: Lấy ra danh sách sinh viên có điểm trung bình lớn hơn 7.

		SELECT name
		FROM Students
		WHERE gpa > 7;

		-> Chỉ nói nhu cầu, không chỉ cách làm.

* Ngôn ngữ dữ liệu / Ngôn ngữ cho CSDL (Database Language): Là ngôn ngữ để thiết kế cấu trúc cho CSDL, cho phép truy cập và thao tác trên dữ liệu của CSDL.
	- Là tập hợp các mệnh lệnh do HQTCSDL định nghĩa, tuỳ thuộc vào HQTCSDL mà sẽ có những tập lệnh tương ứng.
	- Chỉ những mệnh lệnh này mới được HQTCSDL thực thi.

* Ngôn ngữ quan hệ (Relational Language): Là ngôn ngữ được sử dụng để truy vấn và thao tác với dữ liệu trong CSDL quan hệ (dữ liệu trong dòng và cột của bảng).

	- Đại số quan hệ (Relational Algebra) và Phép toán quan hệ (Relational Calculus) là hai dạng chính của ngôn ngữ quan hệ.

		+ Đại số quan hệ (Relational Algebra): Được sử dụng để thực hiện các phép toán trên dữ liệu.

			Ví dụ: Tìm tất cả tựa sách xuất bản năm 2000.
				π(Book name) ( σ (yr_pub=2000) (book) )

		+ Phép toán quan hệ (Relational Calculus): Được sử dụng để mô tả điều kiện cụ thể mà dữ liệu cần thỏa mãn để trích xuất, không quan tâm thứ tự thực hiện truy xuất mà chỉ quan tâm kết quả.

			Ví dụ: Tìm tất cả tựa sách xuất bản năm 2000.
				S = { t | ∃ u ∈  book (t[book name] = u[book name]) ∧ (u[yr_pub] = 2000 ) }

	- Giúp phân rã các yêu cầu của người dùng và hướng dẫn HQTCSDL thực hiện chúng.

------------------------------------------------------------

* Structured Query Language (SQL): Là một trong những ngôn ngữ truy vấn (hỏi/đáp, thao tác) cơ sở dữ liệu quan hệ phổ biến nhất, được sáng chế bởi IBM vào những năm 1970.

	- Là ngôn ngữ được sử dụng rộng rãi để quản lý cơ sở dữ liệu quan hệ.
		+ Gồm những câu lệnh cho phép tương tác với chính cấu trúc của cơ sở dữ liệu bằng các lệnh: Tạo mới, thêm-sửa, xoá... bảng (Table) trong cơ sở dữ liệu.
		+ Ngoài ra, SQL còn giúp giao tiếp với Server để xem-thêm-sửa-xoá... khai thác dữ liệu bên trong các bảng của một cơ sở dữ liệu quan hệ.
		+ Và còn nhiều câu lệnh khác để thực hiện những công việc có liên quan như: gán và gỡ quyền truy cập vào dữ liệu, sao lưu và phục hồi dữ liệu,...

	- Là một ngôn ngữ dữ liệu, nhưng tuỳ thuộc vào ngữ cảnh sử dụng mà có thể là ngôn ngữ thủ tục hoặc phi thủ tục.

	- Người dùng sẽ gõ những câu lệnh ở dạng văn bản, sau đó Client sẽ chịu trách nhiệm mã hoá và chuyển sang cho Server để Server xử lý và trả kết quả lại về cho người dùng.

	- Ban đầu, khi tạo ra ngôn ngữ này, IBM đặt tên nó là SEQUEL (viết hoa tất cả).
		+ Là viết tắt của cụm từ Structured English Query Language (Ngôn ngữ truy vấn tiếng Anh có cấu trúc).
		+ Cú pháp của ngôn ngữ rất giống cú pháp của tiếng Anh, nhưng nó có cấu trúc chặt chẽ hơn tiếng Anh thông thường.
		+ Khi chuẩn bị ra mắt, IBM phát hiện ra đã có một công ty khác đăng ký bản quyền cho cái tên SEQUEL rồi, nên IBM đã bỏ các nguyên âm đi và gọi ngôn ngữ của họ là SQL.

	-> Ngôn ngữ giúp giao tiếp với Database Engine.

----------------------------------------

Các câu lệnh (Command) của SQL thường được phân loại thành các nhóm ngôn ngữ:

	1. Ngôn ngữ định nghĩa dữ liệu (Data Definition Language - DDL): Là những câu lệnh cho phép tương tác trên cấu trúc của một cơ sở dữ liệu / bảng (chứ không phải dữ liệu bên trong).

		- Cho phép thay đổi cấu trúc của bảng như: thêm-sửa-xoá bảng và tạo ra các chỉ mục để hỗ trợ truy xuất dữ liệu.

		- Cho phép BDA hoặc người dùng miêu tả và đặt tên cho các thực thể, thuộc tính và các mối kết hợp cần thiết của ứng dụng.

		- Ngoài ra, DDL còn được dùng để tạo ra sự toàn vẹn trong kết hợp dữ liệu (Associated Integrity) và sự ràng buộc an toàn dữ liệu (Security Constraint).

			Ví dụ: Các ràng buộc.
				- Điểm của sinh viên phải từ 0..10.
				- Giới tính chỉ có ba giá trị.
				- Một khách chỉ được phép chuyển tiền 10 lần/ngày.

		- Có thể tưởng tượng rằng đây là những câu lệnh để tạo lớp (Class) trong lập trình hướng đối tượng (Object Oriented Programming - OOP).

		-> Tương tác ở mức toàn bảng / cơ sở dữ liệu.

		- CREATE: Tạo mới một bảng / CSDL (chưa có dữ liệu bên trong).
		- DROP: Xoá một bảng / CSDL (kèm những dữ liệu bên trong).
		- ALTER: Chỉnh sửa lại cấu trúc của một bảng / CSDL (thường là cột thuộc tính).
		- TRUNCATE: Xóa tất cả hàng khỏi bảng và giải phóng không gian chứa bảng / CSDL.
		- RENAME: Thay đổi tên của bảng / CSDL.

	2. Ngôn ngữ truy vấn dữ liệu (Data Query Language - DQL): Câu lệnh cho phép lấy dữ liệu từ cơ sở dữ liệu sẵn có và thao tác với dữ liệu lấy được mà không làm ảnh hưởng đến dữ liệu gốc, vì kết quả đã được biên dịch thành một bảng tạm khác.
		-> Chỉ xem nội dung bên trong bảng.

		- SELECT: Lấy dữ liệu lên để tính toán hoặc chỉ đơn giản là hiển thị ra bên ngoài.

	3. Ngôn ngữ thao tác dữ liệu (Data Manipulation Language - DML): Là những câu lệnh cho phép thao tác với dữ liệu trong cơ sở dữ liệu.
		- Là ngôn ngữ phi thủ tục (Non-procedural), cho phép người dùng chỉ cần đưa ra yêu cầu, còn chi tiết cách thực hiện sẽ do HQTCSDL lo (trái ngược với ngôn ngữ lập trình khi các lập trình viên phải hướng dẫn từng bước cho máy tính).
		- Đối với những hành động thường xuyên lặp lại, DML cũng cho phép thiết kế các thủ tục / hàm (Stored Procedure) để nhanh chóng tương tác với CSDL.
		- 
		-> Tương tác ở mức bên trong bảng.

		- INSERT: Chèn thêm một dòng dữ liệu vào bảng.
		- UPDATE: Cập nhật hoặc sửa đổi giá trị của một cột trong bảng.
		- DELETE: Xoá một dòng dữ liệu khỏi bảng.
		- CALL: Câu lệnh liên quan đến lập trình, có nhiệm vụ gọi một hàm của cơ sở dữ liệu.
		- EXPLAIN CALL

	4. Ngôn ngữ điều khiển dữ liệu (Data Control Language - DCL): Là những câu lệnh cấu hình và phân quyền, thường được những DBA sử dụng để giới hạn quyền thao tác trên dữ liệu của người dùng (tác động lên 3 ngôn ngữ DDL, DQL và DML).

		- GRAND: Trao quyền cho người dùng.
		- REVOKE: Thu hồi quyền đã trao cho người dùng.

	5. Ngôn ngữ kiểm soát giao tác trên CSDL (Transaction Control Language - TCL): Là những câu lệnh cho phép trao đổi, thay đổi trạng thái của một số dữ liệu, kiểm soát việc xử lý các giao tác trong CSDL.

		- COMMIT: Lưu tất cả các thao tác khi thực hiện trên CSDL.
		- SAVEPOINT
		- ROLLBACK
		- SET TRANSACTION
		- SET CONSTRAINT

(* Tham khảo thêm: https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/)

------------------------------------------------------------

* Đại số quan hệ (Relational Algebra - RA): Là mô hình toán học, lý thuyết chạy ngầm đằng sau Database Engine, giúp hiện thực hoá các câu lệnh SQL.

	- Chỉ hoạt động trên giấy, không thể hoạt động trên máy tính.

	- Bao gồm những phép toán để xử lý dữ liệu.

	- Thuật toán của đại số quan hệ chính là các câu lệnh SQL.

	- Toàn bộ dữ liệu sẽ được lưu trữ ở dạng tập hợp các bit nhị phân, do Database Engine thực hiện bằng toán học.

		Ví dụ:
			- Câu lệnh WHERE trong SQL -> Phép chọn (σ) trong Đại số quan hệ
			- Câu lệnh SELECT trong SQL -> Phép chiếu (π) trong Đại số quan hệ

------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Đại số quan hệ cung cấp "lý thuyết" toán học,		│
│	mô tả trừu tượng cách truy vấn và thao tác dữ liệu	│
│								│
│	SQL là ngôn ngữ truy vấn cụ thể để "thực hành" truy vấn,│
│	dựa trên các nguyên tắc của Đại số quan hệ		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

Về bản chất, vì cơ sở dữ liệu sẽ không có giao diện và chỉ hoạt động ngầm (background) để cung cấp tính năng / dịch vụ (Service) cho một nơi khác để sử dụng, nên ta hoàn toàn có thể tương tác dưới dạng thô / nguyên thuỷ thông qua một công cụ với giao diện đồ hoạ người dùng (GUI).

	- Dữ liệu trên ổ cứng dữ sẽ được lưu dưới dạng nhị phân, sau đó sử dụng một công cụ (Client tool) để hiển thị dưới dạng bảng (Table) và cho phép tương tác thông qua những câu lệnh SQL.

	- Toàn bộ những câu lệnh sẽ được công cụ đồ hoạ (Client) gửi lên Server ngầm (hoạt động ở chế độ dịch vụ - Service) để Server xử lý và trả về kết quả.

		Ví dụ:
			1. Tạo mới một truy vấn bằng nút [New Query]
			2. Thực thi câu lệnh, chẳng hạn như chọn cơ sở dữ liệu: USE tên-cơ-sở-dữ-liệu
			3. Nhấn nút thực thi [Execute]

	- Server sẽ có nhiệm vụ quản lý và chuyển những dữ liệu ở dạng thô thành dạng đẹp, sau đó cung cấp cho ngôn ngữ lập trình để cuối cùng hiển thị ra giao diện cho người dùng.

	-> Thao tác với dữ liệu ở dạng thô, không bị che / ẩn giấu bởi những giao diện người dùng (GUI).

==========================================================================================
==========================================================================================
==========================================================================================

[BÊN TRONG MỘT HỆ QUẢN TRỊ CƠ SỞ DỮ LIỆU - DATABASE ENGINE INSIDE]

Các thành phần của một HQTCSDL, cụ thể là Microsoft SQL Server:
	- Ngôn ngữ giao tiếp giữa người dùng và CSDL.
	- Database: Là một dịch vụ (Servcie) chạy ngầm trong Windows (MSSQLSERVER), cho phép tạo CSDL và thực hiện truy vấn.
	- Data Communication: Cho phép truyền dữ liệu giữa các máy.
	- Database Dictionary: Cho phép định nghĩa và xem từ điển của CSDL.

--------------------------------------------------------------------------------

Kiến trúc 3 mức ANSI-SPARC (ANSI-SPARC Three-level architecture) trong các HQTCSDL.
	- Được đề xuất lần đầu vào năm 1975, được đặt tên theo tiêu chuẩn của Viện Tiêu chuẩn Quốc gia Hoa Kỳ (American National Standards Institute - ANSI) và Hội nghị Các nhà nghiên cứu về Hệ thống Cơ sở dữ liệu và Ứng dụng (Standards Planning And Requirements Committee - SPARC).
	- Giúp mọi người dùng đều có thể truy xuất được dữ liệu như nhau.
	- Góc nhìn (View) của người dùng này không bị thay đổi khi các góc nhìn khác bị thay đổi.
	- Người dùng chỉ cần biết cách sử dụng, không cần biết chi tiết cách CSDL được lưu trữ (mức vật lý, được người thiết kế CSDL xây dựng nên).
		+ Người quản trị CSDL (BDA) có thể thay đổi cấu trúc lưu trữ CSDL (cấu trúc mức ý niệm) mà không làm ảnh hưởng đến góc nhìn của người dùng.
		+ Cấu trúc mức trong của CSDL không bị ảnh hưởng bởi sự thay đổi các yếu tố mức vật lý.

	-> Tăng khả năng độc lập dữ liệu, tách biệt giao diện người dùng với cách cơ sở dữ liệu được biểu diễn vật lý.

------------------------------------------------------------

Kiến trúc này bao gồm ba mức để biểu diễn một CSDL:

	1. Mức ngoài (External Level / View Level).
		- Đây là mức giao diện người dùng / nhóm người dùng.
			+ Thể hiện quan điểm của người dùng về CSDL (người dùng quan tâm đến phần dữ liệu nào trong CSDL).
			+ Bao gồm các góc nhìn (View) của người dùng, nơi người dùng tương tác với hệ thống.
		- Miêu tả từng phần của CSDL có liên quan đến từng người dùng và những dữ liệu ấy giống thế giới thực đến mức nào.
		- Chỉ hiển thị phần dữ liệu mà người dùng cần, không hiển thị toàn bộ dữ liệu trong CSDL.
		- Không đi vào chi tiết về cấu trúc tổ chức, mối quan hệ của dữ liệu, kiểu dữ liệu,... (che giấu đi những phần còn lại của CSDL).

		-> Dữ liệu hiển thị ra cho người dùng như thế nào.

		Ví dụ 1: Tuy giảng viên có rất nhiều thông tin (mã, tên, năm sinh, quê quán, số điện thoại, email, bằng cấp, bậc lương, số năm kinh nghiệm,...), nhưng dưới góc nhìn của một sinh viên, chỉ một số thông tin được hiển thị (mã, tên, email).

		Ví dụ 2: Để tiện cho việc xem thông tin, tuổi sẽ được tính toán và hiển thị đối với người dùng, nhưng khi lưu trong CSDL thì chỉ lưu ngày-tháng-năm sinh.

	2. Mức ý niệm / Mức luận lý (Conceptual Level / Logic Level).
		- Là một góc nhìn (View) tổng quát cho cả CSDL, miêu tả tổng quát (trừu tượng) dữ liệu gì được lưu trong CSDL và mối quan hệ giữa các dữ liệu đó ra sao.
		- Là một lược đồ liệt kê tất cả các thuộc tính (dữ liệu) cần lưu trữ và quan hệ giữa chúng, chưa bao gồm kiểu dữ liệu.

		-> Dữ liệu nào cần lưu trữ và liên quan đến nhau như thế nào.

	3. Mức trong / Mức vật lý (Internal Level / Physical Level).
		- Là sự thể hiện ở mức vật lý của CSDL trên máy tính, miêu tả chi tiết dữ liệu được lưu trữ và tổ chức như thế nào trên thiết bị lưu trữ vật lý.
		- Là các thuộc tính (dữ liệu) đi kèm với kiểu dữ liệu.
		- Giúp xác định các phương pháp tiếp cận, cách tổ chức tệp, cách truy xuất (tuần tự hay ngẫu nhiên), phương pháp lập chỉ mục và cấu trúc lưu trữ được sử dụng để tối ưu hóa hiệu suất truy xuất dữ liệu.
		- Tuỳ thuộc vào hệ quản trị CSDL mà sẽ có ngôn ngữ dữ liệu tương ứng.

		-> Cơ sở dữ liệu được lưu trữ và truy xuất trong máy tính như thế nào.

--------------------------------------------------------------------------------

* Mô hình dữ liệu (Data Model) / Cấu trúc dữ liệu (Data Structure): Là sơ đồ (tập khái niệm và ký hiệu) về cách thức tổ chức, lưu trữ và truy xuất dữ liệu, các mối quan hệ và các ràng buộc giữa các dữ liệu.

	- Được xây dựng trong giai đoạn thiết kế dữ liệu (có thể thực hiện trước hoặc sau khi chọn HQTCSDL), sau khi nhận được yêu cầu phần mềm từ các bên có liên quan.

	- Sau đó, dữ liệu sẽ được biểu diễn dưới dạng sơ đồ và các kí hiệu nhờ vào quá trình mô hình hoá dữ liệu (Data Modeling).
		+ Chỉ biểu diễn ở mức trừu tượng, không đi vào chi tiết.
		+ Để vẽ được sơ đồ, ngoài các kí hiệu, ta còn cần thêm một bộ quy tắc để kết hợp các kí hiệu lại với nhau.

	- Việc mô hình hoá dữ liệu (Data Modeling) giúp xác định:

		+ Dữ liệu có trong CSDL.
			Ví dụ: Các thực thể: sinh viên, giảng viên, khóa học, môn học,...

		+ Mối quan hệ giữa các thực thể.
			Ví dụ:
				- Sinh viên được giảng viên giám sát.
				- Giảng viên giảng dạy các khóa học.

		+ Các ràng buộc về dữ liệu.
			Ví dụ:
				- Mã số sinh viên có chính xác tám chữ số.
				- Một môn học sẽ có ba, bốn hoặc tám đơn vị tín chỉ.

	- Biểu diễn dữ liệu theo cách dễ hiểu nhất để nhìn vào mô hình là biết dữ liệu sẽ được tổ chức như thế nào trong CSDL và được lưu trữ thực tế như thế nào trên máy tính.
		+ Giúp đánh giá sự thiếu/đủ của dữ liệu được thiết kế so với yêu cầu của khách hàng.
		+ Giúp hình dung nhanh những dữ liệu sẽ có trong hệ thống và tránh những tổn thất lớn khi CSDL được đưa vào vận hành thật sự.

	- HQTCSDL sẽ sử dụng mô hình dữ liệu để tạo và quản lý CSDL theo các quy tắc được xác định trong mô hình.

	-> Quá trình tìm hiểu cấu trúc và mối quan hệ của dữ liệu.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Mô hình dữ liệu giúp hiểu rõ cấu trúc dữ liệu	│
│	và quan hệ giữa các phần tử trong CSDL		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------------------------------------

Một mô hình dữ liệu sẽ gồm 3 thành phần:
	1. Cấu trúc (Structure) của dữ liệu: CSDL được tổ chức từ các thành phần nào.
	2. Ràng buộc (Constraint) giữa các dữ liệu: Đảm bảo dữ liệu không bị sai sót.
	3. Phép toán xử lý (Operation) trên dữ liệu: Những thao tác trên dữ liệu.

------------------------------------------------------------

Có 3 loại mô hình dữ liệu khác nhau trong xây dựng hệ CSDL (Database System): Mỗi loại tương ứng với một giai đoạn, cố gắng đưa CSDL đến gần hơn với thực tế.

	1. Mô hình dữ liệu ý tưởng / ý niệm / quan niệm / khái niệm (Conceptual Data Model / Domain Model): Nhìn vào một vấn đề thực tế, từ những mô tả về phần mềm của khách hàng, suy ra những dữ liệu cần lưu trữ là gì bằng một sơ đồ.
		- Cho biết hệ thống chứa những dữ liệu gì (WHAT), giống như thế giới thực.
		- Là một sơ đồ tổng quát (mức trừu tượng cao nhất) khi chỉ tập trung vào thực thể và mối liên kết (có thể có hoặc không có thuộc tính của thực thể).
		- Sau này, chỉ cần nhìn vào sơ đồ thay vì phải liên ục đọc lại yêu cầu phần mềm.

		-> Tập trung vào đối tượng cần biểu diễn.

	2. Mô hình dữ liệu luận lý (Logical Data Model / Representational Data Model).
		- Cho biết hệ thống sẽ được triển khai thế nào mà chưa cần đến HQTCSDL (HOW WITHOUT DBMS).
		- Bao gồm đại số quan hệ (Relational Algebra) và phép tính quan hệ (Relational Calculus).
		- Thuộc tính của thực thể sẽ có thêm kiểu dữ liệu, miền giá trị và khoá chính.
		- Áp dụng dạng chuẩn hoá (Normalization) thứ ba - 3NF.

	3. Mô hình dữ liệu vật lý (Physical Data Model): Mô tả cách mà hệ thống dữ liệu được triển khai bằng một HQTCSDL.
		- Cho biết hệ thống thực sự được triển khai như thế nào và dữ liệu sẽ được lưu trữ bằng HQTCSDL (HOW WITH DBMS).
		- Để máy tính có thể hiểu được, cần tiếp tục chuyển thành những sơ đồ ở mức vật lý.
		- Cho biết dữ liệu được triển khai, lưu trữ thực tế trong máy tính như thế nào.
		- Cồn một HQTCSDL cụ thể.

		-> Tập trung vào cách thức biểu diễn.

	-> Cho thấy dữ liệu được biểu diễn từ nhiều góc độ khác nhau.

	* Bảng so sánh (chỉ mang tính tương đối, vì mỗi nơi lại đang có một cách định nghĩa khác nhau về 3 loại mô hình dữ liệu).

	-------------------------------------------------------------------------
	|			|  Ý niệm	|    Luận lý	|   Vật lý	|
	|-----------------------------------------------------------------------|
	| Thực thể		|	x	|	x	| Được thay bằng|
	|			|		|		| tên bảng	|
	|-----------------------|---------------|---------------|---------------|
	| Mối kết hợp		|	x	|	x	| Bảng trung 	|
	|			|		|		| gian nếu n-n	|
	|-----------------------|---------------|---------------|---------------|
	| Thuộc tính		|      [x]	|	x	| Được thay bằng|
	|			|		|		| tên cột	|
	|-----------------------|---------------|---------------|---------------|
	| Khoá chính		|      [x]	|	x	|	x	|
	|-----------------------|---------------|---------------|---------------|
	| Khoá ngoại		|		|      [x]	|	x	|
	|-----------------------|---------------|---------------|---------------|
	| Kiểu dữ liệu của tt	|		|		|	x	|
	-------------------------------------------------------------------------

		(Cặp dấu "[]" đại diện cho việc có hoặc không, tuỳ theo cách nhìn nhận của từng tác giả.)

------------------------------------------------------------

Lập mô hình dữ liệu (trong HQTCSDL quan hệ):

	- Mô hình dữ liệu thực thể - mối kết hợp (Entity-Relationship Data Model - E-R Model).
		+ Thường được gọi tắt là "mô hình thực thể kết hợp".
		+ Được đề xuất bởi Peter Pin-Shan Chen (Peter Chen / PP Chen) vào năm 1976.
		+ Tồn tại ở mức ý niệm (Conceptual).
		+ Được xây dựng dựa trên việc nhận thức thế giới thực thông qua tập các đối tượng (được gọi là các thực thể), các thuộc tính của đối tượng và các mối quan hệ giữa các đối tượng này.
		+ Từ đó xây dựng nên mô hình dưới dạng đồ thị vô hướng (không có các đường mũi tên để chỉ hướng).
		+ Giúp phân tích dữ liệu, xác định các đơn vị thông tin cơ bản cần thiết của tổ chức, mô tả cấu trúc và mối liên hệ giữa chúng.

		-> Cho một cái nhìn tổng quan về CSDL mà không cần phải xây dựng CSDL.

		(* Lưu ý: Trong E-R Model, Relationship sẽ được dịch là "mối kết hợp" để tránh nhầm lẫn với Relational trong R Model khi cũng có nghĩa là "mối quan hệ".)

	- Mô hình dữ liệu quan hệ (Relational Data Model - R Model).
		+ Thường được gọi tắt là "mô hình quan hệ".
		+ Được đề xuất bởi Edgar Frank "Ted" Codd (Edgar F. Codd / EF Codd) vào năm 1970.
		+ Tồn tại ở mức luận lý (Logical).
		+ Được xây dựng dựa trên lý thuyết về tập hợp và quan hệ, các phép toán thao tác với dữ liệu được mô tả bằng ĐSQH.
		+ Thay vì chỉ sử dụng những hình vẽ với một bộ kí hiệu được quy ước riêng, ta sử dụng các bảng để biểu diễn thông tin và mối quan hệ giữa chúng (và nhiều bảng sẽ tạo thành một CSDL).
		+ Mỗi bảng tượng trưng cho một thực thể, cho phép trực tiếp hình dung được các câu lệnh (các cách) để thao tác với dữ liệu.
		+ Các ràng buộc:
			1. Ràng buộc trên dữ liệu: Ràng buộc về kiểu dữ liệu, miền giá trị tối thiểu và tối đa,...
			2. Ràng buộc về tổ chức dữ liệu: Nếu có dữ liệu trong bảng này thì phải tồn tại trong bảng khác,...

		-> Dựa vào cách quản lý trong thực tế.

		(CSDL được tổ chức theo mô hình quan hệ được gọi là CSDL quan hệ - Relational Database, phần mềm sử dụng để duy trì CSDL quan hệ là HQTCSDL quan hệ - RDBMS.)

==========================================================================================
==========================================================================================
==========================================================================================

[THIẾT KẾ CƠ SỞ DỮ LIỆU - DATABASE DESIGN]

Có nhiều giai đoạn trong quá trình thiết kế cơ sở dữ liệu, mỗi giai đoạn có những mô hình dữ liệu (ý niệm, luận lý và vật lý) tương ứng.

Mục đích thiết kế:
	- Đáp ứng được các yêu cầu của người dùng.
	- Cung cấp cấu trúc thông tin hợp lý và hiệu quả cho quá trình hoạt động của ứng dụng.
	- Hỗ trợ được tất cả các yêu cầu của chương trình trong quá trình vận hành.

--------------------------------------------------------------------------------

* Vòng đời phát triển CSDL (Database Life Cycle): Các bước phải trải qua để có được một CSDL.

------------------------------------------------------------

	1. Thu thập và phân tích yêu cầu (Requirements Gathering / Problem Defined): Kỹ thuật lấy yêu cầu của một bài toán (nghiệp vụ) trong thực tế từ phía khách hàng để bắt đầu phân tích yêu cầu.

		- Khách hàng có thể cung cấp những thông tin gì về nghiệp vụ để biết hệ thống yêu cầu có những tính năng gì và cần lưu trữ những dữ liệu gì.
			+ Mục tiêu là cố gắng thu thập sao cho đúng nhất với những vận hành thực tế của khách hàng.
			+ Có được càng nhiều thông tin thì sẽ càng dễ dàng cho các bước thiết kế ở phía sau.

		- Sau đó chọn lọc thông tin và trao đổi lại với khách hàng (nếu cần) để:
			+ Xác định được những thực thể và thuộc tính của thực thể.
			+ Xác định mối quan hệ giữa các thực thể và thuộc tính của những mối kết hợp (nếu có).

------------------------------------------------------------

	2. Thiết kế ở mức trừu tượng (Conceptual Design): Vẽ những sơ đồ ở mức độ ý niệm.

		- Nguyên tắc của những công trình lớn là luôn luôn phải có những bảng thiết kế, giúp tách ra khỏi những gì cụ thể.

		- Biểu diễn lại những yêu cầu phức tạp về dữ liệu bằng một loại sơ đồ.
			+ Gom những gì chung nhất của các thực thể thành một giàn khung.
			+ Không nhất thiết phải có kiểu dữ liệu, kiểu dữ liệu chỉ cần khi bắt đầu thiết kế CSDL ở mức vật lý hoặc khi bắt đầu lập trình.

		- Được sử dụng để trao đổi giữa người thiết kế và khách hàng (người dùng).
			+ Sơ đồ này sẽ không bao gồm những chi tiết liên quan đến kĩ thuật để các bên có liên quan có thể đọc được.
			+ Đảm bảo rằng người thiết kế đã nắm được đầy đủ các thực thể, thuộc tính và mối quan hệ cần lưu trữ.

------------------------------------------------------------

	3. Logical Design (Data Model Mapping) & Implementation: Hiện thực hoá các sơ đồ ý tưởng thành các sơ đồ mức luận lý, sau đó chuyển đổi thành các câu lệnh (bảng trong cơ sở dữ liệu).

		- Các hệ quản trị khác nhau có thể sẽ có khác nhau đôi chút về cú pháp để tạo dựng giàn khung lưu trữ dữ liệu, nhưng các khái niệm thì vẫn không thay đổi.

		- Mô tả những dữ liệu nào sẽ được lưu trữ trong cơ sở dữ liệu. Bao gồm các thuộc tính, kiểu dữ liệu và mối quan hệ của chúng với nhau.

		- Để xử lý, Database Engine sẽ chuyển các câu lệnh thành mô hình toán học - ĐSQH.

		- Sử dụng ngôn ngữ truy vấn cơ sở dữ liệu (ví dụ: SQL) để tạo bảng và chỉnh sửa cấu trúc cơ sở dữ liệu.

------------------------------------------------------------

	4. Execution / Populating: Đưa dữ liệu vào, thực thi các thiết kế để cho ra được kết quả.

==========================================================================================

[PHÂN TÍCH - MỨC Ý NIỆM]

	(Thuật ngữ Diagram đôi khi còn được gọi là Schema Diagram / Scheme Diagram.)

* Lược đồ thực thể - mối kết hợp (Entity-Relationship Diagram - ERD):

	- Hay còn được biết đến là Peter Chen Notation / Crow's Foot Notation, là một tập các kí hiệu đã được quy ước sẵn.

	- Cho phép tạo nên một bản vẽ thiết kế CSDL ở mức ý niệm (trực quan hóa E-R Model), biểu diễn trừu tượng cấu trúc tổng thể của CSDL.
		+ Liệt kê danh sách các thực thể (đối tượng) cần quản lý, đi kèm với thuộc tính và mối kết hợp giữa các thực thể.
		+ Liệt kê một số ràng buộc dữ liệu đơn giản (không phải ràng buộc về kiểu dữ liệu), ví dụ: Một Sinh viên chỉ được học tối đa 2 Khoa.
		+ Không liệt kê các thao tác trên dữ liệu (hành động).

		-> Giúp xác định thực thể, thuộc tính và mối kết hợp giữa các thực thể.

	* Cấu trúc của E-R Model - Các thành phần chính:

		1. Thực thể / Đối tượng (Entity / Object): Là một đối tượng cần được lưu trữ và quản lý, đại diện cho một sự vật hoặc hiện tượng trong thế giới thực.
			- Trong sơ đồ, thường được vẽ bằng hình chữ nhật.
			- Tên của thực thể sẽ là một danh từ hoặc cụm danh từ, ví dụ: NhânViên, HoáĐơn, HồSơ, GiaoDịch,...

			(* Lưu ý: Khi vẽ sơ đồ, không liệt kê những thực thể không có thuộc tính hoặc những thực thể mà ta đang đi thiết kế ERD cho nó.)

		2. Tập thực thể / Kiểu thực thể / Lớp thực thể (Entity Set / Entity Type): Gồm nhiều đối tượng có những điểm giống nhau, tạo thành một tập thực thể chia sẻ chung đặc điểm.
			- Là khuôn mẫu để lưu trữ nhiều đối tượng cùng loại.
			- Mỗi đối tượng được tạo ra từ một tập thực thể đều sẽ có những thuộc tính giống nhau (chỉ khác giá trị bên trong thuộc tính).
			- Tương đương với lớp (Class) trong lập trình hướng đối tượng (OOP).

			Ví dụ: Từng con người tự do ngoài đời với rất nhiều thông tin khác nhau...
				- Tụ họp lại tại một nơi và chọn lọc ra những thông tin cần lưu trữ như: tên, năm sinh, quê quán, email, số điện thoại, ngày vào học, môn học, điểm số, điểm rèn luyện, học phí,...
				- Bỏ qua những thông tin không cần thiết như: chiều cao, cân nặng, nhóm máu, màu tóc, danh sách bạn bè, công việc làm thêm,...
				- Tạo thành một tập thể sinh viên của một trường học.

			(* Lưu ý: Thông thường, khái niệm về tập thực thể sẽ bị bỏ qua và sử dụng khái niệm về thực thể để thay thế.
				Tập thực thể -> Thực thể
				Từng thực thể trong tập thực thể -> Đối tượng)

		3. Thuộc tính (Attribute): Từng đặc điểm riêng biệt của một thực thể hoặc mối kết hợp, giá trị trong thuộc tính (được quy định bởi kiểu dữ liệu) sẽ giúp tạo nên sự khác biệt (đặc trưng) giữa các thực thể.
			- Trong sơ đồ, thường được vẽ bằng hình elip.
			- Tên của thuộc tính sẽ là một danh từ hoặc cụm danh từ, ví dụ: MãNhânViên, TênPhòngBan, ĐơnGiá,...

		4. Mối kết hợp / Mối liên kết / Mối liên quan / Mối quan hệ (Relationship): Mối quan hệ hai chiều giữa các thực thể với nhau.

			- Trong sơ đồ, thường được vẽ bằng hình thoi.

			- Kiểu liên kết (Type): Tên của mối kết hợp (ví dụ: <Làm việc cho>, <Thuộc>, <Có>, <Quản lý>,...).
				+ Tên của mối kết hợp phải là động từ, giới từ hoặc bổ ngữ.

			- Giữa hai thực thể, có thể có nhiều mối kết hợp khác nhau.

				Ví dụ: Thực thể NhânViên có hai mối kết hợp khác nhau với thực thể PhòngBan.
					| NhânViên |―――――< Làm việc >―――――| PhòngBan |
					| NhânViên |―――――< Là trưởng phòng >―――――| PhòngBan |

			- Đặc biệt, mặc dù chỉ là mối kết hợp, nhưng vẫn được phép có những thuộc tính riêng của mình.
				+ Thuộc tính sẽ được gắn với mối kết hợp khi nó không thể thuộc về bất kì thực thể nào khác.
				+ Thuộc tính sẽ chỉ bắt đầu phát sinh (bắt đầu có ý nghĩa) khi hai thực thể bắt đầu phát sinh mối kết hợp với nhau (khi có mối liên kết thì mới cần đến thuộc tính này).
				+ Thuộc tính này thường liên quan đến nhiều thực thể khác nhau, nên sẽ không thể thuộc về riêng thực thể nào, mà bắt buộc phải thuộc về mối liên kết giữa các thực thể.
				+ Chủ yếu diễn ra trong các mối kết hợp nhiều-nhiều.

				-> Thuộc tính bắt đầu phát sinh chỉ khi hai thực thể bắt đầu có mối kết hợp.

				Ví dụ 1: NhânViên <LàmTrưởngĐơnVị> ĐơnVị, mối kết hợp "LàmTrưởngĐơnVị" sẽ có thuộc tính đi kèm là NgàyKíQuyếtĐịnh.
					- Thuộc tính NgàyKíQuyếtĐịnh chỉ bắt đầu có ý nghĩa khi NhânViên thực sự LàmTrưởngĐơnVị trong ĐơnVị (khi nhân viên bắt đầu được bổ nhiệm chức vụ).
					- Nếu NhânViên không LàmTrưởngĐơnVị trong ĐơnVị thì thuộc tính này sẽ không tồn tại.
					-> NgàyKíQuyếtĐịnh không thể thuộc về NhânViên hay ĐơnVị.

				Ví dụ 2: NhânViên <ThamGia> DựÁn, mối kết hợp "ThamGia" sẽ có thuộc tính đi kèm là SốGiờLàmViệc.
					- Thuộc tính SốGiờLàmViệc chỉ bắt đầu có ý nghĩa khi NhânViên thực sự ThamGia trong DựÁn (khi nhân viên bắt đầu được phân công vị trí công việc).
					- Nếu NhânViên không ThamGia trong DựÁn thì thuộc tính này sẽ không tồn tại.
					-> SốGiờLàmViệc không thể thuộc về NhânViên hay DựÁn.

				Ví dụ 3: Sách <Thuộc> PhiếuMượnSách, mối kết hợp "Thuộc" sẽ có thuộc tính đi kèm là NgàyTrảSách.
					- Thuộc tính NgàyTrảSách chỉ bắt đầu có ý nghĩa khi Sách thực sự Thuộc vào PhiếuMượnSách (khi có người bắt đầu mượn sách).
					- Nếu Sách không Thuộc vào PhiếuMượnSách thì thuộc tính này sẽ không tồn tại.
					-> NgàyTrảSách không thể thuộc về Sách hay PhiếuMượnSách.

				Ví dụ 4: SinhViên <LàmLớpTrưởng> LớpHọc, mối kết hợp "LàmLớpTrưởng" sẽ có thuộc tính đi kèm là NgàyNhậnChức.
					- Thuộc tính NgàyNhậnChức chỉ bắt đầu có ý nghĩa khi SinhViên thực sự LàmLớpTrưởng trong LớpHọc (khi sinh viên bắt đầu được bầu làm ban cán sự lớp).
					- Nếu SinhViên không LàmLớpTrưởng trong LớpHọc thì thuộc tính này sẽ không tồn tại.
					-> NgàyNhậnChức không thể thuộc về SinhViên hay LớpHọc.

		5. Thực thể kết hợp (Associative Entity): Là trường hợp đặc biệt khi đối tượng vừa là thực thể, vừa là mối kết hợp.
			- Mỗi lần hai thực thể liên kết với nhau sẽ phát sinh ra một mối kết hợp (chứa các thuộc tính gắn liền với hai thực thể).
				+ Nhưng mối kết hợp này lại đóng vai trò như thực thể.
				+ Thực thể ở đây là những thứ hữu hình, có thể cầm/ nắm trên tay được; trong khi mối kết hợp là những thứ vô hình, chỉ nằm ở mức ý tưởng (trừu tượng).
				+ Vì là thực thể nên được phép có thuộc tính riêng, đặc biệt là có khoá định danh.
			- Trong sơ đồ, thường được vẽ bằng hình chữ nhật, nhưng có thêm hình thoi bên trong.

			Ví dụ: Các nhân viên trong một công ty được phép tham gia các khoá học bên ngoài để hỗ trợ cho quá trình làm việc.

						n		 n
				| NhânViên |―――――| < ChứngChỉ > |―――――| KhoáHọc |
						     |      |
					    (M̲ã̲C̲h̲ứ̲n̲g̲C̲h̲ỉ̲)  (NgàyHoànThành)

				- Một nhân viên được phép tham gia nhiều khoá học.
					+ Mỗi khoá học cũng cho phép có nhiều nhân viên tham gia.
					+ Mỗi lần tham gia sẽ được cấp một chứng chỉ.
				- Chứng chỉ là một đối tượng cụ thể, có những thuộc tính riêng.
				- Mỗi lần học viên tham gia khoá học sẽ được cấp một chứng chỉ, mỗi chứng chỉ sẽ có một mã chứng chỉ riêng.

				-> Mỗi lần có mối kết hợp sẽ phát sinh ra một thực thể.
					(Nhân viên tham gia khoá học sẽ phát sinh chứng chỉ.)

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Sơ đồ để thiết kế cơ sở dữ liệu, phác thảo về cách lưu trữ dữ liệu.	│
│	Mô hình hoá những thực thể, thuộc tính và các mối liên kết giữa chúng	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

* Lưu ý 1: Peter Chen là người đầu tiên giới thiệu các kí hiệu của ERD vào năm 1976.

	- Tuy nhiên, sau đó đã có một số kí hiệu khác được phát triển để biểu diễn ERD:
		+ Bộ kí hiệu "chân quạ" (Crow's foot) của Gordon Everest.
		+ Bộ kí hiệu của Charles Bachman.
		+ Bộ kí hiệu Richard Barker.
		+ ...

	- Ngoài ra, để biểu diễn phần trọng số (Cardinality) của các mối kết hợp.
		+ Ta còn có thể sử dụng bộ kí hiệu cặp số nhỏ nhất-lớn nhất (Min-Max) để thay thế cho các bộ kí hiệu truyền thông của Peter Chen, Gordon Everest,...
		+ Min-Max cho phép chỉ định rõ số lượng đối tượng tham gia vào mối kết hợp (ví dụ: mỗi lớp học có tối thiểu 30 và tối đa là 80 sinh viên,...).

	- Trong ghi chú này, để tiện cho việc vẽ hình.
		+ Đa phần các kí hiệu thực thể, thuộc tính, mối kết hợp và những khái niệm liên quan sẽ được minh hoạ bằng bộ kí hiệu gốc của Peter Chen.
		+ Các kí hiệu về trọng số sẽ được HIỂU theo bộ kí hiệu chân quạ của Gordon Everest.
		+ Nhưng lại được VẼ bằng kí hiệu min-max, nên các kí hiệu min-max trong ghi chú này đều bị vẽ ngược.

		-> Đọc và hiểu theo "chân quạ" nhưng lại được vẽ bằng "min-max".
	
	(* Tham khảo sự khác nhau giữa các bộ kí hiệu:
		- https://opendsa-server.cs.vt.edu/ODSA/Books/Database/html/ERDNotations.html
		- https://michael-fuchs-sql.netlify.app/2021/03/03/entity-relationship-diagram-erd/
		- https://viblo.asia/p/hieu-va-phan-biet-3-loai-erd-notation-thuong-gap-6J3ZgpPBlmB)


* Lưu ý 2: Về cách đọc (dành cho bộ kí hiệu chân quạ), ta có hai cách đọc khác nhau.

	| E1 |―――(c1)―――――< R >―――――(c2)―――| E2 |

	* Cách đọc 1: Theo tự nhiên, bắt đầu bằng một đối tượng trong thực thể, sau đó nhảy sang trọng số phía đối diện.
		E1 -> R -> c2 -> E2

	* Cách đọc 2: Chỉ dành cho Min-Max, bắt đầu bằng một đối tượng trong thực thể, sau đó sử dụng cặp trọng số ngay bên cạnh mình.
		E1 -> R -> c1 -> E2

	* Cách đọc 3: Tác giả TỰ CHẾ, bắt đầu bằng cặp trọng số gắn liền với thực thể.
		c1 -> E1 -> R -> E2

	Ví dụ 1:
		| BácSĩ |―――(1)―――――< Chăm sóc >―――――(n)―――| BệnhNhân |

		* Cách đọc 1: 
			- Mỗi bác sĩ chăm sóc cho nhiều bệnh nhân.
			- Mỗi bệnh nhân được chăm sóc bởi 1 bác sĩ.

		* Cách đọc 3: 
			- Có 1 bác sĩ chăm sóc cho một bệnh nhân.
			- Có nhiều bệnh nhân được một bác sĩ chăm sóc.

	Ví dụ 2:
		| BácSĩ |―――(0, n)―――――< Chăm sóc >―――――(1, 1)―――| BệnhNhân |

		* Cách đọc 2: 
			- Mỗi bác sĩ chăm sóc cho 0 hoặc nhiều bệnh nhân.
			- Mỗi bệnh nhân được chăm sóc bởi 1 và chỉ 1 bác sĩ.

--------------------------------------------------------------------------------

[PHÂN LOẠI CÁC THÀNH PHẦN CỦA ERD]

* Thực thể - Phân loại thực thể theo khoá:

	1. Thực thể mạnh (Strong Entity):
		- Có thể tồn tại độc lập cùng với những thực thể khác.
		- Yêu cầu phải có ít nhất một thuộc tính để làm khoá.

	2. Thực thể yếu (Weak Entity): Tồn tại phụ thuộc vào một kiểu thực thể mạnh khác.

		- Không thể tồn tại độc lập mà phải chỉ rõ đang phụ thuộc vào thực thể mạnh nào (yêu cầu thực thể khác phải tồn tại để mình được tồn tại).

		- Trong trường hợp này, thực thể mạnh còn được gọi là thực thể sở hữu (Owner Entity / Dominant Entity), còn thực thể yếu được gọi là thực thể phụ thuộc (Dependent Entity / Subordinate Entity).

		- Không thể xác định được thuộc tính để làm khoá vì thực thể yếu đang phụ thuộc vào một thực thể khác, mà thay vào đó sẽ xác định thông qua một bộ thuộc tính định danh (Identifier / Key).
			+ Định danh riêng phần (Partial Identifier / Partial Key / Discriminator): Là những thuộc tính riêng của thực thể yếu, giúp xác định thực thể yếu, nhưng chỉ là trong phạm vi của thực thể mạnh mà nó đang phụ thuộc, nghĩa là vẫn có nguy cơ bị trùng với những thực thể khác trong lược đồ.
			+ Định danh đầy đủ (Full Identifier): Định danh riêng phần của thực thể yếu sẽ kết hợp với định danh riêng của thực thể mạnh để tạo ra một định danh hoàn chỉnh.

			Ví dụ: Một căn hộ dịch vụ với rất nhiều phòng.

				- CănHộ (thực thể mạnh): M̲ã̲C̲ă̲n̲H̲ộ̲ (khoá định danh), ĐịaChỉ
				- Phòng (thực thể yếu): S̰ố̰P̰h̰ò̰n̰g̰ (khoá định danh riêng phần), SứcChứa

				-> M̲ã̲C̲ă̲n̲H̲ộ̲, S̲ố̲P̲h̲ò̲n̲g̲: Định danh đầy đủ.

		- Có thể được chuyển thành mối kết hợp.

		- Thực thể yếu sẽ được kí hiệu bằng hình chữ nhật nét đôi.
			+ Mối kết hơp để phát sinh dữ liệu cho thực thể yếu (được gọi là mối kết hợp định danh - Identifying Relationship) sẽ được kí hiệu bằng hình thoi nét đôi.
			+ Thuộc tính định danh riêng phần của thực thể yếu vẫn được gạch nhân nhưng phải bằng nét đứt.

		Ví dụ 1: Nhân viên có người thân là người cùng hưởng bảo hiểm.

			| NhânViên |―――――<< Có >>―――――|| NgườiThân ||
			     |				     |
			  (M̲ã̲N̲V̲)			      (T̰ḛ̂n̰N̰T̰)

		Ví dụ 2: Hoá đơn trong giao dịch mua hàng có chi tiết hoá đơn.

			| HoáĐơn |―――――<< Thuộc >>―――――|| ChiTiếtHoáĐơn ||
			     |					|
			  (S̲o̲H̲D̲)			      (S̲o̲H̲D̲,̲ ̲M̲ã̲S̲P̲)

		Ví dụ 3: Sinh viên trong một trường có thông tin đăng ký môn học.

			| SinhViên |―――――<< Có >>―――――|| ThôngTinĐăngKýMônHọc ||

------------------------------------------------------------

* Thuộc tính - Phân loại thuộc tính theo nhóm:

	1. Nhóm thuộc tính đơn & thuộc tính tổ hợp.

		* Thuộc tính đơn / nguyên tử (Simple Attribute / Single Attribute / Atomic Attribute): Thuộc tính không thể phân chia nhỏ hơn được nữa (không nói về giá trị bên trong của thuộc tính).

			Ví dụ: Màu sắc, cân nặng,...

		* Thuộc tính tổ hợp / phức hợp (Composite Attribute): Chứa bên trong nhiều thuộc tính đơn hoặc phức.
			- Vẫn còn ở mức chung chung, do nhiều thuộc tính đơn hoặc phức tạo thành, nên có thể được chia nhỏ hơn nếu cần thiết.
			- Được biểu diễn bằng cách đặt tên thuộc tính trong cặp dấu ngoặc tròn "()" và vẽ tiếp những thuộc tính đơn khác có liên kết với thuộc tính phức này.

			Ví dụ:
				- Địa chỉ bao gồm: Số nhà, tên đường, quận, huyện, thành phố,...
				- Họ tên bao gồm: Họ, tên đệm và tên.

	2. Nhóm thuộc tính đơn trị & thuộc tính đa trị.

		* Thuộc tính đơn trị (Single-valued Attribute): Thuộc tính chỉ nhận đồng thời 1 giá trị.

			Ví dụ: Một người chỉ có duy nhất một năm sinh.

		* Thuộc tính đa trị (Multi-valued Attribute): Thuộc tính được phép nhận đồng thời nhiều giá trị (có một tập hợp danh sách các giá trị).
			- Chỉ nên sử dụng để lưu trữ những thuộc tính quan trọng, cần lọc và phân tách để xử lý sau này.
				+ Ngoài ra, không khuyến khích sử dụng vì sẽ gây khó khăn cho quá trình thống kê.
				+ Thay vào đó, có thể lưu toàn bộ giá trị trong một chuỗi, tập tin hoặc đường dẫn.
			- Được biểu diễn bằng hình elip nét đôi.

			Ví dụ:
				- Sở thích: Một người có thể có nhiều sở thích khác nhau.
				- Số điện thoại: Một người có thể có nhiều điện thoại, mỗi loại hỗ trợ nhiều sim.
				- Ngoại ngữ: Mỗi người có thể nói được nhiều ngoại ngữ khác nhau.
				- Bằng cấp/ Chứng chỉ: Mỗi người có thể sở hữu nhiều bằng cấp và chứng chỉ khác nhau.

	3. Nhóm thuộc tính lưu trữ & thuộc tính dẫn xuất.

		* Thuộc tính lưu trữ / cơ sở (Stored Attribute): Nếu để trống, sẽ không thể biết giá trị của thuộc tính là gì và cũng không có cách nào để suy ra (không thể nhìn rồi đoán), nên bắt buộc phải được nhập vào (từ bàn phím).

			Ví dụ: Tên, năm sinh,...

		* Thuộc tính dẫn xuất / suy diễn / suy dẫn / phái sinh (Derived Attribute / Computed Attribute): Để tránh sai xót hoặc mâu thuẫn khi phải nhập thủ công, giá trị của thuộc tính sẽ được suy ra nhờ vào những thuộc tính có sẵn khác.
			- Phục vụ cho việc tổng hợp và thống kê một cách tự động.
			- Thường chỉ nên là thuộc tính dẫn xuất khi được tính toán ra từ một biểu thức đơn giản.
			- Trong thực tế, để đạt chuẩn thiết kế CSDL, thuộc tính dẫn xuất sẽ thường được tách ra thành một bảng tạm thay vì được sử dụng làm thuộc tính của một thực thể.
			- Được biểu diễn bằng hình elip nét đứt.

			Ví dụ:
				- Tuổi: Được tính nhờ vào có nhập thuộc tính năm sinh.
				- Thời gian (kinh nghiệm) làm việc: Được tính từ ngày vào làm.
				- Số lượng nhân viên của Phòng Ban: Được tính nhờ vào việc đếm số lượng nhân viên trong bảng Nhân Viên.
				- Giá trị của hoá đơn trong bảng Hoá Đơn: Được tính nhờ vào việc đi vào bảng Sản Phẩm, tính tổng của (số lượng * đơn giá từng mặt hàng).
				- Lương thực lĩnh: Được tính nhờ vào (hệ số lương * lương cơ bản).

	(Complex Attribute: Khi thuộc tính phức và thuộc tính đa trị kết hợp.)

--------------------

* Lưu ý 1: Đối với nhóm thuộc tính 1 và 3, nếu xác định bị sai thì chỉ gây khó khăn trong việc lấy dữ liệu ra để sử dụng, nhưng nếu nhóm thuộc tính 2 bị xác định sai thì sẽ ảnh hưởng đến việc lưu trữ dữ liệu.


* Lưu ý 2: Khi thiết kế ERD, cần có một số lưu ý sau đối với thuộc tính.
	- Chỉ nên sử dụng thuộc tính đơn và đơn trị, không nên sử dụng thuộc tính phức và đa trị.
	- Mỗi ứng dụng sẽ chỉ tương tác với một vài thuộc tính chứ không phải với tất cả các thuộc tính.
	- Mỗi đối tượng sẽ có một thuộc tính định danh để phân biệt với các đối tượng khác và mỗi thực thể có thể có nhiều thuộc tính cùng làm định danh.

----------------------------------------

	Ngoài ra, ta có thể phân loại thuộc tính theo khoá (Identifier).

		- Tên gọi ban đầu là định danh (Identifier), nhưng công dụng giống hết như khoá (Key) trong mô hình quan hệ, nên dần được gọi là thuộc tính khoá (Key Attribute).

		- Xuất phát từ yêu cầu phải có cách để phân biệt giữa các đối tượng trong cùng một tập thực thể khi giá trị của tất cả các thuộc tính giữa các thực thể đều trùng nhau, giúp đảm bảo việc lưu trữ là duy nhất.

		- Thuộc tính khoá là một thuộc tính hoặc tập hợp các thuộc tính, được sử dụng để xác định một đối tượng duy nhất trong tập thực thể.
			+ Giá trị của thuộc tính là duy nhất cho mỗi thực thể.
			+ Giúp phân biệt giữa đối tượng này với những đối tượng khác trong cùng một kiểu thực thể.

		- Mỗi thực thể yêu cầu phải có ít nhất một thuộc tính khoá để định danh (Identify).

		- Thuộc tính khoá có thể được suy đoán thông qua những suy đoán về mặt luận lý.

		-> Giúp phân biệt giữa các dòng dữ liệu trong bảng.

		1. Thuộc tính khoá chính (Primary Key): Là một thuộc tính khoá đặc biệt khi giá trị của khoá chính yêu cầu thêm hai điều kiện: không được để trống (cấm NULL) và không được trùng nhau giữa các đối tượng (cấm trùng trên cột).

			- Giúp tìm kiếm, sắp xếp và liên kết các bản ghi trong cơ sở dữ liệu.

			- Một hoặc nhiều thuộc tính có thể hợp lại để tạo thành khoá chính.
				+ Nếu chỉ có một thuộc tính, giá trị của thuộc tính này bắt buộc phải khác nhau giữa các thực thể.
				+ Nếu có nhiều thuộc tính hợp lại, chỉ cần các kết hợp không bị trùng là được.
					Ví dụ: [A1, B1], [A1, B2], [A2, B1], [A2, B2], [ ̶A̶2̶,̶ ̶B̶2̶].

			- Nếu trong danh sách thuộc tính của một thực thể không có sẵn thuộc tính để phục vụ cho mục đích định danh.
				+ Vì giá trị của một thuộc tính sẵn có sẽ không tuân theo quy luật và có nhiều biến động (ví dụ: tên sẽ có độ dài khác nhau, có khoảng trắng và có dấu tiếng Việt,...).
				+ Vì vậy, nên thiết kế thêm một thuộc tính riêng, không nên cố gắng sử dụng những thuộc tính sẵn có, vì khả năng trùng lặp dữ liệu và khả năng gây ra khó khăn trong việc định danh là rất cao.
				+ Nếu không thể tự xây dựng thuộc tính định danh do thực thể đang là thực thể yếu, cần phải sử dụng mối kết hợp để chỉ rõ thực thể yếu này đang phụ thuộc vào thực thể nào.

			- Được biểu diễn bằng cách gạch dưới / gạch chân tên thuộc tính.

			-> Chỉ cần một giá trị của thuộc tính là có thể xác định được cả một đối tượng.
				("Giá trị của thuộc tính là thứ tồn tại duy nhất. Còn tất cả những cái khác, trùng hay không trùng, không quan trọng.")

		2. Thuộc tính khoá ngoại (Foreign Key): Không có trong ERD, chỉ có trong RS.
			- Là điểm chung giữa hai thực thể, giúp hai thực thể liên kết với nhau.
			- Là một thuộc tính hoặc tập hợp các thuộc tính trong một bảng, tham chiếu đến khoá chính của bảng khác.
			- Được sử dụng để thiết lập quan hệ giữa hai hay nhiều bảng.
				+ Thuộc tính khoá chính của bảng khác "chạy" sang để làm thuộc tính khoá ngoại trong bảng này.

			-> Khoá chính của bảng này "vi hành" sang làm khoá ngoại của bảng khác.

------------------------------------------------------------

* Mối kết hợp - Phân loại mối kết hợp & Ràng buộc cấu trúc (Structural Constraint) trên mối kết hợp:

--------------------

	* Số ngôi / Bậc / Cấp (Degree): Dựa vào số lượng thực thể tham gia vào mối kết hợp.

		1. Liên kết một ngôi / đơn phân / đệ quy / hồi quy (Unary / Recursive): Mối liên kết / tương tác giữa các đối tượng trong cùng một thực thể (thực thể có thể tự tham gia vào liên kết với vai trò khác nhau).

			Ví dụ:
				| NhânViên |―――――< Chịu sự giám sát của >―――――| NhânViên |
				| NhânViên |―――――< Kết hôn với >―――――| NhânViên |

		2. Liên kết hai ngôi / nhị phân (Binary): Là mối liên kết giữa hai thực thể.

		3. Liên kết nhiều ngôi / ≥ tam phân ≈ đa phân (≥ Ternary ≈ N-ary): Là mối liên kết giữa ba thực thể trở lên.
			- Có thể và ưu tiên chuyển đổi thành nhiều liên kết hai ngôi.
				+ Tên của mối liên kết (kiểu liên kết) sẽ được chuyển đổi thành một thực thể riêng biệt.
				+ Được biểu diễn bằng thoi, nhưng được bao quanh bên ngoài bởi hình chữ nhật.

			Ví dụ: Liên kết ba ngôi, nhưng không thể tách rời được.

				| GiảngViên |―――――< Hướng dẫn >―――――| MônHọc |
							│
							│
							│
						    | LớpHọc |

				Khi tách ra, GiảngViên sẽ không biết giảng MônHọc gì cho LớpHọc và LớpHọc cũng sẽ không biết MônHọc do GiảngViên nào giảng.

--------------------

	* Ràng buộc trọng số (Cardinality Ratio / Mapping Cardinality):
		- Dựa vào trọng số / bản số / lượng số tối đa (số lượng đối tượng tối đa của các thực thể) tham gia vào mối kết hợp.
		- Chỉ quan tâm đến trọng số tối đa (Maximum Cardinality).

		1. Liên kết một-một (one-to-one, 1-1): Mỗi đối tượng trong thực thể A <có liên kết> với 1 đối tượng trong thực thể B, và ngược lại.

			Ví dụ:
						  1			1
				| SinhViên |―――(1, 1)―――――< Có >―――――(1, 1)―――| ThẻSinhViên |

				- Mỗi sinh viên sẽ được nhà trường cung cấp sẵn một thẻ sinh viên.
				- Mỗi thẻ sinh viên đã tạo ra phải và chỉ có thể thuộc về một sinh viên duy nhất.

		2.1. Liên kết một-nhiều (one-to-many, 1-n):
			- Mỗi đối tượng trong thực thể A <có liên kết> với nhiều đối tượng trong thực thể B.
			- Nhưng mỗi đối tượng trong thực thể B chỉ <có liên kết> với 1 đối tượng trong thực thể A.

			Ví dụ:
						  1			 n
				| SinhViên |―――(1, 1)―――――< Nộp >―――――(0, n)―――| BàiTập |

				- Mỗi sinh viên có thể không nộp hoặc nộp nhiều bài tập đã làm.
				- Mỗi bài tập chỉ được nộp bởi một sinh viên duy nhất.

		2.2. Liên kết nhiều-một (many-to-one, n-1):
			- Mỗi đối tượng trong thực thể A chỉ <có liên kết> với 1 đối tượng trong thực thể B.
			- Nhưng mỗi đối tượng trong thực thể B <có liên kết> với nhiều đối tượng trong thực thể A.

			Ví dụ:
						  n			   1
				| SinhViên |―――(0, n)―――――< Thuộc >―――――(1, 1)―――| Khoa |

				- Mỗi sinh viên chỉ được phép thuộc về một khoa duy nhất (trừ văn bằng 2).
				- Mỗi khoa được phép chưa có hoặc có nhiều sinh viên.

		3. Liên kết nhiều - nhiều (many-to-many, n-n): Mỗi đối tượng trong thực thể A <có liên kết> với nhiều đối tượng trong thực thể B, và ngược lại.

			Ví dụ:
						  n			       n
				| SinhViên |―――(0, n)――――< Đăng kí >――――(0, n)―――| MônHọc |

				- Trong một học kì, Mỗi sinh viên có thể không đăng ký (bảo lưu học kì) hoặc đăng kí nhiều môn học.
				- Mỗi môn học có thể không có sinh viên nào đăng kí hoặc có nhiều sinh viên cùng đăng kí.

		4. Liên kết đệ quy / vòng: Mỗi loại thực thể có thể tham gia nhiều lần vào một quan hệ với nhiều vai trò khác nhau.

			Ví dụ:
						  n			    n
				| SinhViên |―――(0, n)―――――< Hỗ trợ >―――――(0, n)―――| SinhViên |

				- Mỗi sinh viên có thể hỗ trợ học tập cho nhiều sinh viên khác.
				- Mỗi sinh viên có thể được nhiều sinh viên khác hỗ trợ học tập.

----------

		- Trọng số tối đa (Maximum Cardinality) sẽ gắn liền với thực thể gần với nó nhất, cách đọc trọng số cũng từ đó mà bị ảnh hưởng theo.
		
			Ví dụ:
				- Mỗi NhânViên làm việc cho 1..1 PhòngBan.
					-> Trọng số 1 được gán cho PhòngBan.

				- Mỗi PhòngBan có 0..n NhânViên làm việc.
					-> Trọng số nhiều được gán cho NhânViên.

					     n			1
				| NhânViên |―――――< Làm việc >―――――| PhòngBan |

				-> NhânViên làm việc cho PhòngBan là liên kết nhiều-một.

		- Đối với liên kết ba ngôi (n-n-n, 1-n-n, 1-1-n, 1-1-1,...).
			+ Có thể là liên kết giữa các thực thể.
			+ Cũng có thể là liên kết giữa các thực thể và mối kết hợp.
			+ Việc xác định trọng số của các thực thể cũng sẽ trở nên phức tạp hơn khi phải trả lời tuần tự 3 câu hỏi:
				1. Khi thực thể A và B kết hợp, có thể có bao nhiêu C?
				2. Khi thực thể A và C kết hợp, có thể có bao nhiêu B?
				3. Khi thực thể C và B kết hợp, có thể có bao nhiêu A?

		Ví dụ 1: Liên kết ba ngôi và trọng số.

			| GiảngViên |―――(1, n)――――< Hướng dẫn >――――(1, n)―――| MônHọc |
							│
							│
						      (1, n)
							│
						    | LớpHọc |

			- Một giảng viên - hướng dẫn cho một lớp, có thể hướng dẫn một hoặc nhiều môn.

			- Một giảng viên - hướng dẫn một môn học, có thể hướng dẫn cho một hoặc nhiều lớp.

			- Một lớp - được hướng dẫn một môn học, có thể có một hoặc nhiều giảng viên cùng hướng dẫn.

		Ví dụ 2: Liên kết ba ngôi và trọng số.

			| NhàCungỨng |―――(1, n)――――< CungCấp >――――(1, n)―――| CửaHàng |
							│
							│
						      (1, n)
							│
						    | MặtHàng |

			- Một nhà cung ứng - cung cấp một mặt hàng, cho nhiều cửa hàng.

			- Một nhà cung ứng - cung cấp cho một cửa hàng, nhiều mặt hàng.

			- Một mặt hàng - cung cấp cho một cửa hàng, bởi nhiều nhà cung ứng.

--------------------

	* Ràng buộc tham gia (Participation Constraint):
		- Dựa vào trọng số tối thiểu tham gia vào mối kết hợp.
		- Chỉ quan tâm đến trọng số tối thiểu (Minimum Cardinality).

		1. Tuỳ chọn (Optional - Opt) - Tham gia bộ phần (Partial Participation): Được phép không có đối tượng nào trong thực thể tham gia vào mối kết hợp.
			-> Số tối thiểu là 

		2. Bắt buộc (Mandatory - Man) - Tham gia toàn bộ (Total Participation): Phải có ít nhất một (hoặc nhiều) đối tượng trong thực thể tham gia vào mối kết hợp.

----------------------------------------

* Lưu ý: Khi thiết kế, phải nhìn trên tổng thể và hướng về tương lai, không nên chỉ thiết kế để giải quyết được những vấn đề trong hiện tại.
	-> Thà thiết kế thừa để sau này mở rộng còn hơn thiết kế thiếu.

	Ví dụ 1: Thiết kế thừa nhưng không sai.

		| NhânViên |―――(1, n)―――――< Làm việc >―――――(1, n)―――| PhòngBan |
							       ^
							       |
				 Cần xem xét là 1 hay n. -------

		Một nhân viên có thể làm việc trong một hoặc nhiều phòng ban.

			- Ở thời điểm hiện tại, một nhân viên chỉ đang thuộc một phòng ban.
				-> Có thể thiết kế trọng số của NhânViên là (1, 1).

			- Nhưng trong tương lai, một nhân viên có thể được thuyên chuyển sang nhiều phân hệ khác nhau (thăng cấp, hạ cấp).
				-> Phải thiết kế trọng số của NhânViên là (1, n).

			- Ngoài ra, việc thiết kế trọng số của NhânViên là (1, n) còn cho phép lưu lại lịch sử làm việc của một nhân viên, phục vụ cho công việc thống kê sau này.

	Ví dụ 2: Thiết kế thừa nhưng không sai.

		| GiảngViên |―――(1, n)―――――< Hướng dẫn >―――――(1, n)―――| MônHọc |
				    ^
				    |
				    ------- Cần xem xét là 1 hay n.

		Một môn học có thể được một hoặc nhiều giảng viên hướng dẫn.

			- Ở thời điểm hiện tại, có thể một môn chỉ cho phép một giảng viên phụ trách.
				-> Có thể thiết kế trọng số của MônHọc là (1, 1).

			- Nhưng trong tương lai, một môn có thể có đến hai giảng viên hướng dẫn, một thời phụ trách phần lý thuyết và người còn lại phụ trách phần thực hành.
				-> Phải thiết kế trọng số của MônHọc là (1, n).

--------------------------------------------------------------------------------

[ERD MỞ RỘNG - ENHANCED ERD (E-ERD)]

Khi độ phức tạp của dữ liệu ngày càng tăng.
	- ERD truyền thống sẽ không đủ đề mô hình hóa CSDL (biểu diễn các đối tượng và mối kết hợp giữa chúng).
	- Cần phải có thêm những khái niệm mới để giúp biểu diễn dữ liệu được rõ ràng và chính xác hơn.

	Ví dụ: Một công ty phần mềm có 3 loại nhân viên khác nhau:
		- Chuyên viên phân tích nghiệp vụ khách hàng (Business Analyst).
		- Lập trình viên (Developer).
		- Kiểm thử viên (Tester).

		-> Làm sao thể hiện được quy tắc nghiệp vụ bằng ER truyền thống?

			1. Tạo ra 3 thực thể riêng biệt.
				- Mỗi thực thể tương ứng với một loại nhân viên.
				- Những thông tin chung (ví dụ: tên, năm sinh, sđt, email...) sẽ bị lặp lại nhiều lần giữa các thực thể.

				-> Không tận dụng được những đặc điểm chung.

			2. Tạo ra một thực thể chung là NhânViên.
				- Tất cả những thông tin chung đã được gom vào cùng một nơi.
				- Có thêm 3 thuộc tính: ChuyênViênPhânTíchNghiệpVụ, LậpTrìnhViên, KiểmThửViên.
				- Cùng một lúc, chỉ có 1 trong 3 thuộc tính có thể có dữ liệu (2 thuộc tính còn lại sẽ luôn luôn được để trống).

				-> Một số thông tin luôn luôn bị để trống.

------------------------------------------------------------

1. Tổng quát hoá và chuyên biệt hoá / Cha-Con (Generalization and Specialization): Được lấy cảm hứng từ mô hình hướng đối tượng.

	- Khi giữa các thực thế có mối kết hợp Cha-Con (Cha tổng quát hoá, Con chuyên biệt hoá), nhận biết bằng dấu hiệu "là-một (is-a)".
		+ Thực thể Cha (Supper-type / Super-class / Generalized Class): Chỉ chứa đựng những đặc điểm hoặc mối kết hợp chung nhất của tất cả các Con.
		+ Thực thể Con (Sub-type / Sub-class / Specialized Class): Chỉ bao gồm những đặc điểm hoặc mối kết hợp riêng biệt mà Cha không có.

		Ví dụ: Một số đặc điểm mà chỉ riêng Con mới có.

			| KháchHàngThânThiết |―――――< Là một >―――――| KháchHàng |
				|
			(SốĐiểmThưởngTíchLuỹ)


			| LậpTrìnhViên |―――――< Là một >―――――| NhânViên |
				|
		      (SốTínhNăngViếtĐược)


			| GiảngViên |―――――< Là một >―――――| NhânViên |
			      |
			(GiảngDạyVàNCKH)

	- Thực thể Con sẽ kế thừa toàn bộ thuộc tính, khoá và mối liên kết của thực thể Cha.
		- Đồng thời, Con được phép có thêm những thuộc tính và mối liên kết khác cho riêng mình.
		+ Nhưng riêng về khoá thì Con không được phép có mà phải sử dụng khoá của Cha (Con có quyền sử dụng đồ dùng trong nhà, nhưng riêng chìa khoá nhà vẫn phải do Cha nắm giữ).

	- [???] Một thực thể kiểu Con cũng là một thực thể kiểu Cha, nhưng không nhất thiết một thực thể kiểu Cha phải thuộc về một kiểu Con.

	- Để biểu diễn được các thực thể Cha-Con:
		1. Gom những gì chung nhất, để ở Cha.
		2. Sử dụng một hình tròn nhỏ (vòng tròn chuyên biệt) để làm mấu nối / chốt rẻ nhánh.
		3. Từng Con riêng biệt sẽ nối với vòng tròn chuyên biệt và đi kèm với kí hiệu thuộc về (∈) hoặc kí hiệu tập hơp con (⊂).
			- Đầu tròn của kí hiệu ∈ / ⊂ sẽ quay về phía Con.
			- Đầu nhọn sẽ quay về phía vòng tròn chuyên biệt (mấu nối của Cha).
			(Ý nghĩa: Con ∈ Cha / Con ⊂ Cha.)

		Ví dụ: Các chức danh công việc trong một công ty CNTT.
		
			| LậpTrìnhViên |―――――――――――――――――――∈―――――\
			| ChuyênViênPhânTíchNghiệpVụ |―――――∈―――――〇―――――| NhânViên |
			| KiểmThửViên |――――――――――――――――――――∈―――――/

	* Kỹ thuật xác định Cha-Con:

		1. Tổng quát hoá (Generalization): Là quá trình tiếp cận từ cụ thể đến tổng quát (buttom-up).
			- Phát hiện ra giữa những thực thể Con có một số điểm chung (thuộc tính, mối liên kết,...).
			- Sau đó gom những điểm chung này lại và tạo thành thực thể Cha.

			-> Phát hiện ra những điểm chung trong từng cái riêng.

			Ví dụ: Cho một cơ sở dữ liệu phục vụ cho một hội nghị khoa học.
				- Trong đó, các tác giả sẽ gửi những bài báo của mình cho hội nghị. Thông tin tác giả bao gồm: Địa chỉ email (định danh), họ và tên, bộ môn, khoa, trường công tác, học vị, chức vị.
				- Hội nghị sẽ phân công một số nhà khoa học tham gia đánh giá các bài báo. Một bài báo sẽ được nhiều người đánh giá. Thông tin người đánh giá bao gồm địa chỉ email (định danh), họ và tên, số điện thoại liên lạc, học vị, chức vị và những hướng nghiên cứu.

				-> Cả tác giả và người đánh giá đều có những thông tin chung.
					=> Tổng quát hoá lên thành thực thể NhàKhoaHọc.

		2. Chuyên biệt hoá / Cụ thể hoá (Specialization): Là quá trình tiếp cận từ tổng quát về cụ thể (top-down).
			- Xem xét trong tập thực thể Cha.
				+ Ngoài những thông tin chung (thuộc tính, mối liên kết,...), có thực thể nào có "cá tính" không.
				+ Nếu có thì tách những thực thể có "cá tính" ra thành những thực thể Con.
			- Hoặc khi phát hiện trong thực thể Cha, một số thông tin lúc có/ lúc không có giá trị.
				+ Một số thông tin không phải lúc nào cũng có giá trị.
				+ Đôi khi, nếu thông tin này có giá trị hoặc thay đổi giá trị thì một số thông tin khác sẽ bị vô hiệu hoá tạm thời.
				+ Giống như các câu lệnh rẻ nhánh (if-else, switch-case). 

				Ví dụ: Một công ty gồm 3 loại nhân viên: Bán thời gian, toàn thời gian, chuyên viên tư vấn.
					- Nếu thuộc tính "Loại nhân viên" có giá trị là 1 (nhân viên bán thời gian).
						+ Chỉ thuộc tính "Số giờ làm việc" được phép có giá trị.
						+ Những thuộc tính "Số năm làm việc" (của nhân viên toàn thời gian) và "chiết khấu hợp đồng" (của chuyên viên tư vấn) sẽ tạm thời bị vô hiệu hoá.

			Ví dụ: Linh kiện để lắp ráp một sản phẩm trong công ty A bao gồm các thông tin: Mã số linh kiện, mô tả linh kiện, địa điểm lắp ráp. Linh kiện gồm hai loại:
				- Một loại có thể tự sản xuất được, cần ghi lại số hiệu sản xuất.
				- Một loại đặt mua từ nhà cung cấp bên ngoài, cần lưu giữ thông tin: Mã nhà cung cấp, giá thành.

				-> Trong linh kiện có những loại nhỏ hơn và có cá tính.
					=> Chuyên biệt hoá thành các thực thể LK_TSX và LK_DCC.

--------------------

* Lưu ý: Đôi khi, trong một số trường hợp, các thực thể tổng quát hoá và chuyên biệt hoá không được xem là Cha-Con.
	- Đó là khi trong quá trình tổng quát hoá, một số thực thể biến mất hoàn toàn vì không có bất kì đặc điểm riêng nào so với những thực thể khác.
	- Lúc này, thực thể được tổng quát hoá đang chứa mọi đặc điểm riêng của thực thể vừa biến mất (hai thực thể này có thể xem như đang hoà làm một).
	- Nhưng không thể gọi thực thể được tổng quát hoá là Cha của những thực thể khác, vì chưa chắc thực thể vừa biến mất đã đủ "tư cách" để làm Cha của những thực thể còn lại.

	Ví dụ: Sự biến mất của thực thể trong quá trình tổng quát hoá.

				-- Trước khi tổng quát hoá --

		| XeMáy |			| XeKhách |―――――(SốChỗNgồi)
		    |				     |
		    |				     |
		(M̲ã̲, ThươngHiệu, Giá,...)       (M̲ã̲, ThươngHiệu, Giá,...)

				| XeTải |―――――(TrọngTải)
				    |
				    |
				(M̲ã̲, ThươngHiệu, Giá,...)


				-- Sau khi tổng quát hoá --
		[Thực thể XeMáy đã "hoà tan" do không có bất kì điểm riêng nào]

		(SốChỗNgồi)
		     |
		     |
		| XeKhách |―――――――――――――――∈―――――\
						〇―――――| PhươngTiệnGiaoThông |
		| XeTải |―――――――――――――――――∈―――――/		|
		     |						|
		     |					(M̲ã̲, ThươngHiệu, Giá,...)
		(TrọngTải)

----------------------------------------

	* Ràng buộc trong quan hệ Cha-Con (cụ thể là ràng buộc trên thuộc tính Con):

		- Ràng buộc về tính đầy đủ (Completeness Constraint): Trong quá trình tổng quát hoá, các thực thể Con có còn đầy đủ hay đã bị "hoà tan" (Con ẩn, Con ngầm, Con rơi).

			1. Quy tắc chuyên biệt toàn phần (Total Specialization Rule).
				- Vẫn còn đầy đủ Con.
					+ Mọi đối tượng trong thực thể Cha bắt buộc phải thuộc một trong các thực thể Con đã được liệt kê.
					+ Tập hợp / Tổng các thực thể Con cộng lại phải bằng tổng thực thể Cha.
				- Được phép gọi là mối quan hệ Cha-Con.
				- Trong sơ đồ, được vẽ bằng đường nét đôi (song song), nối từ phía Cha đến vòng tròn chuyên biệt.

				Ví dụ: Trong một bệnh viện, nếu bệnh nhân (thực thể Cha) đi khám bệnh.
					- Sau khi có kết quả khám, bệnh nhân sẽ được chỉ định điều trị nội trú hoặc ngoại trú (các thực thể Con).
					- Tổng số bệnh nhân ngoại trú và nội trú, khi cộng lại phải bằng tổng số lượng bệnh nhân.

			2. Quy tắc chuyên biệt riêng phần (Partial Specialization Rule).
				- Một hoặc một số Con đã bị "hoà tan" (Con ẩn, Con ngầm, Con rơi).
					+ Có một số đối tượng trong thực thể Cha không thuộc về một trong các thực thể Con nào đã liệt kê.
					+ Tập hợp / Tổng các thực thể Con cộng lại không thể bằng tổng thực thể Cha.
				- Nên gọi là mối quan hệ Tổng quát hoá-Chuyên biệt hoá.
				- Trong sơ đồ, được vẽ bằng đường nét đơn, nối từ phía Cha đến vòng tròn chuyên biệt.

				Ví dụ: Khi phương tiện giao thông được tổng quát hoá thành thực thể Cha.
					- Trong quá trình tổng quát hoá, một số thực thể Con vì không có bất kì cá tính nào, nên đã bị "hoà tan" vào trong thực thể Cha.
					- Dẫn đến việc có một số loại phương tiện đặc biệt chỉ bao gồm những thuộc tính của Cha, không thể tạo thành thực thể Con.
					- Tổng số thực thể của lớp Con cộng lại sẽ không thể bằng tổng số thực thể của lớp Cha, do ban đầu đã có một số thực thể Con bị mất.

		- Ràng buộc về tính phân biệt / tách biệt (Disjointness Constraint): Kiểm tra một đối tượng kiểu Cha có thể đóng cùng một lúc nhiều vai (thuộc về nhiều) kiểu Con hay không.

			1. Quy tắc phân biệt / tách biệt / rời rạc (Disjoint Rule).
				- Tại một thời điểm, một đối tượng của Cha không thể thuộc về nhiều thực thể Con (chỉ chọn thuộc về duy nhất một trong số các Con).
				- Trong sơ đồ, kí tự 'd' được viết trong vòng tròn chuyên biệt.

				Ví dụ 1: Tại một thời điểm, không thể có hai phương thức điều trị (ngoại trú và nội trú) cho cùng một bệnh nhân.

				Ví dụ 2: Tại một thời điểm, một loại xe không thể nào cùng thuộc cả hai loại xe (môtô và ôtô).

			2. Quy tắc trùng lặp / phủ lấp / chồng chéo (Overlapped Rule).
				- Tại một thời điểm, một đối tượng của Cha có thể thuộc về nhiều thực thể Con.
				- Trong sơ đồ, kí tự 'o' được viết trong vòng tròn chuyên biệt.

				Ví dụ 1: Tại một thời điểm, có thể có hai loại linh kiện (tự sản xuất và nhập khẩu) cùng tồn tại trong một công ty phân phối linh kiện.

				Ví dụ 2: Tại một thời điểm, một nhân viên của công ty có thể nhận nhiều vai trò cùng một lúc (vừa làm chuyên viên phân tích nghiệp vụ khách hàng, vừa làm kiểm thử viên).

			(Nếu không chỉ định rõ, mặc định sẽ là phân biệt / rời rạc.)

		* Yếu tố phân biệt / Thuộc tính xác định thực thể Con (Sub-type Discriminator):
			- Là yếu tố được sử dụng để bổ sung thêm cho ràng buộc về tính phân biệt (Disjointness Constraint).
			- Tạo thêm một thuộc tính ở Cha, giá trị của thuộc tính này sẽ cho biết loại thực thể Con nào sẽ được sử dụng (giống if-else, switch-case).

			1. Các thực thể Con phân biệt (Disjoint Sub-type): Dùng một thuộc tính đơn (không thể phân tách) với các giá trị khác biệt nhau để chỉ ra các thực thể Con có thể có.

			2. Các thực thể Con trùng lặp (Overlapping Sub-type): Dùng một thuộc tính phức (có thể phân tách) mà các phần nhỏ hơn của nó nói đến các thực thể Con khác nhau.
				- Mỗi phần chứa một giá trị luận lý để chỉ ra một đối tượng có thuộc về thực thể Con tương ứng hay không.

			Ví dụ 1: Các thực thể con phân biệt (Disjoint).

					    "NgoạiTrú"
				| NgoạiTrú |――――――――――∈―――――\  LoạiBN = ...
							    〇―――――――――――――――| BệnhNhân |
				| NộiTrú |――――――――――――∈―――――/			  |
					    "NộiTrú"				  |
									       (LoạiBN)

				Thuộc tính LoạiBN sẽ là một cột.
					+ Tại một thời điểm, chỉ nhận vào một giá trị duy nhất.
					+ Cho biết loại bệnh nhân tương ứng là gì.

				* Bảng "Bệnh nhân":

				-----------------------------------------------------------
				| Mã BN	| Tên BN		| Năm sinh	| Loại BN |
				|-------|-----------------------|---------------|---------|
				| BN01	| Nguyễn Văn Anh	| 01/01/2001	| NgT	  |
				|-------|-----------------------|---------------|---------|
				| BN02	| Hoàng Minh Chiến	| 02/02/2002	| NT	  |
				|-------|-----------------------|---------------|---------|
				| BN03	| Hoàng Thị Giang	| 03/03/2003	| NT	  |
				|-------|-----------------------|---------------|---------|
				| BN04	| Nguyễn Mạnh Hùng	| 04/04/2004	| NgT	  |
				-----------------------------------------------------------

			Ví dụ 2: Các thực thể con trùng lặp (Overlap).

					  LK_TSX="Y"
				| LK_TSX |――――――――――∈―――――\  LoạiLK = ...
							  〇―――――――――――――――| LinhKiện |
				| LK_DCC |――――――――――∈―――――/			|
					  LK_DCC="N"				|
									―――――(LoạiLK)―――――
									|		 |
									|		 |
								     (LK_TSX)	      (LK_DCC)

				Thuộc tính LoạiLK sẽ được tách thành hai cột.
					+ Tại một thời điểm, cả hai cột cùng cho phép nhận giá trị.
					+ Mỗi cột sẽ là một giá trị luận lý (True/False, Yes/No).
					+ Loại linh kiện có thể có tận hai giá trị khác nhau.

				* Bảng "Linh kiện":
				
				---------------------------------------------------------
				| Mã LK	| Tên LK	| Số lượng	|   Loại LK	|
				|	|	    	| tồn kho	|---------------|
				|	|	    	|		| Tự SX	| Nhập	|
				|-------|---------------|---------------|-------|-------|
				| LK01	| Đầu nối   	| 3568		| Y	| N	|
				|-------|---------------|---------------|-------|-------|
				| LK02	| Điện trở  	| 4500		| N	| Y	|
				|-------|---------------|---------------|-------|-------|
				| LK03	| Công tắc 	| 8000		| Y	| Y	|
				|-------|---------------|---------------|-------|-------|
				| LK04	| Bo mạch   	| 68		| N	| Y	|
				---------------------------------------------------------

----------------------------------------

	* Các quy tắc nghiệp vụ / ràng buộc toàn vẹn ở mức ý niệm (Integrity Constraint): Giúp định nghĩa hoặc ràng buộc một số khía cạnh nghiệp vụ.
		- Đây là những mô tả (văn bản hoặc kí hiệu) mà sơ đồ thông thường chưa biểu diễn được.
		- Những quy tắc này giúp:
			+ Hỗ trợ thêm về khả năng diễn đạt ngữ nghĩa cho ERD.
			+ Đảm bảo tính đúng đắn của dữ liệu khi thực hiện các thao tác thêm-xoá-sửa.

		Ví dụ:
			- Một người chỉ có thể thuê xe nếu có bằng lái.
				-> Ràng buộc trước-sau.

			- Một giảng viên được phân công giảng dạy một học phần trong học kì chỉ khi:
				+ Giảng viên này có đủ trình độ để giảng dạy học phần tương ứng.
				+ Học phần này đã được sắp xếp trong thời khoá biểu.
				-> Ràng buộc tương đương.

			- Trong một học kì, giảng viên không được phân công giảng dạy quá 3 học phần.
				-> Ràng buộc tối thiểu-tối đa (cận trên-cận dưới).

	(* Tham khảo thêm các kí hiệu RBTV - Học viện Kỹ thuật mật mã: https://youtu.be/13VaPmqWmsc?si=OFLEKSb1Hcam16L-)

------------------------------------------------------------

2. Đa kế thừa (Multiple Inheritance): Một thực thể Con có thể có nhiều Cha khác nhau.
	- Thuộc tính của thực thể Con là tập hợp (union) thuộc tính của các thực thể Cha.

	Ví dụ: Một giảng viên có thể vừa là thực thể Con của Nhân viên, vừa là thực thể Con của Cựu sinh viên.

------------------------------------------------------------

3. Tập hợp (Union)

(* Tham khảo thêm: https://www.geeksforgeeks.org/enhanced-er-model/)

--------------------------------------------------------------------------------

* Thực hành vẽ ERD (nâng cao): https://thinhnotes.com/chuyen-nghe-ba/15-phut-thuc-hanh-voi-so-do-erd/

==========================================================================================

[THIẾT KẾ - MỨC LUẬN LÝ]

--------------------------------------------------------------------------------

[CÁC THÀNH PHẦN, ĐẶC TRƯNG CỦA MÔ HÌNH DỮ LIỆU QUAN HỆ]

------------------------------------------------------------

	[1. DƯỚI GÓC NHÌN CỦA CẤU TRÚC DỮ LIỆU - STRUCTURE]

* Mô hình dữ liệu quan hệ (Relational Model / Relational Data Model): Là mô hình dữ liệu được sử dụng phổ biến nhất.

	- Có thành phần chính là một bảng (Table) gồm các dòng (Row) và cột (Column).
		+ Giống như bảng tính (Spreadsheet) trong Microsoft Excel.
		+ Nhưng bảng tính chỉ được thiết kế cho một người dùng, trong khi CSDL được thiết kế cho phép nhiều người dùng cùng lúc.

	- Tập trung vào mối quan hệ (Relational) giữa các bảng.

	- Cho phép sử dụng ngôn ngữ SQL để tương tác và quản lý: xem-thêm-sửa-xoá... dữ liệu.

	- Nếu dữ liệu được tổ chức theo mô hình quan hệ sẽ đạt được sự cân bằng giữa:
		+ Hiệu suất cao.
		+ Tiết kiệm không gian lưu trữ.
		+ Dễ dàng truy vấn.

* Lược đồ quan hệ (Table Schema / Relation Schema - RS):
	(Schema = Scheme)

	- Là lược đồ thể hiện cấu trúc của một bảng trong CSDL quan hệ.
		+ Bao gồm tên bảng, các cột, khoá và đôi khi bao gồm cả miền dữ liệu (Domain).
		+ Các cột được liệt kê ngăn cách nhau bằng dấu phẩy, giống hệt như một tập hợp trong toán học (vì được xây dựng dựa trên lý thuyết tập hợp).
		+ Nhưng chỉ liên quan đến một bảng duy nhất, chưa biểu diễn sự liên quan (mối kết hợp) đến các bảng khác.
		+ Không chứa dữ liệu thật sự bên trong, vì dữ liệu có thể có rất nhiều và thường xuyên thay đổi theo thời gian.

		Ví dụ: Lược đồ của từng bảng khác nhau.

			KháchHàng(M̲ã̲K̲H̲, TênKH, EmailKH)
			SinhViên(M̲ã̲S̲V̲, TênSV, EmailSV)

	- Giống như việc nhìn một lớp của lập trình hướng đối tượng (OOP).

* Lược đồ cơ sở dữ liệu quan hệ (Relational Database Schema): Đảm nhận phần còn thiếu của RS khi giúp biểu diễn cấu trúc và mối quan hệ / kết nối giữa các bảng trong CSDL.
	- Gồm nhiều lược đồ quan hệ (RS) để tạo thành một CSDL.
	- Được sử dụng để thể hiện giàn khung (Skeleton) của CSDL, biểu diễn mối quan hệ giữa các bảng.

		Ví dụ: Nhiều bảng liên quan.
			SinhViên(M̲ã̲S̲V̲, TênSV, EmailSV)
			MônHọc(M̲ã̲M̲H̲, TênMH, SốGiờHọc)

* Lược đồ cơ sở dữ liệu (Database Schema): Thường ám chỉ toàn bộ cấu trúc của một CSDL, không nhất thiết phải là một CSDL quan hệ.

	- Database Engine sẽ "nhìn" một CSDL dưới dạng rất nhiều thứ:

		1. Table (Bảng)
		2. View (Góc nhìn): Bên trong chứa sẵn câu truy vấn, được đặt tên và có thể xem đây như một bảng.
		3. Store Procedure
		4. Trigger

* Thể hiện của lược đồ quan hệ (Relation Instance / Populated Table): Cho biết tại một thời điểm, bảng đang chứa những dữ liệu gì - đang có những dòng dữ liệu gì (có thể thay đổi theo thời gian).

* Trạng thái của lược đồ quan hệ (Relation State): Bao gồm (nhiều) Relation Instance và cả những trạng thái trước hoặc sau khi có sự thay đổi trong dữ liệu.

----------------------------------------

Các thông tin lưu trữ trong CSDL sẽ được tổ chức dưới dạng bảng (Table), còn được gọi là quan hệ (Relation).

*  Quan hệ (Relation): Là đơn vị cơ bản của một CSDL.

	- Là một bảng (Table) - mảng hai chiều / ma trận hai chiều (2D Array) gồm các dòng (Row) và cột (Column), giúp lưu trữ thông tin của nhiều thực thể.
		+ Từng thuộc tính (Attribute) sẽ được liệt kê thành từng cột (Column).
		+ Bộ giá trị (Tuple) của các thuộc tính sẽ được gọi là dòng (Row).

	- Đưa dữ liệu vào một nơi có cùng cấu trúc mô tả hoặc đặc điểm mô tả, chứ không nhét một cách bừa bãi.

		Ví dụ: Trong một trường học, những thực thể khác nhau với chức vụ khác nhau sẽ thuộc về những bảng khác nhau.
			- Sinh viên.
			- Giảng viên.
			- Nhân viên.
			- Bảo vệ.
			- Lao công.
			- Câu lạc bộ.
			- ...

	- Nếu giữa các thực thể dính dáng đến nhau, thì được gọi là có mối quan hệ (Relationship).

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Bảng là nơi lưu trữ nhiều đối tượng với chung một cấu trúc	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

* Lưu ý: Quan hệ (Relation) là tên gọi/ cách gọi khác của bảng (Table), trong khi mối kết hợp (Relationship) là sự liên kết giữa hai bảng (Table / Relation).
	- Lý thuyết: Relation - liên qua đến toán học.
	- Thực hành: Table.

----------------------------------------

Các bảng (Table) trong CSDL quan hệ giống như lớp (Class) và những dòng dữ liệu (Row) giống như những thể hiện (Instance) trong lập trình hướng đối tượng (OOP).
	Class			≈ Table / Relation / File
	Instance / Object	≈ Row / Tuple / Record / Entity
	Property		≈ Column / Attribute / Field
	ObjectName.Property	≈ Cell / Value / Data item


* Table "Customers" ≈ Class "Customer"

				Degree (Tổng cột)
	-----------------------------------------------------------------
	|		|		|		|		|

		 Column / Attribute / Field - Data Type / Domain
		-------------------------------------------------
		|		|		|		|
	-----------------------------------------------------------------
	| PrimaryKey(PK)| Column 1	| Attribute 2	| Field 3	|
--------+---------------+---------------+---------------+---------------|
| 1	| Primary Key 1	| Cell 1	| Value 1	| Data item 1	| <-----| Row /
|-------+---------------+---------------+---------------+---------------|	| Tuple /
| 2	| Primary Key 2	| Cell 2	| Value 2	| Data item 2	| <-----| Record /
|-------+---------------+---------------+---------------+---------------|	| Entity /
| 3	| Primary Key 3	| Cell 3	| Value 3	| Data item 3	| <-----| Instance
--------------------------------|---------------|---------------|--------
   |				|		|		|
   -------------		---------------------------------
    Cardinality			    Cell / Value / Data item
    (Tổng dòng)

	|								|
	-----------------------------------------------------------------
			Table / Relation / Class

----------

// Định nghĩa nội dung:

	- Lược đồ quan hệ (Table Schema / Relation Schema): Cấu trúc các bảng ở mức ý niệm.
		+ Giàn khung (đặc điểm / thuộc tính / biến) chưa có dữ liệu.
		+ Được phác thảo dựa trên sơ đồ ERD.

	- Bảng (Table / Relation): Cấu trúc bảng + Dữ liệu (Đầy đủ thông tin).

	- Cơ sở dữ liệu (Database): Tập hợp gồm nhiều bảng có liên kết với nhau.

	- Từng cột thuộc tính (Column / Attribute / Field): Là những thuộc tính của một đối tượng / thực thể, có thể xem mỗi cột là một biến thuộc tính trong lập trình.

		+ Kiểu dữ liệu (Data Type): Dữ liệu được hiển thị ra bên ngoài dưới dạng như thế nào (thuộc tính có thể chứa loại dữ liệu gì).
			+ Là một dạng ràng buộc về giá trị, có thể là: số nguyên, số thực, chuỗi kí tự, thời gian,...
			+ Nhưng không bao gồm các kiểu dữ liệu phức tạp như: tập hợp (set), danh sách (list), mảng (array),...

		+ Miền giá trị (Domain): Gồm nhiều giá trị đơn (không thể chia nhỏ) thuộc về một kiểu dữ liệu, được phép gán cho một cột (giá trị mà thuộc tính có thể nhận được / có thể chứa).

		(Thuật ngữ "miền giá trị" đã bao gồm cả thuật ngữ "kiểu dữ liệu" bên trong.)

		+ Khoá (Key): Giá trị trong một cột giúp xác định một dòng dữ liệu.

	- Từng dòng dữ liệu (Row / Tuple / Record / Entity): Là khi giá trị được gán cho thuộc tính và tạo thành một dòng dữ liệu.
		+ Mỗi dòng đại diện cho một tập các dữ liệu có liên quan với nhau.
		+ Có thể xem mỗi dòng là một đối tượng trong lập trình.

	- Tổng cột (Degree): Tổng bậc - Số cột của một bảng.

	- Tổng dòng (Cardinality): Tổng lực lượng / bảng số - Số lượng dòng đang được lưu trữ, liên quan đến ĐSQH.

----------

// Định nghĩa hình thức (toán tập hợp):

	- Một lược đồ quan hệ (R) chứa bên trong một tập thuộc tính {A₁, A₂,..., Aₙ}, kí hiệu là: R (A₁, A₂,..., Aₙ).

	- Mỗi thuộc tính (Aᵢ) trong tập thuộc tính {A₁, A₂,..., Aₙ} sẽ có một miền giá trị (Dᵢ) tương ứng với (Aᵢ), kí hiệu là: dom(Aᵢ).
		+ Trong từng miền giá trị sẽ có nhiều giá trị khác nhau.
		+ Nhiều thuộc tính khác nhau (với những miền giá trị khác nhau), khi kết hợp theo tích Đềcác (Descartes), sẽ tạo nên một tập hợp vô cùng nhiều các bộ dữ liệu.

		* Tích Đềcác (Descartes) các miền giá trị của từng thuộc tính trong một bảng.
			- Là lần lượt lấy từng giá trị trong miền giá trị của thuộc tính này đem đi nhân với từng giá trị trong miền giá trị của những thuộc tính khác.
			- Kí hiệu là: D = D₁ × D₂ × ... × Dₙ.

	- Một bảng (r) trong lược đồ quan hệ (R) kí hiệu là: r(R).
		- Sẽ là tập con (subset) tích Đềcác của các miền giá trị, kí hiệu là: D (r ∈ D).
		- Từng dòng dữ liệu trong bảng (r) chỉ là một trong rất nhiều bộ dữ liệu được tạo ra nhờ tích Đềcác vào sau đó được gom vào trong bảng (r).

	- Mỗi bộ (t) của lược đồ quan hệ (R) sẽ có các giá trị aᵢ, kí hiệu là: t (a₁, a₂,..., aₙ).
		+ Với aᵢ ∈ dom(Aᵢ), nghĩa là từng giá trị aᵢ trong bộ (t) phải thuộc miền giá trị của Aᵢ trong R.
		+ Đồng thời, thứ tự khi chèn (nhập) dữ liệu aᵢ vào trong bộ (t) cũng phải tương đương với thứ tự được sắp xếp của Aᵢ trong R.

--------------------

* Các tính chất của bảng (Characteristics of Relations): Một cơ sở dữ liệu có thể tách dữ liệu ra và lưu trữ trong nhiều bảng, mỗi bảng gồm dòng và cột.

	- Tên của các bảng không được trùng nhau.

	- Mỗi dòng trong bảng đại diện cho một đối tượng cụ thể hoặc mối quan hệ giữa các đối tượng, nên sẽ không thể có hai dòng trùng nhau hoàn toàn (mỗi dòng phải là duy nhất).
		- Số lượng dòng và những dữ liệu bên trong một dòng có thể được thay đổi theo thời gian.
		- Những thay đổi phụ thuộc vào những thao tác thêm-sửa-xoá của người dùng.
		- Trong một bảng, dòng đầu tiên được gọi là dòng tiêu đề, chỉ chứa tên các thuộc tính (danh sách tên cột).

	- Mỗi cột trong bảng đại diện cho một thuộc tính của đối tượng.
		+ Tên của các cột trong bảng là cố định và cũng không được trùng nhau.
		+ Các giá trị trong cùng một cột phải cùng một loại (ví dụ: cột để chứa tên không thể chứa họ, dù cả hai đều là kiểu chuỗi) và phải nằm trong miền giá trị được quy ước trước (ví dụ: điểm chỉ được nằm trong 0..10).

	- Mỗi ô trong cột chỉ có thể chứa một giá trị (giá trị đơn) hoặc có thể trống.
		+ Nếu muốn chứa được nhiều giá trị (đa trị).
			1. Tạo thêm cột khác tên nhưng lưu cùng một loại giá trị.
			2. Sử dụng chuỗi để lưu trữ thông tin.
		+ Nếu muốn chứa giá trị phức, chia nhỏ và lưu trữ từng giá trị đơn của giá trị phức.
		+ Có thể chứa giá trị rỗng (NULL).

	- Trong một bảng có nhiều dòng và cột, nếu không quan tâm đến thứ tự của các dòng và cột, việc đổi thứ tự giữa cột với cột và dòng với dòng sẽ không làm ảnh hưởng đến dữ liệu (không kể thử tự - UnOrdered).

	- Vì bên trong bảng sẽ chứa dữ liệu, nên có thể sử dụng thêm các hàm, kiểu dữ liệu... để có thể truy xuất và chỉnh sửa dữ liệu.

----------

Tất cả các giá trị trong cùng một cột phải đến từ một miền giá trị.
	- Mặc định, hầu hết các kiểu dữ liệu đều bao gồm một giá trị được biệt được gọi là giá trị NULL.
	- Đây là giá trị thứ ba, còn được gọi là UNKNOWN, bên cạnh hai giá trị TRUE và FALSE trong thuyết 3 giá trị luận lý (three-valued logic / three truth values).
	- Nếu giá trị trong một ô trả về NULL (có màu vàng), sẽ được hiểu là không có hoặc chưa xác định được (tạm thời để bằng NULL, đến khi biết thì sẽ có những cập nhật sau trong tương lai).

	Ví dụ: khi sinh viên kí tên vào danh sách thi, cột điểm ở thời điểm kí tên đang tạm thời là NULL - mang trạng thái chưa xác định.

	-> NULL đại diện cho một thứ chưa xác định được.

	- Khi thiết kế, nên tránh những giá trị NULL vì nó sẽ gây ra mơ hồ.
		Ví dụ: Trong cột "Địa chỉ nhà" của bảng "Nhân viên", có hai ô cùng lưu giá trị NULL, ta không thể kết luận hai nhân viên này có cùng địa chỉ được.

	- Nếu chưa có giá trị thì cũng không thể sử dụng các toán tử so sánh (>, <, =...)

	- Thay vào đó, ta sẽ sử dụng các toán tử: IS NULL, IS NOT NULL, NOT (Tên bảng IS NULL) để kiểm tra và lọc ra những ô có giá trị là NULL.

------------------------------------------------------------

	[2. DƯỚI GÓC NHÌN CỦA RÀNG BUỘC DỮ LIỆU - CONSTRAINT]

* Ràng buộc toàn vẹn (Integrity Constraint): Để đảm bảo tính nhất quán và an toàn, dữ liệu trong một bảng sẽ không thể được nhập một cách tuỳ tiện, mà phải thoả mãn một số ràng buộc và dữ liệu cũng phải có mối liên hệ với nhau.
	- Là những điều kiện bất biến, không được vi phạm trong một CSDL.
	- Được thực hiện trong quá trình thiết kế lược đề quan hệ, những ràng buộc về dữ liệu sẽ dần dần được gài vào.
	- Những ràng buộc này sẽ được kiểm tra trước khi thực hiện bất kỳ thao tác thêm-sửa-xoá nào về dữ liệu trong CSDL.

	-> Các ràng buộc giúp quy định dữ liệu nên và không nên như thế nào.

* Ràng buộc trong CSDL sẽ được chia làm 3 loại chính:

	1. Implicit Constraint (Default Constraint / Inherent Model-Based Constraint): Những ràng buộc vốn có của mô hình dữ liệu, tự động được HQTCSDL áp dụng cho dữ liệu mà không cần sự can thiệp từ con người.
		- Not Null Constraint: Mặc định, một cột trong bảng không được null mà bắt buộc phải chứa giá trị.
		- [???] Default Value Constraint: Một giá trị mặc định sẽ được tự động gán cho cột nếu không cung cấp giá trị trong quá trình thêm dữ liệu.

		Ví dụ:
			- Tên của bảng không được trùng.
			- Tên của cột không được trùng.
			- Không thể có hai dòng trùng nhau.
			- Mỗi ô trong cột chỉ chứa giá trị đơn.

	2. Explicit Constraint (Schema-Based Constraint): Những ràng buộc được gài bằng những câu lệnh DDL (những câu lệnh tạo dựng dàn khung cho bảng) trong SQL hoặc thao tác trực tiếp trên giao diện của HQTCSDL.
	
	3. Semantic Constraint (Application-Based Constraint / Business Rule): Những ràng buộc nghiệp vụ được gài bằng những câu lệnh trong lập trình (ví dụ: if-else,...).
		Ví dụ:
			- Tiền lương chỉ có thể tăng.
			- Tiền lương của nhân viên không được cao hơn tiền lương của quản lý.
			- Nhân viên chỉ được làm tối đa 56g/tuần.

----------------------------------------

* Các loại ràng buộc tường minh (Explicit Constraint):

	1. Ràng buộc miền giá trị (Domain Constraint): Quy định những giá trị được phép nhận của một cột.
		- Để việc nhập giá trị cho cột được thành công, dữ liệu nhập vào phải:
			+ Là giá trị đơn.
			+ Nằm trong miền giá trị.
		- Giúp đảm bảo rằng dữ liệu được nhập vào cột đó phù hợp với ý nghĩa của cột.

		Ví dụ:
			- Điểm của sinh viên phải là các số nguyên: 0..10.
			- Giới tính chỉ có ba giá trị kiểu chuỗi: Nam, Nữ, Khác.

	2. Ràng buộc khoá (Key Constraint / Uniqueness Constraint): Là một hoặc nhiều cột, được sử dụng để đảm bảo mỗi dòng trong bảng là duy nhất.

		- Trong cuộc sống, luôn cần có cách để nhận diện đối tượng bằng một giá trị độc nhất, giúp dễ dàng hơn trong việc quản lý.
		
		- Vì vậy, thuộc tính khoá chính được sử dụng, mỗi khoá chính sẽ giúp xác định chính xác và duy nhất một dòng dữ liệu trong bảng.

			Ví dụ: cột "Mã đơn hàng", "Mã số sinh viên", "Mã thẻ căn cước công dân"...

		-> Cách để định vị một thông tin duy nhất giữa vô vàn thông tin.

		* Relation Key: Chìa khoá (cột) để mở một ổ khoá (dòng) - Giúp xác định duy nhất một ổ khoá.
			- Mỗi dòng phải có một giá trị khác nhau.
			- Không có dòng nào được phép mang giá trị NULL.

		* Phân loại khoá:

			- Siêu khoá (Super Key): Cũng là một hoặc nhiều cột giúp xác định duy nhất một dòng trong bảng.
				+ Các cột sẽ kết hợp với nhau, thậm chí là tất cả các cột cùng kết hợp.
				+ Tạo thành một tập vô cùng lớn, dư thừa rất nhiều dữ liệu, chỉ để xác định được một dòng trong bảng.
				+ Nói cách khác, cứ là khoá - cứ giúp xác định một dòng trong bảng thì được gọi là siêu khoá.
				+ Đóng vai trò như "chợ đầu mối", chuyên cung cấp lẻ khoá cho nơi khác.

				Ví dụ: Tất cả các cột đều có thể kết hợp để làm siêu khoá.

					PhòngThi (S̲B̲D̲, M̲ã̲S̲V̲, H̲ọ̲T̲ê̲n̲, N̲g̲à̲y̲S̲i̲n̲h̲)

			- Khoá ứng viên (Candidate Key): Được trích xuất từ siêu khoá, nhưng chỉ chọn ra những tập bé nhất bằng cách loại bỏ đi những cột thừa.

				Ví dụ: Là tập bé nhất trong siêu khoá.

					PhòngThi (S̲B̲D̲, MãSV, HọTên, NgàySinh)

					PhòngThi (SBD, M̲ã̲S̲V̲, HọTên, NgàySinh)

			- Khoá chính (PRIMARY KEY - PK): Là một trong nhiều khoá ứng viên được chọn ra.
				+ Là một cột đặc biệt với giá trị bên trong bị cấm trùng trên mọi dòng (cấm trùng trên mọi ô cùng cột).
				+ Giá trị cấm trùng đó sẽ được sử dụng để làm đại diện cho cả một dòng, giúp xác định duy nhất một đối tượng / thực thể.
				+ Trong khoá chính đã bao gồm ràng buộc NOT NULL (NOT NULL Constraint).
				+ Nên chọn khoá chính là sự kết hợp của ít cột nhất (tốt nhất là chỉ có một cột) và không chứa đa trị.
					Ví dụ: Số điện thoại và email vẫn đủ để làm khoá chính, nhưng một người lại có thể có nhiều số điện thoại và email.
				+ Nên dựa vào quan hệ lập luận để chọn chứ không nên dựa vào giá trị của dữ liệu tại một thời điểm.
					Ví dụ: Tại một thời điểm, giá trị của các dữ liệu trong một cột có thể khác nhau, nhưng trong tương lai thì không chắc.
				+ Cũng không nên chọn những cột mà mình không có quyền kiểm soát (không nắm bắt được quy luật), nếu cần thiết thì sẽ phát sinh thêm cột.
					Ví dụ: Trong trường học có lưu cả số CMND/CCCD của sinh viên, nhưng lại quản lý theo mã sinh viên vì đây là mã số mà nhà trưởng nắm được quy luật và có thể kiểm soát được.

				* Tham chiếu (Reference): Từ nơi này trỏ đến nơi khác, từ nơi thuộc tính đang làm khoá ngoại "tham chiếu" đến nơi thuộc tính đang làm khoá chính.
					- Trong bảng có một cột, giá trị của cột này có được là nhờ tham chiếu (đi vạy mượn) từ một cột khoá chính trong bảng khác.
					- Bảng chứa khoá chính yêu cầu phải tồn tại trước (được lập liệu, có giá trị trước) thì nơi sử dụng làm khoá ngoại mới có thể tham chiếu đến.

			- Khoá ngoại (FOREIGN KEY - FK): Đang là khoá chính của một bảng, nhưng nay lại "xuất ngoại" / "vi hành" sang bảng khác.
				+ Đôi khi còn được gọi với một tên khác là ràng buộc tham chiếu (REFERENCE Constraint).
				+ Phát sinh khi các bảng có mối quan hệ với nhau và cần sử dụng dữ liệu của nhau.
				+ Thường được dùng để liên kết giữa các bảng, hạn chế sai sót trong quá trình lưu trữ dữ liệu.
				+ Khoá chính của một bảng (nơi cung cấp dịch vụ) sẽ nằm yên, đợi khoá ngoại của bảng khác (nơi sử dụng dịch vụ) tham chiếu đến để sử dụng.
				+ Khoá ngoại yêu cầu đi đến nơi khác và tiến hành JOIN để xem và lấy dữ liệu.
				+ Tuy không yêu cầu trùng tên cột giữa hai bảng, nhưng bắt buộc phải có cùng kiểu dữ liệu và trùng miền giá trị (có gì dùng nấy).
				+ Được phép nhận giá trị NULL, điều này nghĩa là giữa hai dòng trong bảng chưa hình thành bất kì mối quan hệ nào.

				Ví dụ: Khoá chính "xuất ngoại" / "vi hành" sang bảng khác.

								    Khoá ngoại ------
										    |
										    v
					NhânViên (M̲ã̲N̲V̲, HọTên, NgàySinh, QuêQuán, M̰ã̰P̰B̰)
										    |
						   ----------- Tham chiếu -----------
						   |
						   v
					PhòngBan (M̲ã̲P̲B̲, TênPB, ĐịaChỉ)
						   ^
						   |
						   ------ Khoá chính

			- Khoá phức (Composite key): Phải có tối thiểu từ hai cột trở lên cùng làm khoá chính.

	3. Ràng buộc NOT NULL (NOT NULL Constraint): Khá giống với ràng buộc về khoá chính khi ràng buộc NOT NULL cũng cấm giá trị trong một cột được phép là NULL.
		- Đồng nghĩa với việc, khi nhập dữ liệu hoặc chỉnh sửa dữ liệu cho một dòng, dòng đó không được phép chứa giá trị NULL tại cột được chỉ định NOT NULL.
		- Phải chỉ định rõ khi cần thiết, vì mặc định các kiểu dữ liệu cho phép NULL.
		- Trong thường hợp của khoá chính, ràng buộc NOT NULL là mặc định.

	4. Ràng buộc toàn vẹn thực thể (Entity Integrity Constraint): Khoá chính phải luôn luôn có giá trị, không được NULL (đã ngầm có NOT NULL).

	5. Ràng buộc toàn vẹn tham chiếu (Referential Integrity Constraint): Là ràng buộc giữa ít nhất hai bảng thông qua khoá ngoại.
		* Bên đi tham chiếu (Referencing Relation): Chủ động chứa cột của bảng khác.
		* Bên được tham chiếu (Referenced Relation): Nằm yên để người khác dùng cột của mình.

		- Khi cột thuộc tính khoá chính trong bảng của bên "được tham chiếu" chạy sang làm thuộc tính khoá ngoại trong bảng của bên "đi tham chiếu".
		- Cho gì dùng nấy, không được tài lanh sử dụng những giá trị mà chính nơi cho cũng không có.
		- Vì khoá ngoại được phép NULL nên thà để trống vẫn còn hơn là nhập giá trị tầm bậy.

	- NULL: Được quyền bỏ trống giá trị của thuộc tính. Mặc định sẽ là NULL.

	- NOT NULL: Giá trị trong một ô không được phép mang trạng thái NULL, mà bắt buộc phải có giá trị.

		- Thường thấy dưới dạng dấu hoa thị màu đỏ (*) tại các biểu mẫu / đơn nhập dữ liệu.

		- Nhưng không phải lúc nào cũng sử dụng NOT NULL, vì người dùng rất ngại trong việc bị sưu tầm thông tin.

	- UNIQUE

	- CHECK

		- Miền giá trị (RANGE): Chỉ cho phép giá trị nhập vào nằm trong một khoảng nhất định.

	- DEFAULT: Đưa trước một giá trị nào đó vào để làm giá trị mặc định nếu trước đó thông tin được để trống.

--------------------

Các ràng buộc kể trên được gọi là State Constraint (Static Constraint) vì nó liên quan đến trạng thái hợp lệ (valid state) của CSDL.

Bên cạnh State Constraint (Static Constraint), còn một loại ràng buộc khác được gọi là Transition Constraint (Dynamic Constraint) vì nó liên quan đến việc thay đổi trạng thái (state change) của CSDL.

Ngoài ra, các ràng buộc dữ liệu cũng được phân loại theo số lượng bảng:

	* Một bảng:

		- Miền giá trị: Các giá trị mà một thuộc tính có thể nhận.

		- Giữa các dòng trong bảng: Không có việc trùng lặp dữ liệu giữa hai dòng.
			+ Tuy không quan tâm đến thứ tự sắp xếp giữa các dòng.
			+ Nhưng giữa các dòng không được trùng thông tin, dòng đến sau phải cẩn thận dòng đến trước.

			-> Khoá chính.

		- Giữa các cột trong bảng: Phải có tính hợp lý (ví dụ: trong một khoá học, ngày bắt đầu ≤ ngày kết thúc).

	* Nhiều bảng với nhau:

		- Tham chiếu: Bảng được tham chiếu phải tồn tại trước, để bảng đi tham chiếu có thể lấy giá trị.
			-> Khoá ngoại.

		- Các dòng giữa các bảng: Mỗi khi phát sinh một dòng trong bảng, sẽ có một dòng trong bảng khác được phát sinh theo (ví dụ: Mỗi dòng hoá đơn sẽ phát sinh một dòng Chi tiết hoá đơn).

		- Các cột giữa các bảng: Tuy dữ liệu được tách thành nhiều bảng khác nhau, nhưng vẫn phải giữa được tính liên kết (ví dụ: ngày sinh của trưởng phòng được lưu trong bảng NhânViên phải nhỏ hơn ngày nhận chức được lưu trong bảng LàmTrưởngĐơnVị.)

----------------------------------------

* Các cơ chế xử lý khi phát hiện những vi phạm RBTV: Được tự động áp dụng mỗi khi có tác động lên giá trị của khoá chính. RBTV

	- Là những cơ chế mà HQTCSDL cho phép cài đặt mỗi khi có phát sinh những ràng buộc khoá ngoại giữa các bảng.

	1. Cơ chế mặc định: Tự động từ chối mọi hành vi vi phạm RBTV, nếu sửa từ đúng thành sai thì sẽ chủ động giữ lại giá trị đúng.

	2. Cơ chế thay thế: Tự động cập nhật giá trị khoá ngoại khi giá trị khoá chính tương ứng bị thay đổi.

	3. Cơ chế sử dụng giá trị NULL: Mọi giá trị vi phạm RBTV sẽ tự động được thiết lập giá trị là NULL.

----------------------------------------

* Ràng buộc (Constraint): Ràng buộc là cách mà người thiết kế cơ sở dữ liệu ép dữ liệu khi đưa vào bảng phải tuân theo một dạng nào đó.

	Ví dụ 1: Đường Bá Hổ có ba việc không làm.
		- Không rót nước, bưng trà.
			&&
		- Không giặt giũ, lau nhà.
			&&
		- Không dọn giường, xếp ga.

	Ví dụ 2: Tối đi chơi, nhớ về nhà sớm.
		- Sớm được định nghĩa:
			+ Buổi tối trong cùng ngày && trước 22g đêm.

	- Mặc định, các hệ quản trị cơ sở dữ liệu cho phép một cột không cần thiết phải có ràng buộc.

	- Nhưng nếu không có ràng buộc thì dữ liệu nhận vào sẽ không được như ý muốn.

	- Vì sẽ có rất nhiều quy tắc (rule), nên mỗi ràng buộc trong cơ sở dữ liệu được quyền đặt cho một cái tên để dễ dàng gợi nhớ, kiểm soát và tránh nhầm lẫn.

		+ Mặc định, các Database Engine sẽ tự động đặt tên cho các ràng buộc tìm thấy (khi ta bắt đầu nhập những lệnh DDL - những câu lệnh tạo dựng dàn khung cho bảng).

		+ Ngoài việc tự động đặt tên, Database Engine còn cung cấp cơ chế cho phép ta tự động đặt tên cho từng ràng buộc.

			* Quy tắc đặt tên sẽ giống như quy tắc đặt tên cho hằng số trong lập trình: In hoa toàn bộ chữ cái và viết cách nhau bằng dấu gạch dưới _.

				Ví dụ: Gài ràng buộc khoá chính cho cột StudentID
					-- Sử dụng từ khoá CONSTRAINT để gài ràng buộc
					-- và đặt tên cho ràng buộc là PK_STUDENTV6
					CONSTRAINT PK_STUDENTV6
					PRIMARY KEY (StudentID)

	- Việc gài ràng buộc nên được thực hiện trước khi bảng có dữ liệu bên trong, vì nếu trước đó đã có dữ liệu không được nhập vào theo đúng theo định dạng, thì việc gài ràng buộc về sau này cũng không có nhiều ý nghĩa nếu dữ liệu bị nhập sai đó không được xoá đi.

	- Ngoài việc khai báo ràng buộc chung trong lúc tạo bảng bằng, ta cũng có thể tách việc tạo ràng buộc khoá chính và khoá ngoại ra hẳn thành một phần riêng bằng câu lệnh ALTER.
		-> Tạo bảng trước, sửa bảng sau.

		Ví dụ: Câu lệnh chuẩn để gài thêm ràng buộc khoá chính cho một bảng.
			ALTER TABLE StudentV7		-- Chỉnh sửa bảng
			ADD CONSTRAINT PK_STUDENTV7	-- Thêm ràng buộc
			PRIMARY KEY (StudentID)		-- Loại ràng buộc

	- Đã thêm được thì chắc chắn cũng sẽ xoá được, ta cũng có thể xoá ràng buộc bằng câu lệnh ALTER kết hợp với câu lệnh DROP. Ngoài việc xoá những khoá chính do ta tự tạo và đặt tên, những khoá chính do Database Engine tự đặt tên cũng sẽ có thể xoá được, miễn ta sao chép được chính xác tên tự động phát sinh.

		Ví dụ: Câu lệnh chuẩn để xoá ràng buộc khoá chính cho một bảng.
			ALTER TABLE StudentV7		-- Chỉnh sửa bảng
			DROP CONSTRAINT PK_STUDENTV7	-- Xoá ràng buộc

	-> Đặt ra quy tắc (rule) cho việc nhập dữ liệu.

------------------------------------------------------------

	[3. DƯỚI GÓC NHÌN CỦA THAO TÁC TRÊN DỮ LIỆU - OPERATION]

Sau khi đã tạo ra được cấu trúc để lưu trữ dữ liệu, không còn bàn về lý thuyết và thiết kế nữa, mà chỉ quan tâm đến những dữ liệu trong CSDL và những truy vấn trên đấy.

	- Cho phép khai thác "không xâm lấn": truy vấn (xem), sắp xếp,... dữ liệu trong bảng.
		+ Cho phép truy vấn dữ liệu và đưa ra thông tin cần thiết.
		+ Giúp trả lời cho những câu hỏi liên quan đến thống kê, báo cáo và phân tích dữ liệu.

		-> Phép toán đại số quan hệ (Relational Algebra Operation).

	- Cho phép khai thác "có xâm lấn": thêm-sửa-xoá dữ liệu trong bảng.
		+ Cho phép ra dữ liệu và quản lý sự thay đổi của dữ liệu theo thời gian.
		+ Giúp duy trì tính đúng đắn của dữ liệu trong bảng.

		-> Phép toán cập nhật (Update Operation / Modification Operation).

----------------------------------------

		[PHÉP TOÁN ĐẠI SỐ QUAN HỆ - RELATIONAL ALGEBRA OPERATION]

Trong đại số quan hệ:
	- Một tập hợp (set) các bộ dữ liệu (tuple) sẽ tạo thành một quan hệ (relation).
	- Mỗi quan hệ (bảng) được xem như một biến (toán hạng) và có thể tham gia vào một biểu thức.
	- Vì vậy, ta có thể áp dụng các phép toán lên các biến này để ra được một kết quả mới mà không làm ảnh hưởng đến các giá trị gốc.

* Phép toán đại số quan hệ (Relational Algebra Operation): Chỉ được sử dụng để khai thác "không xâm lấn" dữ liệu trong CSDL.
	- Là các phép toán cụ thể, được áp dụng lên dữ liệu trong bảng.
	- Giúp khai thác (lấy) dữ liệu trong các bảng của một HQTCSDL.
	- Tạo ra một bảng mới để lưu kết quả chứ không hề làm thay đổi bảng ban đầu.
		+ Có thể nhận đầu vào là một hoặc nhiều bảng.
		+ Nhưng kết quả đầu ra chỉ là duy nhất một bảng mới.

		-> ĐSQH là ngôn ngữ có tính chất đóng.

	-> Xác định cách truy vấn và thao tác dữ liệu.

* Biểu thức đại số quan hệ (Relational Algebra Expression): Gồm các phép toán ĐSQH nối với nhau, tạo thành một chuỗi (sequence).

	Ví dụ: π Fname, Lname, Salary (σ Dno = 5 (EMPLOYEE))

Để xây dựng một biểu thức ĐSQH có thể rất dài và phức tạp, ta có thể.

	- Áp dụng quy tắc về thứ tự ưu tiên trong các phép toán trong ĐSQH:

		1. Các phép toán một ngôi:
			- Phép chọn (SELECT).
			- Phép chiếu (PROJECT).
			- Phép đổi Phép đổi tên (RENAME).

		2. Kết hợp các bảng
			- Phép tích Đềcác (CARTESIAN PRODUCT).
			- Phép kết nối (JOIN).

		3.
			- Phép giao (INTERSECTION).
			- Phép chia (DIVISION).

		4.
			- Phép hội (UNION).
			- Phép trừ (SET DIFFERENCE).

	- Để viết một biểu thức phức tạp, ta có hai cách:

		1. Biểu diễn bằng một chuỗi / tầng (sequence / cascade) trên một dòng (in-line expression): Các phép toán được lồng vào nhau và có thể sử dụng dấu ngoặc để thay đổi độ ưu tiên.
			Ví dụ: π MaNV, MaDA (NHANVIEN_DUAN) ÷ π MaDA (σ MaPB = 1 (DUAN))

		2. Sử dụng phép gán (Assignment Operation): Cho phép đặt tên để tái sử dụng giống như biến.

			* Kí hiệu: R’ ← E.

			- Có thể được sử dụng để đặt tên tạm cho một bảng và các thuộc tính của bảng.
			- Có thể được dùng để lưu lại kết quả của một phép toán (kết quả là một bảng mới).
			- Giúp đơn giản hoá một chuỗi biểu thức ĐSQH bằng tên trung gian đã lưu lại.

			Ví dụ:
				// Đặt tên tạm cho bảng và thuộc tính của bảng
				BRIEF_EMPLOYEE_INFOS (First_name, Last_name, Salary) ← π Fname, Lname, Salary (EMPLOYEE)

				// Lưu lại kết quả của một phép toán
				DEP5_EMPS ← σ Dno = 5 (EMPLOYEE)
				RESULT ← π Fname, Lname, Salary (DEP5_EMPS)

				// Đơn giản hoá một chuỗi biểu thức ĐSQH
				// bằng tên đã lưu lại
				* Gốc:
					1. π MaHV, MaMH (KETQUATHI) ÷ π MaMH (MONHOC)
					2. π MaNV, MaDA (NHANVIEN_DUAN) ÷ π MaDA (σ MaPB = 1 (DUAN))

				* Sử dụng phép gán:

					1.
						R1 ← π MaHV, MaMH (KETQUATHI)
						R2 ← π MaMH (MONHOC)
						KQ ← R1 ÷ R2

					2.
						R1 ← π MaNV, MaDA (NHANVIEN_DUAN)
						R2 ← π MaDA (σ MaPB = 1 (DUAN))
						KQ ← R1 ÷ R2

--------------------

Trên thực tế, có rất nhiều cách để phân loại các phép toán của ĐSQH, một trong những cách đó (tạm gọi là cách 1) là:

----------

	* Phép toán trên một bảng (Unary Relational Operation): Rút trích ra một phần thông tin của bảng.

		1. Phép chọn (SELECT / RESTRICT / FILTER) | σ: Lựa dòng để hiển thị.

			* Công thức tổng quát: σ ϕ (R) = {t | t ∈ R, ϕ(t)}

				- Điều kiện lọc là ϕ (phi - Φ / φ) của phép chọn σ (sigma) trên bảng R sẽ tương đương như các câu lệnh if trong lập trình.

				- Điều kiện lọc (predicate) là một biểu thức luận lý - đúng/sai (Boolean Expression), gọi tắt là biểu thức điều kiện, được tạo thành từ một số mệnh đề (clause), gồm ba thành phần chính:

					1. Tên thuộc tính (Attribute Name): Tên các thuộc tính có trong bảng R.

					2. Các toán tử so sánh (Comparison Operator): =, ≠, <, ≤, >, ≥.

					3.1. Giá trị hằng (Constant Value): Giá trị nằm trong miền giá trị của thuộc tính.
						σ A ϴ B (R) = {t | t ∈ R, t(A) ϴ t(B)}
						
					3.2. Tên một thuộc tính khác (Another Attribute Name).
						σ A ϴ v (R) = {t | t ∈ R, t(A) ϴ v}

					Ví dụ: Các dạng phép chọn khác nhau.
						- σ A ϴ v (R): σ Salary > 30000 (EMPLOYEE)
						- σ A ϴ B (R): σ Age = Weight (PERSON)

				- Giữa các mệnh đề (clause) có thể kết nối với nhau bằng các toán tử luận lý (Boolean Operator): NOT (¬), AND (∧), OR (∨).

					Ví dụ: σ (Dno = 4 AND Salary > 30000) (EMPLOYEE)

				- Sau khi chọn lọc.
					+ Kết quả sẽ tạo ra một bảng mới, chỉ chứa những dòng thoả điều kiện trong R.
					+ Số cột trong bảng mới sẽ bằng so với với số cột trong R.
					+ Số dòng trong bảng mới có thể ít hơn hoặc bằng (dòng nào cũng thoả điều kiện) so với số dòng trong R; thậm chí là bảng rỗng (không có dòng nào, chỉ có đầy đủ cột) nếu không có dòng nào thoả điều kiện lọc.

				- Phép chọn có tính giao hoán (commutative):
					σ <dk₁> (σ <dk₂> (R))
				     =
					σ <dk₂> (σ <dk₁> (R))

				- Các điều kiện của phép chọn có thể được lồng nhau hoặc kết hợp với nhau bằng toán tử AND.
					σ <dk₁> (σ <dk₂> (... (σ <dkₙ> (R)) ...))
				     =
					σ <dk₁> AND <dk₂> AND ... AND <dkₙ> (R)

			* Trong SQL, điều kiện chọn chính là mệnh đề WHERE.

				Ví dụ: Phép chọn trong SQL.

					- Phép chọn: σ Dno = 4 AND Salary > 25000 (EMPLOYEE)

					- Mệnh đề WHERE:
						SELECT *
						FROM EMPLOYEE
						WHERE Dno = 4 AND Salary > 25000;

			* Các toán tử có thể sử dụng:

				- Các toán tử so sánh: =, ≠, <, ≤, >, ≥.
					+ Chỉ áp dụng cho các thuộc tính với miền giá trị có thứ tự (ví dụ: số, chuỗi, ngày-tháng-năm,...).
					+ Các thuộc tính với miền giá trị không có thứ tự sẽ chỉ có thể sử dụng hai toán tử so sánh '=' và '≠' (ví dụ: màu sắc,...).

				- Các toán tử luận lý: NOT (¬), AND (∧), OR (∨).
					+ AND: Chỉ đúng khi tất cả cùng đúng.
					+ OR: Chỉ sai khi tất cả cùng sai (chỉ cần 1 trong nhiều cái đúng là sẽ đúng).
					+ NOT: 

			Ví dụ: Chọn ra tất cả nhân viên làm việc ở phòng 4 và có lương hơn 25.000tr/năm hoặc làm việc ở phòng 5 và có lương trên 30.000tr/năm.

				σ (Dno = 4 AND Salary > 25000) OR (Dno = 5 AND Salary > 30000) (EMPLOYEE)


		2. Phép chiếu (PROJECT) | π: Lựa cột để hiển thị.

			* Công thức: π <cột₁, cột₂, ..., cộtₙ> (R) = {t[A₁, A₂, ..., Aₙ] | t ∈ R}

				- Điều kiện để lọc của phép chiếu π (pi) chính là tên của các cột (tiêu đề của bảng - header) cần hiển thị ra.

				- Sau khi chọn lọc.
					+ Tạo ra một bảng mới, chứa danh sách các cột cần chiếu trong R.
					+ Thứ tự của các cột sẽ tương đương với thứ tự được liệt kê trong phép chiếu (có thể dùng phép chiếu để thay đổi thứ tự hiển thị của cột).
					+ Số cột trong bảng mới có thể ít hơn, bằng hoặc thậm chí nhiều hơn (tạo thêm cột mới để chứa dữ liệu) so với số cột trong R; cũng có thể là bảng rỗng (không có cột nào, nên cũng không có dòng nào) nếu không có cột nào thoả điều kiện lọc.

				- Vì kết quả là một tập hợp (set), nên bảng mới sẽ loại bỏ đi các dòng bị trùng (duplicate elimination) sau khi chiếu.
					+ Trước khi chiếu, một số dòng không bị trùng thông tin vì có một giá trị nào đó trong dòng khác với các dòng còn lại.
					+ Sau khi chiếu, nếu không bao gồm các cột khoá chính, số lượng thông tin được sử dụng để phân biệt các dòng có thể bị ít đi, dễ dẫn đến việc bị trùng thông tin giữa các dòng.

					-> Giảm số cột.

				- Các phép chiếu cũng có thể được lồng vào nhau để tạo thành một chuỗi phép toán.
					+ Nhưng phép chiếu bên trong phải có nhiều cột hơn số cột của phép chiếu bên ngoài.
					+ Phép chiếu bên ngoài chỉ có thể chiếu các cột mà phép chiếu bên trong đang có, nếu không sẽ tạo ra một biểu thức lỗi.
					+ Vì vậy, phép chiếu không có tính giao hoán.

					π <list1> (π <list2> (R))
				     =
					π <list1> (R)

			* Trong SQL, danh sách cột được liệt kê trong mệnh đề SELECT.
				- Nhưng trong phép chiếu, kết quả trả về mặc định sẽ là một tập  hợp (set) với các dòng không trùng nhau.
				- Còn kết quả mặc định của mệnh đề SELECT trong SQL lại trả về một tập hợp đa phần tử (multiset / bag) với các dòng có thể trùng nhau.
				- Vì các dòng bị trùng trong SQL sẽ không được tự động xoá (eliminated) giống như trong phép chiếu, nên yêu cầu phải có thêm từ khoá DISTINCT ở phía sau mệnh đề SELECT để loại bỏ đi các dòng bị trùng.

				Ví dụ: Phép chiếu cấm trùng dòng trong SQL.

					- Phép chiếu: π Gender, Salary (EMPLOYEE)

					- Mệnh đề SELECT và từ khoá DISTINCT:
						SELECT DISTINCT Gender, Salary
						FROM EMPLOYEE

			* Công thức mở rộng (Extended Projection):

				- Ngoài việc sử dụng phép chiếu để giảm số cột.
					+ Giúp hai bảng dễ dàng thoả điều kiện sử dụng các phép toán tập hợp: hợp, giao và trừ.
					+ Ta cũng có thể sử dụng phép chiếu để phát sinh ra cột (ví dụ: thuộc tính dẫn xuất trong ERD).

				- Có thể sử dụng các phép toán số học lên các cột.
					+ Phép toán sẽ thay đổi một cột nào đấy.
					+ Thậm chí là phát sinh cột mới từ những cột có sẵn.

					-> Tăng số cột.

				Ví dụ:
					// Thay đổi một cột trong bảng
					π A * 2, B (R)

					// Phát sinh cột mới
					π (A + B) -> C, A, B (R)

						- A và B là hai cột khác nhau, sử dụng các phép toán để phát sinh ra bảng C.
						- Sau đó hiển thị cả ba bảng: C, A và B.


		3. Phép đổi tên (RENAME) | ρ: Đổi tên của bảng và cột.

			* Công thức
				1. Đổi tên bảng: ρ <tên-bảng-mới> (R)
				2. Đổi tên cột: ρ <tên-cột-mới₁, ..., cột-cột-mớiₙ> (R)
				3. Đổi tên bảng và tên cột: ρ <tên bảng mới> <tên-cột-mới₁, ..., cột-cột-mớiₙ> (R)

				- Đằng sau kí hiệu ρ (rô - rho) có thể là tên mới của bảng, tên mới của cột hoặc cả hai.

				- Khi đổi tên nhiều cột, những cột nào không muốn đổi tên thì cứ giữ nguyên tên cũ.

				Ví dụ: Xét bảng R(B, C, D).
					- Đổi tên bảng R -> S: ρ S (R)
					- Đổi tên chỉ một cột (B, C, D) -> (X, C, D): ρ X, C, D (R)
					- Đổi cả tên bảng và tên cột: ρ S (X, C, D) (R)

			* Trong SQL, ta có thể đặt bí danh (alias) cho bảng và cột bằng mệnh đề AS.
				- Đây là bí danh (tên tạm), chỉ tồn tại trong thời gian thực hiện truy vấn, nên sẽ không làm thay đổi cấu trúc bảng.
				- Mệnh đề WHERE sẽ được thực thi trước mệnh đề SELECT, nên không thể sử dụng bí danh của cột trong WHERE.

				Ví dụ: Đặt bí danh cho bảng và thuộc tính của bảng NHANVIEN.

					SELECT NHANVIEN.Fname AS TenNV, NHANVIEN.Lname AS HoNV
					FROM EMPLOYEE AS NV
					WHERE NV.Dno = 5 AND NV.Lname = 'Nguyen'

----------

	* Phép toán trên hai bảng (Binary Relational Operation): Tương tác giữa các bảng.

		1. Phép toán tập hợp (Set Operation):

			- Nếu chỉ tính riêng từng bảng, ta sẽ không thể áp dụng được các phép toán tập hợp, nhưng sau khi đã thực hiện từng phép toán trên một bảng và nhận về kết quả, ta có thể áp dụng các phép toán tập hợp để liên kết các kết quả này lại với nhau.
				+ Cần ít nhất hai bảng để có thể thực hiện phép toán.
				+ Tuy không thể trực tiếp sử dụng trên một bảng, nhưng vẫn có thể được dùng để kết hợp giữa hai bảng với nhau.

				-> Chỉ sử dụng khi có từ hai bảng trở lên.

			- Chỉ những bảng có cùng lược đồ mới áp dụng được phép toán tập hợp (không áp dụng cho phép tích Đềcác vì không được xem là một phần của các phép toán tập hợp).
				+ Có cùng số cột (tên cột không cần phải trùng nhau) và vị trí tương ứng.
				+ Có cùng miền giá trị trong mỗi cột.

				-> Chỉ áp dụng được khi giữa các bảng có tính khả hợp (Union Compatibility / Type Compatibility).

			- Kết quả là một bảng mới có cùng tên thuộc tính với bảng thứ nhất và tự động loại bỏ những dòng bị trùng.

			1.1. Phép hợp / Phép hội (UNION) | ∪: Gom toàn bộ các dòng trong hai bảng lại với nhau và loại bỏ những dòng bị trùng lặp.

				* Công thức: R ∪ S = {t ∣ t ∈ R OR t ∈ S}

					Ví dụ: Liệt kê những sinh viên có đăng ký học một trong hai môn.

					SVHocLapTrinhMang	SVHocKhaiPhaDuLieu
					---------------------	---------------------
					| MaSV | HoTenSV    |	| MaSV | HoTenSV    |
					|------|------------|	|------|------------|
					| NV01 | Nguyễn An  |	| NV03 | Lê Minh    |
					| NV02 | Trần Dũng  |	| NV04 | Hoàng Linh |
					| NV03 | Lê Minh    |	| NV07 | Hứa Cường  |
					| NV04 | Hoàng Linh |	| NV08 | Đinh Lực   |
					---------------------	| NV09 | Châu Trì   |
								---------------------

					SVHocLapTrinhMang ∪ SVHocKhaiPhaDuLieu

						---------------------
						| MaSV | HoTenSV    |
						|------|------------|
						| NV01 | Nguyễn An  |
						| NV02 | Trần Dũng  |
						| NV03 | Lê Minh    |
						| NV04 | Hoàng Linh |
						| NV07 | Hứa Cường  |
						| NV08 | Đinh Lực   |
						| NV09 | Châu Trì   |
						---------------------
			

			1.2. Phép giao (INTERSECTION) | ∩: Chỉ lấy những dòng chung của hai bảng.

				* Công thức: R ∩ S = {t ∣ t ∈ R AND t ∈ S}

					Ví dụ: Tìm ra những sinh viên có đăng ký học cả hai môn.

					SVHocLapTrinhMang	SVHocKhaiPhaDuLieu
					---------------------	---------------------
					| MaSV | HoTenSV    |	| MaSV | HoTenSV    |
					|------|------------|	|------|------------|
					| NV01 | Nguyễn An  |	| NV03 | Lê Minh    |
					| NV02 | Trần Dũng  |	| NV04 | Hoàng Linh |
					| NV03 | Lê Minh    |	| NV07 | Hứa Cường  |
					| NV04 | Hoàng Linh |	| NV08 | Đinh Lực   |
					---------------------	| NV09 | Châu Trì   |
								---------------------

					SVHocLapTrinhMang ∩ SVHocKhaiPhaDuLieu

						---------------------
						| MaSV | HoTenSV    |
						|------|------------|
						| NV03 | Lê Minh    |
						| NV04 | Hoàng Linh |
						---------------------
			
			* Lưu ý: Riêng phép hội và phép giao sẽ có thêm hai tính chất.

				* Giao hoán:
					R ∪ S = S ∪ R
					R ∩ S = S ∩ R

				* Kết hợp:
					R ∪ (S ∪ T) = (R ∪ S) ∪ T
					R ∩ (S ∩ T) = (R ∩ S) ∩ T


			1.3. Phép trừ / Phép hiệu (SET DIFFERENCE / EXCEPT / MINUS) | '−': Chỉ bao gồm những dòng riêng của một bảng.

				* Công thức: R − S = {t ∣ t ∈ R AND t ∉ S}

					Ví dụ: Tìm ra những nhân viên chưa từng tham gia dự án.

					NhanVien		NhanVien_DuAn
					---------------------	---------------
					| MaNV | HoTenNV    |	| MaDA | MaNV |
					|------|------------|	|------|------|
					| NV01 | Nguyễn An  |	| DA01 | NV01 |
					| NV02 | Trần Dũng  |	| DA02 | NV03 |
					| NV03 | Lê Minh    |	| DA03 | NV01 |
					| NV04 | Hoàng Linh |	| DA04 | NV04 |
					| NV05 | Đỗ Đạt     |	| DA05 | NV05 |
					| NV06 | Võ Quân    |	| DA06 | NV01 |
					---------------------	---------------

					π MaNV (NhanVien) − π MaNV (NhanVien_DuAn)
					--------		--------
					| MaNV |		| MaNV |
					|------|		|------|
					| NV01 |		| NV01 |
					| NV02 |		| NV03 |
					| NV03 |		| NV04 |
					| NV04 |		| NV05 |
					| NV05 |		--------
					| NV06 |
					--------

						KetQua (những dòng riêng của NhanVien)
							--------
							| MaNV |
							|------|
							| NV02 |
							| NV06 |
							--------


					- Phép trừ không có tính giao hoán:
						R − S ≠ S − R

					- Ngoài ra, ta có thể biểu diễn phép giao bằng phép trừ: R ∩ S = R − (R − S).
			
			* Trong SQL cũng có các mệnh đề UNION, INTERSECT và EXCEPT tương ứng với các phép toán tập hợp.
				- Ngoài ra còn có các từ khoá UNION ALL, INTERSECT ALL và EXCEPT ALL để bỏ qua việc tự động loại bỏ đi kết quả trùng.

				Ví dụ: Các phép toán tập hợp trong SQL.

					SinhVien (7 dòng)	GiangVien (5 dòng)
					----------------	----------------
					| Ho   | Ten   |	| HoGV | TenGV |
					|------|-------|	|------|-------|
					| Hoang| Linh  |	| Ngo  | Van   |
					| Do   | Dinh  |	| Bui  | Chau  |
					| Dinh | Dat   |	| Hoang| Linh  |
					| Vo   | Xuan  |	| Pham | Huong |
					| Bach | Khang |	| Do   | Dinh  |
					| Cao  | Vinh  |	----------------
					| Tran | An    |
					----------------


					- Phép hội: SinhVien ∪ GiangVien (10 dòng)

					- Mệnh đề UNION:
						SELECT Ho, Ten FROM SinhVien
						UNION
						SELECT HoGV, TenGV FROM GiangVien

						----------------
						| Ho   | Ten   |
						|------|-------|
						| Hoang| Linh  |
						| Do   | Dinh  |
						| Dinh | Dat   |
						| Vo   | Xuan  |
						| Bach | Khang |
						| Cao  | Vinh  |
						| Tran | An    |
						| Ngo  | Van   |
						| Bui  | Chau  |
						| Pham | Huong |
						----------------


					- Phép giao: SinhVien ∩ GiangVien (2 dòng)

					- Mệnh đề INTERSECTION:
						SELECT Ho, Ten FROM SinhVien
						INTERSECTION
						SELECT HoGV, TenGV FROM GiangVien

						----------------
						| Ho   | Ten   |
						|------|-------|
						| Hoang| Linh  |
						| Do   | Dinh  |
						----------------


					- Phép trừ:
						SinhVien − GiangVien (5 dòng)
						GiangVien − SinhVien (3 dòng)

					- Mệnh đề INTERSECTION:
						SELECT Ho, Ten FROM SinhVien
						EXCEPT
						SELECT HoGV, TenGV FROM GiangVien

						----------------
						| Ho   | Ten   |
						|------|-------|
						| Dinh | Dat   |
						| Vo   | Xuan  |
						| Bach | Khang |
						| Cao  | Vinh  |
						| Tran | An    |
						----------------
						
						SELECT HoGV, TenGV FROM GiangVien
						EXCEPT
						SELECT Ho, Ten FROM SinhVien

						----------------
						| HoGV | TenGV |
						|------|-------|
						| Ngo  | Van   |
						| Bui  | Chau  |
						| Pham | Huong |
						----------------


			1.4. Phép tích Đềcác (CARTESIAN PRODUCT / CROSS PRODUCT / CROSS JOIN) | ×: Từng dòng của bảng thứ nhất sẽ đi kết hợp với từng dòng của bảng thứ hai.

				- Không được chính thức xem là một phần của các phép toán tập hợp.
				- Nhưng vẫn liên quan đến tập hợp vì nó tạo ra một tập hợp mới từ hai tập hợp đã cho.
				-> Xếp chung dù không phải là một phép toán tập hợp.

				* Công thức: R × S = {(t, q) ∣ t ∈ R và q ∈ S}

					- Tạo ra một bảng mới.
						+ Số cột sẽ là tổng (+) các cột của hai bảng.
						+ Số dòng sẽ là tích (×) các dòng của hai bảng.

					- Khi cộng các cột.
						+ Vì các cột đến từ các bảng khác nhau, nên tên cột của hai bảng có thể bị trùng nhau và tạo nên sự mơ hồ (ambiguous).
						+ Để phân biệt giữa các cột, ta có thể lấy tên bảng chấm '.' với tên cột của bảng tương ứng (ví dụ: Employee.employeeID và Department.employeeID).

					- Khi nhân các dòng.
						+ Mỗi dòng của bảng đầu tiên sẽ kết hợp với mỗi dòng của bảng thứ hai.
						+ Cứ kết hợp liên tục cho đến khi nào bảng đầu tiên hết dòng thì dừng.
						+ Lấy cả một dòng để kết nối, không phải lấy từng giá trị trong một dòng.

					- Gây nên sự bùng nổ số dòng.
						+ Có thể tạo ra một lượng lớn dữ liệu và làm chậm truy vấn.
						+ Trong số rất nhiều dữ liệu kết hợp được, không phải dòng nào cũng có ý nghĩa và có thể sử dụng được.

					Ví dụ: Tìm ra tên phòng ban đang quản lý dự án.

					PhongBan		DuAn
					----------------	-----------------------
					| MaPB | TenPB |	| MaDA | TenDA | MaPB |
					|------|-------|	|------|-------|------|
					| PB01 | NS    |	| DA01 | A     | PB01 |
					| PB02 | KT    |	| DA02 | B     | PB03 |
					| PB03 | KD    |	-----------------------
					----------------

					(PhongBan × DuAn)
					--------------------------------------------
					| PB.MaPB | TenPB | MaDA | TenDA | DA.MaPB |
					|---------|-------|------|-------|---------|
					| PB01    | NS    | DA01 | A     | PB01    | 🗸
					| PB01    | NS    | DA02 | B     | PB03    |
					| PB02    | KT    | DA01 | A     | PB01    |
					| PB02    | KT    | DA02 | B     | PB03    |
					| PB03    | KD    | DA01 | A     | PB01    |
					| PB03    | KD    | DA02 | B     | PB03    | 🗸
					--------------------------------------------

				* Trong SQL, đây chính là CROSS JOIN.
					- Được dùng để kết nối hai bảng mà...
						+ Không cần thiết lập điều kiện kết nối.
						+ Không cần khả hợp.
						+ Không cần cột chung.
						+ ...
					- Thường được thay thế bằng các phép JOIN khác.

					Ví dụ:
						- Phép tích Đềcác: SinhVien × GiangVien

						- Mệnh đề CROSS JOIN:

							* Cách 1 - Tường minh: Có từ khoá CROSS JOIN.
								SELECT *
								FROM NhanVien CROSS JOIN PhongBan

							* Cách 2 - Ngầm định: Liệt kê bằng dấu phẩy trong FROM (không chỉ định điều kiện kết nối trong mệnh đề WHERE).
								SELECT *
								FROM NhanVien, PhongBan


		* Lưu ý: Các phép toán tập hợp chỉ được áp dụng trên các tập hợp (bảng), không thể áp dụng vào các biểu thức điều kiện.

			Ví dụ:
				- Sai: σ (TenMH = 'NMLT' ∪ TenMH = 'CSDL') (MonHoc)
				- Đúng: (σ TenMH = 'NMLT' (MonHoc)) ∪ (σ TenMH = 'CSDL' (MonHoc))


		2. Các phép toán phi tập hợp: Các phép toán dành riêng cho CSDL quan hệ.

			2.1. Phép kết nối (JOIN) | ⋈:

				Bản chất của JOIN vẫn chỉ là phép tích Đềcác.
					- Nhân từng dòng (cả một dòng) của bảng thứ nhất với từng dòng của bảng thứ hai.
					- Nhưng có bổ sung thêm các điều kiện so sánh chọn để loại bỏ đi những dòng không hợp lệ và những dòng không mong muốn sau khi nhân.

				-> Tương đương với phép tích Đềcác, nhưng có thêm phép chọn.

				Một số khái niệm có liên quan:

					- Cột kết nối (Join Attribute): Là cột được sử dụng để kết nối.
						+ Có thể là cột chung (trùng tên) giữa hai bảng.
						+ Cũng có thể là hai cột riêng biệt.

					- Điều kiện kết nối (Join Condition): Là một mệnh đề mô tả cách thức kết nối giữa các cột bằng toán tử so sánh.
						+ Có thể bao gồm cả toán tử luận lý.
						+ Điều kiện kết nối sẽ trả về giá trị luận lý (TRUE, FALSE, hoặc NULL).
						+ Chỉ những kết quả thoả điều kiện (là TRUE) thì mới được chọn, những kết quả không thoả (có thể là FALSE hoặc đang mang giá trị NULL) sẽ không được chọn.

						Ví dụ:
							NhanVien ⋈ (NhanVien.MaPB = PhongBan.MaPB AND TenPB = 'CNTT') PhongBan

							- Cột kết nối: NhanVien.MaPB và PhongBan.MaPB
							- Điều kiện kết nối: NhanVien.MaNV = PhongBan.MaNV AND TenPB = 'CNTT'

					- Tỷ lệ chọn lọc kết nối (Join Selectivity - JS):
						+ Được tính bằng công thức: Số dòng trả về / số dòng của phép kết tự nhiên.
						+ Thường được dùng để đánh giá hiệu suất của việc truy xuất.

				* Phép kết theta (Theta/General join): R ⋈ ϴ S = σ ϕ (R × S)

					- Sau khi nhân hai bảng, bắt đầu kiểm tra thêm điều kiện lọc (ϴ).
					- Điều kiện lọc áp dụng các phép toán so sánh: =, ≠, <, ≤, >, ≥.
						+ Nếu chỉ sử dụng dấu '=' để so sánh giữa các cột sẽ được gọi là phép kết tương đương (Equi join).
						+ Những phép so sánh còn lại sẽ được gọi là phép kết không tương đương (Non-equi join).
					- Cột điều kiện không cần phải là cột chung giữa hai bảng, mà có thể là sự kết hợp giữa hai hay nhiều cột trong cùng một bảng (ví dụ: (ThoiGianNghiLam - ThoiGianVaoLam) > 2 năm).

					Ví dụ: Tìm ra tên phòng ban đang quản lý dự án.

					NhanVien	   LamViec
					----------------   --------------------------
					| MaNV | TenNV |   | MaNV | NgVL   | NgNL   |
					|------|-------|   |------|--------|--------|
					| NV01 | An    |   | NV01 | 1/2/20 | 3/4/23 |
					| NV02 | Bình  |   | NV03 | 5/6/22 | 7/8/23 |
					| NV03 | Cường |   --------------------------
					----------------

					NhanVien ⋈ (NhanVien.MaNV = LamViec.MaNV AND (year(NgNL) - year(NgVL)) > 2) LamViec
					-----------------------------------------------
					| NV.MaNV | TenPB | LV.MaNV | NgVL   | NgNL   |
					|---------|-------|---------|--------|--------|
					| NV01    | An    | NV01    | 1/2/20 | 3/4/23 |
					-----------------------------------------------


				* Phép kết tương đương / kết bằng (Equi join): R ⋈ (A = B / A = v) S

					- Là một trường hợp đặc biệt của phép kết theta.
					- Khi mọi điều kiện so sánh đều là phép so sánh: =.
					- Từng điều kiện riêng lẻ được so sánh bằng sẽ được gọi là phép kết tương đương khi:
						+ Đảm bảo chỉ có phép so sánh bằng.
						+ Không quan tâm các điều kiện riêng lẻ này có kết hợp với nhau bằng toán tử AND, OR,... hay không.
					- Vì là so sánh bằng giữa hai cột, nên chắc chắn sẽ có hai cột trùng nhau hoàn toàn về giá trị.

					Ví dụ: Tìm ra tên phòng ban đang quản lý dự án.

					PhongBan		DuAn
					----------------	-----------------------
					| MaPB | TenPB |	| MaDA | TenDA | MaPB |
					|------|-------|	|------|-------|------|
					| PB01 | NS    |	| DA01 | A     | PB01 |
					| PB02 | KT    |	| DA02 | B     | PB03 |
					| PB03 | KD    |	-----------------------
					----------------

					PhongBan ⋈ (PhongBan.MaPB = DuAn.MaPB) DuAn
					--------------------------------------------
					| PB.MaPB | TenPB | MaDA | TenDA | DA.MaPB |
					|---------|-------|------|-------|---------|
					| PB01    | NS    | DA01 | A     | PB01    |
					| PB03    | KD    | DA02 | B     | PB03    |
					--------------------------------------------


				* Phép kết tự nhiên (Natural join): R * S

					- Sử dụng kí hiệu là '*' thay vì '⋈'.
					- Là một trường hợp đặc biệt của phép kết tương đương, nhưng tự động bỏ đi cột bị trùng.
					- Không chỉ định tên cột, nên chỉ kết nối khi hai cột có cùng tên và có cùng kiểu dữ liệu.
						+ Nếu khác tên, cần thực hiện phép đổi tên trước khi thực hiện phép kết.
						+ Nếu khác kiểu, chỉ kết nối được khi kiểu dữ liệu này có thể ép kiểu được.

					Ví dụ: Tìm ra tên phòng ban đang quản lý dự án.

					PhongBan		DuAn
					----------------	-----------------------
					| MaPB | TenPB |	| MaDA | TenDA | MaPB |
					|------|-------|	|------|-------|------|
					| PB01 | NS    |	| DA01 | A     | PB01 |
					| PB02 | KT    |	| DA02 | B     | PB03 |
					| PB03 | KD    |	-----------------------
					----------------

					PhongBan * DuAn
					-------------------------------
					| MaPB | TenPB | MaDA | TenDA |
					|------|-------|------|-------|
					| PB01 | NS    | DA01 | A     |
					| PB03 | KD    | DA02 | B     |
					-------------------------------


				* Phép kết ngoài (Outer join): R ⋈ ϴ S

					- Right join
					- Left join


				* Phép nửa kết (Semi join): R ⋈ ϴ S

				* Trong SQL, các bảng cần kết nối sẽ liệt kê trong mệnh đề FROM:

					- Điều kiện kết nối (so sánh) sẽ được viết trong mệnh đề WHERE.

						Ví dụ:
							SELECT *
							FROM PhongBan, DuAn
							WHERE PhongBan.MaPB = DuAn.MaPB

					- Tạo ra một bảng tạm, được lồng (nested) bên trong một bảng khác bằng mệnh đề WHERE.

						Ví dụ:
						SELECT *
						FROM NhanVien
						WHERE MaPB IN (
							SELECT MaPB
							FROM Departments
							WHERE TenPB = 'CNTT'
							      )


					- Một mệnh đề JOIN riêng biệt giống như SELECT, FROM, WHERE,...
						+ Được thêm vào trong SQL2.
						+ Giúp phân biệt rõ ràng điều kiện JOIN với các điều kiện lựa chọn trong câu lệnh WHERE.

						Ví dụ:
							SELECT *
							FROM DonDatHang
							JOIN KhachHang ON DonDatHang.MaKH = KhachHang.MaKH


			2.2. Phép chia (DIVISION) | ÷: Tìm các dòng trong bảng thứ nhất có liên quan đến tất cả các dòng trong bảng thứ hai.

				* Công thức: R ÷ S = {t | ∀ u ∈ S : (t, u) ∈ R}

					- Được dùng để trích các dòng trong bảng R (nhiều thông tin) có liên quan đến tất cả các dòng trong bảng S (ít thông tin).
						- Vì có liên quan nên cần đảm bảo S có bao nhiêu cột thì R cũng phải có từ bấy nhiêu trở lên (cùng số cột và miền giá trị).
						- Nếu S có những cột mà R không có thì phải sử dụng phép chiếu để bỏ bớt cột khác nhau, giúp kết quả chia được chính xác hơn.

					- Sẽ tạo ra một bảng mới.
						+ Số cột sẽ là R − S (bỏ đi cột trùng).
						+ Số dòng sẽ chỉ gồm những dòng chung của cả hai bảng, nhưng với một số điều kiện:
							1. Dữ liệu trong các cột chung giữa R và S phải khớp nhau hoàn toàn.
							2. Dữ liệu trong các cột còn lại của R, dòng nào cũng phải giống hệt nhau.

							Ví dụ:
							
							BangA		    BangB
							----------------    -----------
							|Cot1|Cot2|Cot3|    |Cot2|Cot3|
							|----|----|----|    |----|----|
							| 7  | A1 | B2 |    | A1 | B2 |
							| 9  | A1 | B4 |    | A1 | B4 |
							| 1  | A1 | B2 |    -----------
							| 1  | A8 | B4 |
							| 3  | A1 | B2 |
							| 7  | A1 | B4 |
							---------------- 

							BangA ÷ BangB
								------
								|Cot1|
								|----|
								| 7  |
								| 7  |
								------


					Ví dụ: Tìm ra mã sinh viên theo điều kiện.

					MonHoc			KetQua
					-----------------------	----------------------
					| MaMH | TenMH | SoTC |	| MaSV | MaMH | Diem |
					|------|-------|------|	|------|------|------|
					| MH01 | TH    | 2    |	| SV01 | MH01 | 5    |
					| MH02 | LT    | 3    |	| SV01 | MH02 | 7    |
					| MH03 | DL    | 2    |	| SV01 | MH03 | 6    |
					| MH04 | KT    | 4    |	| SV02 | MH01 | 8    |
					-----------------------	| SV02 | MH03 | 7    |
								| SV03 | MH01 | 8    |
								| SV03 | MH02 | 9    |
								| SV03 | MH03 | 7    |
								| SV03 | MH04 | 6    |
								| SV04 | MH02 | 5    |
								----------------------

					- Sinh viên đã thi môn TH và LT trong MonHoc:
					R1 ← π MaMH (σ TenMH = 'TH' (MonHoc) ∪ σ TenMH = 'LT' (MonHoc))
					KetQua ÷ R1

					- Sinh viên thi những môn có số tín chỉ = 2:
					R1 ← π MaMH (σ SoTC = 2 (MonHoc))
					KetQua ÷ R1

--------------------

	[TỔNG KẾT: CÁC PHÉP TOÁN TRONG ĐẠI SỐ QUAN HỆ]

	- Phép chọn (SELECT): Lựa dòng để hiển thị.
		| σ <điều kiện lọc> (R)

	- Phép chiếu (PROJECT): Lựa cột để hiển thị và xoá dòng trùng.
		| π <cột₁, cột₂, ..., cộtₙ> (R)

	- Phép đổi tên (RENAME): Đổi tên của bảng, cột hoặc cả hai.
		| ρ <tên-bảng-mới> (R)
		| ρ <danh-sách-tên-cột-mới> (R)
		| ρ <tên bảng mới> <danh-sách-tên-cột-mới> (R)

	- Phép hợp (UNION): Gom toàn bộ dòng trong hai bảng lại và bỏ dòng trùng.
		| R ∪ S

	- Phép giao (INTERSECTION): Chỉ lấy những dòng chung của hai bảng.
		| R ∩ S

	- Phép trừ (SET DIFFERENCE): Chỉ bao gồm những dòng riêng của một bảng.
		| R − S

	- Phép chia (DIVISION): Tìm các dòng trong bảng này có liên quan (cùng số cột và miền giá trị) với tất cả các dòng trong bảng khác.
		| R ÷ S

	- Phép tích Đềcác (CARTESIAN PRODUCT): Cộng hai cột, từng dòng của bảng này sẽ đi kết hợp với từng dòng (đến hết tất cả dòng) của bảng khác.
		| R × S

	- Phép kết nối (JOIN): Có lọc thêm điều kiện sau khi thực hiện phép tích Đềcác.
		+ Theta join: Điều kiện là các phép toán {=, ≠, <, ≤, >, ≥} trên thuộc tính.
			| R ⋈ ϴ S
		+ Equi join: Điều kiện chỉ toàn chứa phép toán bằng '=', sẽ dẫn đến có hai cột trùng tên và giá trị hoàn toàn.
			| R ⋈ <A = B / A = v> S
		+ Natural join: Kết nối mà không cần chỉ định điều kiện, tự động loại bỏ cột trùng tên.
			| R * ϴ S

--------------------

* Lưu ý 1: Ngoài cách phân loại ở bên trên (cách 1), còn có một số cách khác nhau để phân loại các toán tử của đại số quan hệ, có thể kể đến.

	* Cách 2: 

		- Có 5 toán tử là toán tử cơ bản (complete set) trong ĐSQH.

			+ Bao gồm:
				1. Phép hội (UNION)
				2. Phép trừ (SET DIFFERENCE)
				3. Phép tích Đềcác (CARTESIAN PRODUCT)
				4. Phép chọn (SELECT)
				5. Phép chiếu (PROJECT)

			+ Chỉ cần 5 toán tử này là đủ để thực hiện các thao tác truy xuất dữ liệu.

			+ Cũng có thể dùng 5 toán tử này để biểu diễn thay thế cho những toán tử khác, chỉ là không gọn và thuận tiện bằng.

				Ví dụ:
					R ∩ S = R − (R − S).
					R ∩ S = ((R ∪ S) − (R − S)) − (S − R)
					R ∩ S = (R ∪ S) – ((R – S) ∪ (S – R))
					R ⋈ ϴ S = σ ϕ (R × S)

					T1 ← π y (R)
					T2 ← π y ((S × T1) – R)
					T ← T1 – T2

		- Có 3 toán tử mở rộng.

			+ Bao gồm:
				1. Phép giao (INTERSECTION)
				2. Phép kết (JOIN)
				3. Phép chia (DIVISION)
				4. Phép đổi tên (RENAME)

			+ Được thêm vào vì tính tiện dụng chứ không phải cần thiết.
			
			+ 3 toán tử này lại thường được sử dụng hơn để thay thế cho 5 toán tử cơ bản, giúp đơn giản hoá các câu lệnh truy vấn.


	* Cách 3:

		- Các phép toán trên tập hợp:
			1. Phép hội (UNION)
			2. Phép giao (INTERSECTION)
			3. Phép trừ (SET DIFFERENCE)

		- Rút trích một phần của bảng:
			1. Phép chọn (SELECT)
			2. Phép chiếu (PROJECT)

		- Kết hợp các bảng:
			1. Phép tích Đềcác (CARTESIAN PRODUCT)
			2. Phép kết (JOIN)

		- Đổi tên:
			1. Phép đổi tên (RENAME)

		(Cách này không phân loại cho Phép chia (DIVISION).)


	* Cách 4: 

		- Các phép toán tập hợp:
			1. Phép hội (UNION)
			2. Phép giao (INTERSECTION)
			3. Phép trừ (SET DIFFERENCE)
			4. Phép tích Đềcác (CARTESIAN PRODUCT)

		- Các phép toán dành riêng cho CSDL quan hệ:

			+ Các phép toán một ngôi:
				1. Phép chọn (SELECT)
				2. Phép chiếu (PROJECT)
				3. Phép đổi tên (RENAME)

			+ Các phép toán hai ngôi:
				1. Phép kết (JOIN)
				2. Phép chia (DIVISION)

* Lưu ý 2: Nên ưu tiên thực hiện phép chọn (SELECT) trước để loại bớt số dòng dữ liệu dư thừa, sau đó mới thực hiện các phép khác sau.
	- Nếu vẫn quyết định thực hiện phép chiếu (PROJECT) trước phép chọn (SELECT), cần đảm bảo chừa lại đủ các cột mà phép chọn (SELECT) cần để thực hiện lọc dữ liệu.

* Lưu ý 3: Các phép toán tập hợp: hội, giao,... sẽ được sử dụng khi giữa các mệnh đề không thể sử dụng các toán tử luận lý: AND, OR,... được.

--------------------

* Bài tập:

	Phép hợp (UNION): R ∪ S
	Phép giao (INTERSECTION): R ∩ S
	Phép trừ (SET DIFFERENCE): R − S
	Phép tích Đềcác (CARTESIAN PRODUCT): R × S

	Phép chọn (SELECT): σ <điều kiện lọc> (R)
	Phép chiếu (PROJECT): π <cột₁, cột₂, ..., cộtₙ> (R)

	Phép đổi tên (RENAME): ρ <tên bảng hoặc cột mới> (R)
	Phép kết nối (JOIN): R ⋈ ϴ S
	Phép chia (DIVISION): R ÷ S

	Phép gán  (Assignment Operation): R’ ← E

	- Các toán tử so sánh: =, ≠, <, ≤, >, ≥.
	- Các toán tử luận lý: NOT (¬), AND (∧), OR (∨).

	1. Một CSDL gồm 5 bảng:

		Product (P̲r̲o̲d̲u̲c̲t̲C̲o̲d̲e̲, ProductName, PurchasePrice, SellPrice, Type, #SupplierCode)

		Supplier (S̲u̲p̲p̲l̲i̲e̲r̲C̲o̲d̲e̲, SupplierName, Address)

		Employee (E̲m̲p̲l̲o̲y̲e̲e̲I̲D̲, FullName, Gender, BirthDay, Address)

		Invoice (I̲n̲v̲o̲i̲c̲e̲I̲D̲, SellDate, #EmployeeID)

		InvoiceLine (#̲P̲r̲o̲d̲u̲c̲t̲C̲o̲d̲e̲,̲ ̲#̲I̲n̲v̲o̲i̲c̲e̲I̲D̲, Quantity)

		* BT1:

			1. Lấy ra mã và tên của bảng Product.
				π ProductCode, ProductName (Product)

			2. Lấy ra những sản phẩm có giá trị > 100.000.
				σ SellPrice > 100000 (Product)

			3. Lấy ra những nhân viên từng bán sản phẩm.
				R1 = Invoice ⋈ Employee
				R2 = π EmployeeID, FullName, Gender, BirthDate, Address (R1)

			4. Lấy ra những sản phẩm được bán vào tháng 8.
				R1 = InvoiceLine ⋈ Invoice
				R2 = R1 ⋈ Product
				R3 = σ month(SellDate) = 8 (R2)
				R4 = π ProductCode, ProductName, PurchasePrice, SellPrice, Type, SupplierCode (R3)

		* BT2:

			1. Lấy ra tên và giá bán của những sản phẩm TV được cung cấp bởi SONY.
				R1 = Product ⋈ Supplier
				R2 = σ Type = "TV" AND SupplierName = "SONY" (R1)
				R3 = π ProductName, SellPrice (R2)

			2.1. Lấy ra tên và địa chỉ của các nhà cung cấp sản phẩm TV.
				R1 = Product ⋈ Supplier
				R2 = σ Type = "TV" (R1)
				R3 = π SupplierName, Address (R2)

			2.2.* Lấy ra tên và địa chỉ của các nhà cung cấp sản phẩm TV hoặc ĐT.
				R1 = Product ⋈ Supplier
				R2 = σ Type = "TV"(R1)
				R3 = σ Type = "Mobile" (R1)
				R4 = R3 ∪ R2
				R5 = π SupplierName, Address (R4)

			3. Lấy ra tên của tất cả các nhân viên sinh năm 2000.
				R1 = σ year(BirthDay) = 2000 (Employee)
				R2 = π FullName (R1)

			4. Lấy ra tên và loại của tất cả sản phẩm được bán vào ngày 23/05/2020.
				R1 = InvoiceLine ⋈ Invoice
				R2 = σ SellDate = "23/05/2020" (R1)
				R3 = R2 ⋈ Product
				R4 = π ProductName, Type (R3)

			5.1. Lấy ra tên của những nhân viên nữ đã từng bán TV.
				R1 = InvoiceLine ⋈ Invoice
				R2 = R1 ⋈ Employee
				R3 = R2 ⋈ Product
				R4 = σ Gender = "Female" AND Type = "TV" (R3)
				R5 = π FullName (R4)

			5.2.* Lấy ra tên của những nhân viên nữ đã từng bán TV hoặc ĐT.
				R1 = InvoiceLine ⋈ Invoice
				R2 = R1 ⋈ Employee
				R3 = R2 ⋈ Product
				R4 = σ Gender = "Female" (R3)
				R5 = σ Type = "TV" (R4)
				R6 = σ Type = "Mobile" (R4)
				R7 = R4 ∪ R5
				R8 = π FullName (R5)

			6.1. Lấy ra tên và địa chỉ của các nhà cung cấp có cung cấp TV và ĐT.
				R1 = Supplier ⋈ Product
				R2 = σ Type = "TV" (R1)
				R3 = σ Type = "Mobile" (R1)
				R4 = R2 ∩ R3
				R5 = π SupplierName, Address (R4)

			6.2.* Lấy ra tên và địa chỉ của các nhà cung cấp chỉ cung cấp TV hoặc chỉ cung cấp ĐT.
				R1 = Supplier ⋈ Product
				R2 = σ Type = "TV" (R1)
				R3 = σ Type = "Mobile" (R1)
				R4 = R2 ∩ R3
				R5 = R2 − R4
				R6 = R3 − R4
				R7 = R3 ∪ R5
				R8 = π SupplierName, Address (R7)

			7. Lấy ra tên và giá của tất cả sản phẩm được bán bởi nhân viên "Nguyễn Văn An" trong tháng 04/2020.
				R1 = InvoiceLine ⋈ Invoice
				R2 = R1 ⋈ Employee
				R3 = R2 ⋈ Product
				R4 = σ FullName = "Nguyễn Văn An" AND month(SellDate) = "04" AND year(SellDate) = "2000" (R3)
				R5 = π ProductName, SellPrice (R4)

			8. Lấy ra tên và giá của tất cả sản phẩm ĐT của LG trong tháng 04/2020.
				R1 = InvoiceLine ⋈ Invoice
				R2 = R1 ⋈ Product
				R3 = R2 ⋈ Supplier
				R4 = σ Type = "Mobile" AND SupplierName = "LG" (R1)
				R5 = σ month(SellDate) = "04" AND year(SellDate) = "2000" (R4)
				R6 = π ProductName, SellPrice (R5)

			9. Lấy ra sản phẩm có giá bán cao nhất.
				σ SellPrice = max(SellPrice) (Product) (Product)

			10. Lấy ra tổng tiền (Quantity * SellPrice) của mỗi chi tiết hoá đơn với ngày bán là 30/04/2020.
				R1 = InvoiceLine ⋈ Invoice
				R2 = R1 ⋈ Product
				R3 = σ SellDate = "30/04/2020" (R2)
				R4 = π (Quantity * SellPrice) -> TotalPrice (R3)

--------------------

Các phép toán ĐSQH cơ bản sẽ không thể thực hiện được một số thao tác thống kê, báo cáo,  tổng hợp, tóm tắt dữ liệu từ các bảng,...

* Các phép toán quan hệ bổ sung (Additional Relational Operations):
	- Hàm tập hợp (Aggregate Function):
	- Phép gom nhóm các dòng (Grouping):
	- Phép kết mở rộng (OUTER JOIN):
	- Phép hội mở rộng (OUTER UNION):

----------

----------------------------------------

		[PHÉP TOÁN CẬP NHẬT - UPDATE OPERATION / MODIFICATION OPERATION]

* Phép toán cập nhật (Update Operation / Modification Operation): Được sử dụng để khai thác "có xâm lấn" dữ liệu trong CSDL.

--------------------

	1. Phép bổ sung / chèn (Insert): Thêm một dòng dữ liệu (t) vào bảng (r), kí hiệu là: r = r ∪ t.

		* Kí hiệu:
					       Tên bảng		Giá trị trong miền giá trị
					       ---------       ---------------------------
						       |       |
						       v       v
			- Cách 1 - Tường minh: INSERT (r; A₁ = d₁, A₂ = d₂, ..., Aₙ = dₙ)
							  ^
							  |
							  ---------------
							   Tên thuộc tính

			- Cách 2 - Ngầm định: INSERT (r; d₁, d₂, ..., dₙ)

		Ví dụ 1: Thêm một dòng phòng ban t = (IT01, CNTT, HoangNT2) vào bảng PhongBan (M̲a̲P̲B̲, TenPB, MaTrPh).

			- Cách 1: INSERT (PhongBan; M̲a̲P̲B̲ = IT01, TenPB = CNTT, MaTrPh = HoangNT2)

			- Cách 2: INSERT (PhongBan; IT01, CNTT, HoangNT2)

		Ví dụ 2: KetQua (#̲M̲S̲S̲V̲,̲ ̲#̲M̲M̲H̲, DiemSoMH), t = (SV001, CSDL, 7)

			- Cách 1: INSERT (KetQua; #̲M̲S̲S̲V̲ = SV001, #̲M̲M̲H̲ = CSDL, DiemSoMH = 7)

			- Cách 2: INSERT (KetQua; SV001, CSDL, 7)

--------------------

	2. Phép loại bỏ (Delete): Xoá một dòng dữ liệu (t) khỏi bảng (r), kí hiệu là: r = r - t.

		* Kí hiệu:

			- Cách 1 - Tường minh: DEL (r; A₁ = d₁, A₂ = d₂, ..., Aₙ = dₙ)

			- Cách 2 - Ngầm định: DEL (r; d₁, d₂, ..., dₙ)

					   Thuộc tính khoá
					   ----------------
							  |
							  v
			- Cách 3 - Xoá bằng khoá: DEL (r; B̲₁̲ = e₁, B̲₂̲ = e₂, ..., B̲ₘ̲ = eₘ)
							       ^
							       |
							       ----------------------------
							        Giá trị của thuộc tính khoá

		Ví dụ 1: Xoá một dòng phòng ban t = (IT01, CNTT, HoangNT2) khỏi bảng PhongBan (M̲a̲P̲B̲, TenPB, MaTrPh).

			- Cách 1: DEL (PhongBan; M̲a̲P̲B̲ = IT01, TenPB = CNTT, MaTrPh = HoangNT2)

			- Cách 2: DEL (PhongBan; IT01, CNTT, HoangNT2)

			- Cách 3: DEL (PhongBan; M̲a̲P̲B̲ = IT01)

		Ví dụ 2: KetQua (#̲M̲S̲S̲V̲,̲ ̲#̲M̲M̲H̲, DiemSoMH), t = (SV001, CSDL, 7)

			- Cách 1: DEL (KetQua; #̲M̲S̲S̲V̲ = SV001, #̲M̲M̲H̲ = CSDL, DiemSoMH = 7)

			- Cách 2: DEL (KetQua; SV001, CSDL, 7)

			- Cách 3: DEL (PhongBan; #̲M̲S̲S̲V̲ = SV001, #̲M̲M̲H̲ = CSDL)

--------------------

	3. Phép Thay đổi (Update / Change): Thay đổi một hoặc nhiều giá trị (không phải toàn bộ giá trị) của một dòng dữ liệu (t) trong bảng (r), kí hiệu là: r = (r \ t) ∪ tʼ.

		* Kí hiệu:

				     Giá trị gốc trong bộ t
				     -----------------------
							   |
							   v
			- Cách 1 - Tường minh: CH (r; A₁ = d₁, A₂ = d₂, ..., Aₙ = dₙ;
						      C₁ = e₁, C₂ = e₂, ..., Cₚ = eₚ)
							   ^
							   |
							   ------------------------
							    Giá trị mới trong bộ tʼ

					    Thuộc tính khoá gốc	     Giá trị của khoá gốc
					    --------------------    ---------------------
							       |    |
							       v    v
			- Cách 2 - Ngầm định bằng khoá: CH (r; B̲₁̲ = d₁, B̲₂̲ = d₂, ..., B̲ₘ̲ = dₘ;
							       C₁ = e₁, C₂ = e₂, ..., Cₚ = eₚ)
							       ^    ^
							       |    |
					------------------------    ---------------------
					Thuộc tính cần thay đổi	     Giá trị cần thay đổi

		Ví dụ 1: Thay đổi một thuộc tính t = (IT01, CNTT, DungCT)
					  bằng tʼ = (IT01, CNTT, HoangNT2)
		       trong bảng PhongBan (M̲a̲P̲B̲, TenPB, MaTrPh).

			- Cách 1: CH (PhongBan; M̲a̲P̲B̲ = IT01, TenPB = CNTT, MaTrPh = DungCT; M̲a̲P̲B̲ = IT01, TenPB = CNTT, MaTrPh = HoangNT2)

			- Cách 2: CH (PhongBan; M̲a̲P̲B̲ = IT01; MaTrPh = HoangNT2)

		Ví dụ 2: KetQua (#̲M̲S̲S̲V̲,̲ ̲#̲M̲M̲H̲, DiemSoMH),
			 t = (SV001, CSDL, 7) và tʼ = (SV001, CSDL, 8)

			- Cách 1: CH (KetQua; #̲M̲S̲S̲V̲ = SV001, #̲M̲M̲H̲ = CSDL, DiemSoMH = 7; #̲M̲S̲S̲V̲ = SV001, #̲M̲M̲H̲ = CSDL, DiemSoMH = 8)

			- Cách 2: CH (PhongBan; #̲M̲S̲S̲V̲ = SV001, #̲M̲M̲H̲ = CSDL; DiemSoMH = 8)

--------------------------------------------------------------------------------

[PHƯƠNG PHÁP & NGUYÊN TẮC CHUYỂN ĐỔI TỪ ERD SANG RS
 (CHUYỂN ĐỔI TỪ PHÂN TÍCH SANG THIẾT KẾ, TỪ Ý NIỆM SANG LUẬN LÝ)]

Từ mô hình ERD đã thiết kế sau khi thu thập và phân tích yêu cầu phần mềm (về dữ liệu).

Kết quả của quá trình chuyển Data Model Mapping.


	(* Lưu ý: Để tránh những chồng chéo trong việc ghi chú kí hiệu, kí hiệu nét đứt để biểu diễn cột khoá ngoại sẽ được thay thế bằng cách thêm một kí tự '#' vào trước tên thuộc tính.)

------------------------------------------------------------

Bước 1: Chuyển đổi thực thể (Entity) và thuộc tính (Attribute).

	* Thực thể -> Bảng riêng

	* Thuộc tính:
		- Thuộc tính đơn (nguyên tử), đơn trị và lưu trữ -> Cột

		- Thuộc tính phức -> Mỗi thuộc tính đơn trong thuộc tính phức là một cột
			+ Bỏ qua thuộc tính phức.
			+ Từng thuộc tính đơn trong thuộc tính phức sẽ tương đương một cột.

		- Thuộc tính đa trị -> Tách thành bảng riêng.
			+ Trong một bảng, với sự cản trở của khoá chính mà mỗi đối tượng trong bảng chỉ được xuất hiện một lần (chỉ có duy nhất một dòng dữ liệu).
			+ Nhưng để lưu được nhiều giá trị của thuộc tính đa trị thì lại cần nhiều dòng dữ liệu của cùng một đối tượng.
			+ Bắt buộc phải tạo thành một bảng mới và bảng này phải có cách để lưu được nhiều giá trị của thuộc tính đa trị, mà vẫn biết những giá trị đó thuộc về đối tượng nào.
			+ Bảng mới sẽ có tên được ghép là TENTHUOCTINH_TENBANG.

				1. Nếu giữa thực thể và thuộc tính có quan hệ nhiều-nhiều:
					- Khoá chính là sự kết hợp giữa khoá chính của thực thể + thuộc tính đa trị.
					- Vẫn có khoá ngoại, chính là khoá chính của thực thể.
					Ví dụ:
						- Mỗi NhânViên có nhiều KỹNăng.
						- Mỗi KỹNăng có thể nhiều NhânViên có.
						-> Khoá chính: M̲ã̲N̲V̲,̲ ̲K̲ỹ̲N̲ă̲n̲g̲

				2. Nếu giữa thực thể và thuộc tính có quan hệ một-nhiều:
					- Chỉ riêng thuộc tính đa trị làm khoá chính là đủ.
					- Vẫn có khoá ngoại, chính là khoá chính của thực thể.
					Ví dụ:
						- Mỗi NhânViên có nhiều SĐT.
						- Mỗi SĐT chỉ thuộc về một NhânViên.
						-> Khoá chính: S̲Đ̲T̲

		- Thuộc tính dẫn xuất -> Tuỳ chọn, có thể biểu diễn hoặc không

	* Khoá định danh -> Khoá chính

	Ví dụ: Chuyển thực thể NhânViên thành bảng NhanVien.

		  (Họ)―――――( (HọTên) )―――――(Tên)
				|
				|
		(M̲ã̲N̲V̲)―――――| NhânViên |―――――((SĐT))
				|
				|
			    (GiớiTính)


		NhanVien (M̲a̲N̲V̲, Ho, Ten, GioiTinh)
			   ^
			   |
			   ------------
			   	      |
		SDT_NhanVien (S̲D̲T̲, #MaNV)

------------------------------------------------------------

Bước 2: Chuyển đổi thực thể yếu (Weak Entity).

	* Thực thể yếu -> Bảng riêng

	* Thuộc tính riêng của mối kết hợp -> Cột trong bảng của thực thể yếu
	
	* Khoá:
		- Nếu thuộc tính yếu có khoá định danh riêng:
			+ Khoá chính: Thuộc tính định danh riêng + Khoá chính của thực thể mạnh (giống với thuộc tính đa trị).
			+ Khoá ngoại: Thuộc tính định danh của thực thể mạnh trở thành khoá ngoại.

		- Nếu thuộc tính yếu không có khoá định danh riêng: Thuộc tính định danh của thực thể mạnh vừa là khoá chính, vừa là khoá ngoại.

	Ví dụ: Chuyển thực thể NhânViên thành bảng NhanVien.

		  (HọTên)			(MốiQuanHệ)
		     |				     |
		| NhânViên |―――――<< Có >>―――――|| NgườiThân ||―――――(NgàySinh)
		     |				     |
		  (M̲ã̲N̲V̲)			      (T̰ḛ̂n̰N̰T̰)


		NhanVien (M̲a̲N̲V̲, HoTen)
			    ^
			    |
			    |
		NguoiThan (#M̲a̲N̲V̲,̲ ̲T̲e̲n̲N̲T̲, HoTen, NgaySinh)

------------------------------------------------------------

Bước 3: Chuyển mối kết hợp (Relationship).

	(* Lưu ý: Dấu mũi tên của khoá ngoại sẽ xuất phát từ bên đi tham chiếu (Referencing) sang bên được tham chiếu (Referenced).		
		- Bên đi tham chiếu (Referencing): Chủ động chứa cột của bảng khác.
		- Bên được tham chiếu (Referenced): Nằm yên để người khác dùng cột của mình.)

	* Một ngôi:

		- 1-n: Khoá ngoại đệ quy, tham chiếu đến chính khoá chính trong bảng.
			+ Thuộc tính định danh của riêng mối kết hợp (hoặc phải tự tạo thêm) sẽ trở thành khoá ngoại.
			+ Vì chỉ có một bảng duy nhất, nên khoá ngoại sẽ tham chiếu đến chính khoá định danh của thực thể.

			Ví dụ: NhânViên quản lý / chịu sự quản lý (của) nhân viên khác.

				(M̲ã̲N̲V̲)―――――| NhânViên |―――――(HọTên)
					    |	     |
					1   |	     |    n
				     (1, 1) |	     | (0, n)
					    |	     |
					    ――<Q.Lý>――


				NhanVien (M̲a̲N̲V̲, HoTen, #MaNgQLy)
					   ^		  |
					   |		  |
					   ----------------


		- n-n: Tạo ra một bảng mới cho mối kết hợp.
			+ Vì chỉ có một ngôi, nên khoá chính sẽ phân thân ra thành hai cột khi sang bảng mới.
			+ Bảng mới sẽ có hai cột khoá chính của bảng gốc cùng làm khoá chính, đồng thời cũng là khoá ngoại.

			Ví dụ: Trước khi học một MônHọc, yêu cầu phải học qua một MônHọc khác.

				――――――| MônHọc |―――――――
				|		      |
			    n   |		      |    n
			 (0, n) |		      | (0, n)
				|		      |
				―――――< Điều kiện >―――――


				MonHoc (M̲a̲M̲H̲, TenMH, SoTinChi)
					 ^
					 |
					 ----------------
					    |		|
				DieuKien (#̲M̲a̲M̲H̲,̲ ̲#̲M̲a̲M̲H̲T̲i̲e̲n̲Q̲u̲y̲e̲t̲)


	* Hai ngôi:

		- 1-1: Lấy khoá chính của một bên "xuất ngoại" sang bên còn lại.
			+ Nếu có phân biệt bằng trọng số tối thiểu, khoá chính ở phía bắt buộc (1) sẽ làm khoá ngoại ở phía tuỳ chọn (0).
			+ Nếu hai trọng số bằng nhau thì đặt khoá ngoại tuỳ ý.
			+ Nhưng dù trong trường hợp nào thì những thuộc tính riêng (nếu có) của mối kết hợp đều sẽ đi chung với khoá ngoại.
			+ Phải có thêm ràng buộc, yêu cầu cấm trùng (UNIQUE) trên cột khoá ngoại, nếu không sẽ trở thành trường hợp 1-n.

			Ví dụ: Mối kết hợp giữa BácSĩ và TrạmYTế.

				 (HọTên)				       (TênTYT)
				    |	      1				1	  |
				| BácSĩ |――(1, 1)―――< Làm trưởng >―――(0, 1)――| TrạmYTế |
				    |			  |			  |
				 (M̲ã̲B̲S̲)		(NgàyNhậmChức)		   (M̲ã̲T̲Y̲T̲)
				

				BacSi (M̲a̲B̲S̲, HoTen)
					^
					|
					-------------------
							  |
				TramYTe (M̲a̲T̲Y̲T̲, TenTYT, #MaBS, NgayNhamChuc)


		- 1-n: Lấy khoá chính của bên ít "xuất ngoại" sang bên nhiều.
			+ Những thuộc tính riêng (nếu có) của mối kết hợp cũng sẽ thuộc về bên nhiều.

			Ví dụ: Mối kết hợp giữa KháchHàng và ĐơnHàng.

				  (HọTên)					(NgàyĐặt)
				     |		   1			 n	    |
				| KháchHàng |―――(1, 1)―――――< Có >―――――(0, n)―――| ĐơnHàng |
				     |						    |
				  (M̲ã̲K̲H̲)					     (M̲ã̲Đ̲H̲)
				

				KhachHang (M̲a̲K̲H̲, HoTen)
					    ^
					    |
					    ---------------
							  |
				DonHang (M̲a̲D̲H̲, NgayDat, #MaKH)


		- n-n: Mối kết hợp được chuyển thành một bảng trung gian.
			+ Tên của bảng có thể là tên của mối kết hợp hoặc tên ghép của hai bảng.
			+ Khoá định danh của từng thực thể sẽ hợp lại (khoá đôi/cặp), cùng làm khoá chính cho bảng mới và cũng đồng thời làm khoá ngoại.
			+ Nhưng thuộc tính riêng (nếu có) của mối kết hợp sẽ trở thành cột trong bảng mới.

			Ví dụ: Mối kết hợp giữa SinhViên và MônHọc.

				  (HọTên)					(TênMH)
				     |		  n			 n	   |
				| SinhViên |―――(0, n)―――――< Học >―――――(0, n)―――| MônHọc |
				     |						   |
				  (M̲ã̲S̲V̲)					     (M̲ã̲M̲H̲)
				

				SinhVien (M̲a̲S̲V̲, HoTen)
					    ^
					    |
				       ------
				       |
				Hoc (#M̲a̲S̲V̲,̲ ̲#M̲a̲M̲H̲)
					      |
					 ------
					 |
					 v
				MonHoc (M̲a̲M̲H̲, TenMH)


	* Ba ngôi:

		* Mối kết hợp -> Bảng riêng
			- Không còn quan tâm đến trọng số của từng mối kết hợp.
			- Tất cả thuộc tính định danh của các thực thể có liên quan sẽ cùng hợp lại để làm khoá chính cho bảng mới, đồng thời cũng là khoá ngoại.
			- Sẽ dễ gây thiếu nhất quán trong dữ liệu khi có những sự kết hợp không hợp lệ giữa các thực thể.
				1. Tách các mối kết hợp ba ngôi thành hai ngôi.
				2. Đính kèm danh sách các ràng buộc toàn vẹn cho công đoạn thiết kế mô hình vật lý.

		Ví dụ: Mối kết hợp giữa NhàCungỨng, MặtHàng và CửaHàng.

					   (HìnhThứcVC)	  (GiáThành)
						    |	    |
						    |	    |
			| NhàCungỨng |―――(1, n)――――< CungCấp >――――(1, n)―――| CửaHàng |
							│
							│
						      (1, n)
							│
						    | MặtHàng |


			NhaCungUng (M̲a̲N̲C̲U̲)
					^
					|
					-----------
						  |
			Cua Hang (M̲a̲C̲H̲)	      |
				    ^		  |
				    |		  |
				    -------	  |
					  |	  |
			MatHang (M̲a̲M̲H̲)    |	      |
				   ^	  |	  |
				   |	  |	  |
				   |	  |	  |
			CungCap (#M̲a̲M̲H̲,̲ ̲#M̲a̲C̲H̲,̲ ̲#M̲a̲N̲C̲U̲, HinhThucVC, GiaThanh)

------------------------------------------------------------

Bước 4: Chuyển thực thể kết hợp (Associative Entity).

	* Thực thể kết hợp -> Bảng riêng

	* Khoá
		- Nếu thực thể kết hợp không có sẵn khoá định danh thì lấy khoá định danh của từng thực thể hợp lại, cùng làm khoá chính cho bảng mới và cũng đồng thời làm khoá ngoại.
		- Nếu thực thể kết hợp đã có sẵn khoá định danh thì chuyển thành khoá chính và lấy 2 khoá định danh của hai thực thể thông thường làm khoá ngoại.

	Ví dụ: Thực thể kết hợp ChứngChỉ.

		  (HọTên)					  (TênKH)
		     |		     n		      n		     |
		| NhânViên |――――――――――| < ChứngChỉ > |――――――――――| KhoáHọc |
		     |			 |	  |		     |			
		  (M̲ã̲N̲V̲)	    (M̲ã̲C̲h̲ứ̲n̲g̲C̲h̲ỉ̲)    (NgàyHoànThành)	(M̲ã̲K̲H̲)


		NhanVien (M̲a̲N̲V̲, HoTen)
			   ^
			   |
			   ------------------------------
							|
		ChungChi (M̲a̲C̲h̲u̲n̲g̲C̲h̲i̲, NgayHoanThanh, #MaNV, #MaKH)
								|
			  ---------------------------------------
			  |
			  v
		KhoaHoc (M̲a̲K̲H̲, HoTen)

------------------------------------------------------------

Bước 5: Chuyển thực thể Cha-Con.

	- Bao gồm 3 phong cách khác nhau:

		1. Cha-Con tách biệt:

			* Thực thể Cha -> Bảng Cha
				* Thuộc tính chung của Cha -> Cột của Cha

			* Thực thể Con -> Bảng Con
				* Thuộc tính riêng của Con -> Cột Con
				* Khoá định danh Cha -> Khoá chính + Khoá ngoại Con

		2. Chỉ Con tồn tại:
			- Loại bỏ thực thể Cha, chuyển tất cả các thực thể Con thành các bảng.
			- Mỗi Con sẽ có đầy đủ thuộc tính như Cha + thuộc tính riêng của mình.

		3. Chỉ Cha tồn tại:
			- Loại bỏ thực thể Con, chuyển thực thể Con thành một bảng.
			- Các thuộc tính của Cha sẽ bao gồm cả các thuộc tính riêng của Con + thuộc tính bổ sung để xác định Con nào đang được đề cập.

		Ví dụ: Các chức danh công việc trong một công ty CNTT (bằng phong cách 1).
		
			| LậpTrìnhViên |―――――――――――――――――――∈―――――\
			| ChuyênViênPhânTíchNghiệpVụ |―――――∈―――――〇―――――| NhânViên |
			| KiểmThửViên |――――――――――――――――――――∈―――――/


			NhanVien (M̲a̲N̲V̲, HoTen)

			LapTrinhVien(#M̲a̲N̲V̲, SoTinhNangVietDuoc)

			ChuyenVienPhanTichNghiepVu(#M̲a̲N̲V̲, SoSoDoHeThongDaVe)

			KiemThuVien(#M̲a̲N̲V̲, SoLoiTimDuoc)

--------------------------------------------------------------------------------

Có thể dữ liệu sẽ nằm rải rác trong bảng (Table) để phục vụ cho những triết lý thiết kế. Vì vậy, ta phải sử dụng thêm nhiều kỹ thuật khác nhau để lắp ráp lại thành đúng dữ liệu cần dùng bằng câu lệnh JOIN.

* Tính bất thường của dữ liệu (Anomaly): Thông tin bị lặp lại quá nhiều khi gộp thành một bảng duy nhất và bị phân mảnh khi được tách thành nhiều bảng khác nhau.

	- Giúp dữ liệu tránh bị lặp lại nhiều đến mức không cần thiết. Nhưng trước khi đi, vẫn để lại một "mảnh hồi ức" để sau này có thay đổi ở nơi khác thì nơi này vẫn được thay đổi theo, giúp tăng tính nhất quản của dữ liệu và tránh việc phải nhập lại quá nhiều thông tin.

		Ví dụ: Dữ liệu về sinh viên có thể được tách ra thành nhiều bảng
			- Bảng: Thông tin sinh viên
			- Bảng: Thông tin chuyên ngành học
			- Bảng: Thông tin CLB tham gia
			- ...
			-> Nếu một thông tin trong bảng bị thay đổi thì những bảng có liên quan sẽ thay đổi theo.

	- Một số cột thường sẽ được tách ra làm nhiều cột nhỏ để phục vụ cho việc lưu trữ và sắp xếp.

		Ví dụ: họ và tên sẽ được tách làm hai cột với mục đích.
			- Phù hợp với việc lưu trữ tên của người Việt và người nước ngoài.
			- In ra theo phong cách / quy ước riêng của mỗi quốc gia.

	- Khi dữ liệu được tách ra thành nhiều bảng khác nhau, giữa các bảng sẽ liên kết với nhau bằng khái niệm "Mối quan hệ (Relationship)" hay "Tham chiếu (Reference)".

	* Insertion Anomaly in Referencing Relation: Thêm vào bên nhận (Referencing) những dữ liệu mà bên cho (Referenced) không hề có.

	* Deletion/ Updation Anomaly in Referenced Relation: Không thể xoá hoặc chỉnh sửa những dữ liệu ở bên cho (Referenced), nếu bên nhận (Referencing) đang sử dụng nó, nhưng nếu bên nhận (Referencing) đang không sử dụng thì có thể xoá hoặc cập nhật bình thường.
		- On Delete Cascade:
		- On Update Cascade:


Việc đặt toàn bộ dữ liệu trong cùng một bảng duy trong CSDL sẽ gây nên nhiều hệ luỵ.

Nghệ thuật thiết kế CSDL.
	1. Tìm ra số bảng cần phải tạo (tách bảng).
	2. Tìm ra mối quan hệ / liên kết giữa các bảng.
	-> Đích đến cuối cùng: Có được CSDL để bắt đầu khai thác dữ liệu.

	-> Chuẩn hoá CSDL (Normalization): Kỹ thuật tách bảng làm sao cho thật khéo.

--------------------------------------------------------------------------------

Có thể thấy, bảng sẽ là nơi lưu trữ những dữ liệu có cùng cấu trúc, giúp tạo nên sự nhất quán.

Nhưng với sự phong phú của dữ liệu, NoSQL ra đời.

	- Là một mô hình không dựa trên khái niệm bảng.

	- Là dạng cơ sở dữ liệu mà các dữ liệu bên trong không nhất thiết phải có cùng cấu trúc, số cột có thể thay đổi.

==========================================================================================

[THIẾT KẾ - MỨC VẬT LÝ]

* Những khái niệm tương đương khi chuyển từ mô hình luận lý sang vật lý:

	- Bảng ở mức ý niệm (Schema): Là những ngăn tủ rỗng, chưa có bất kì món đồ nào bên trong.
		- Giống như một bản phác thảo để cho biết hình dáng thật sự của chiếc tủ sẽ ra sao.
		- Được phác thảo thiết kế sơ khởi bằng ERD, sau đó tiếp tục được chuyển thành RS để gần hơn với mức vật lý.

	- Bảng đầy đủ (Table / Relation): Tủ đựng đồ với nhiều ngăn chứa và đồ đạc (dữ liệu) bên trong.

	- Cơ sở dữ liệu (Database): Căn phòng lớn để chứa bên trong nhiều tủ đựng đồ.

	- Dòng (Row): Những món đồ, phụ kiện, quần áo... sau khi mua về sẽ được lập tức cất vào trong tủ.

==========================================================================================
==========================================================================================
==========================================================================================

[NHỮNG LƯU Ý]

Mặc định, các câu lệnh sẽ chạy theo thứ tự từ trên xuống dưới. Vì vậy, để chỉ định một câu lệnh hoặc một nhóm câu lệnh cần thực thi, ta có thể quét chọn (bôi đen) câu lệnh hoặc một nhóm câu lệnh đó.

Phím tắt để thực thi câu lệnh trong SQL Server là [F5].

Đối với collation mặc định, SQL Server sẽ không phân biệt hoa thường. Nhưng những từ khoá, hàm() sẽ được quy ước nên được viết in hoa toàn bộ.

	- Vì mục đích của cơ sở dữ liệu là để lưu trữ và cho phép tìm được càng nhiều dữ liệu càng tốt, việc phân biệt hoa thường sẽ gây cản trở trong việc tìm kiếm.

	- Vì hàm có trả về giá trị nên ta hoàn toàn có thể đem đi sử dụng và lồng bên trong những câu lệnh khác.

==========================================================================================

[CÂU LỆNH ĐỂ LẤY DỮ LIỆU RA: SELECT - SELECT STATEMENT]

Có rất nhiều câu lệnh (statement) để tương tác với cơ sở dữ liệu và lấy dữ liệu ra.

Một trong những câu lệnh đầu tiên là SELECT với công dụng.

	1. Lấy dữ liệu lên, tính toán và in ra màn hình (giống như những câu lệnh in ra màn hình của các ngôn ngữ lập trình: printf(), cin, System.out.println(), echo...).

	2. In ra dữ liệu đang có trong bảng (dưới dạng hàng và cột).

	-> Luôn hiển thị dữ liệu ra dưới dạng bảng (gồm hàng và cột).

	* Phép chiếu (Projection): Trả về nguyên một cột với nhiều dòng hoặc nhiều cột (sử dụng đèn pin để rọi).

* Cú pháp chuẩn: In toàn bộ dữ liệu trong một bảng.
	SELECT *
	FROM [Tên bảng]

	-- Dấu * sẽ cho biết việc muốn lấy tất cả các cột trong bảng
	-- Mệnh đề FROM sẽ cho biết tên của bảng cần lấy dữ liệu

		Ví dụ: Lấy tất cả các cột trong bảng nhân viên.

			SELECT *
			FROM Employees

* Cú pháp mở rộng: In một vài cột trong bảng.

	-- Liệt kê một số cột nhất định cần lấy từ một bảng,
	-- những cột không sử dụng đến sẽ được ẩn đi
	SELECT [Tên các cột, cách nhau bởi dấu phẩy]
	FROM [Tên bảng]
	
	-- Mẹo: Nhập tên bảng trước để nhận được gợi ý khi nhập tên cột

		Ví dụ: Lấy một số cột trong bảng nhân viên.

			SELECT EmployeeID, LastName, FirstName, Title, BirthDate
			FROM Employees

* Cú pháp mở rộng: Sử dụng thêm hàm và phép toán để xử lý các cột.

		Ví dụ: Xử lý các cột trong bảng nhân viên.

			-- Sử dụng phép toán cộng
			-- để ghép cột họ và tên thành cột tên đầy đủ,
			-- sau đó đặt tên giả cho cột mới này
			SELECT EmployeeID, LastName + ' ' + FirstName AS [Full name]
			FROM Employees
		
			-- Sử dụng hàm
			-- để tính toán tuổi dựa theo cột ngày sinh,
			-- sau đó đặt tên giả cho cột mới này
			SELECT YEAR(GETDATE()) - YEAR(BirthDate) AS Age
			FROM Employees

* Cú pháp mở rộng: Loại bỏ những dữ liệu bị trùng.

	-- Dữ liệu từ cột trong bảng có nguy cơ bị trùng lặp (trùng 100%),
	-- nhưng đây hoàn toàn không phải là sai sót trong việc nhập liệu hay thiết kế,
	-- mà chỉ đơn giản là vì có quá nhiều thông tin / đặc điểm trùng nhau
	-- và ta lại đang tập trung vào dữ liệu đó
	SELECT DISTINCT [Tên các cột, cách nhau bởi dấu phẩy]
	FROM [Tên bảng]

	-- Càng nhiều cột được chọn thì càng khó trùng

	-- * Lưu ý 1: Nếu từ khoá DISTINCT đi kèm với khoá chính
	--	      thì sẽ trở nên vô nghĩa, vì khoá chính đã cấm trùng nhau
	--	      (hoặc bộ lọc WHERE đi kèm với DISTINCT cũng sẽ vô nghĩa)

	-- * Lưu ý 2: Không thể sử dụng DISTINCT trên những cột
	--	      có kiểu dữ liệu nhị phân (Binary text) - Hexa,
	--	      vì việc so sánh giữa hai tập tin nhị phân là vô nghĩa

		Ví dụ 1: Toàn bộ người dân Việt Nam đều sẽ thuộc 63 Tỉnh và Thành phố.
			- Mặc dù có hơn 100tr dòng dữ liệu, nhưng cuối cùng chỉ có 63 giá trị là khác nhau.

		Ví dụ 2: Loại bỏ dữ liệu bị trùng trong bảng nhân viên.
		
			-- Sử dụng từ khoá DISTINCT
			-- để loại bỏ những giá trị trùng nhau trong cột tên quốc gia
			SELECT DISTINCT Country FROM Customers

* Cú pháp mở rộng: Sắp xếp dữ liệu theo một tiêu chí nào đó.

	-- Sắp xếp dữ liệu theo cách thức / tiêu chí:
	--	1. Tăng dần (Ascending - ASC)
	--	2. Giảm dần (Descending - DESC)
	-- (Mặc định sẽ sắp xếp tăng dần)
	SELECT [Tên các cột, cách nhau bởi dấu phẩy]
	FROM [Tên bảng]
	ORDER BY [Tên cột muốn sắp xếp] [Kiểu sắp xếp: tăng hoặc giảm dần]

	-- Ta có thể sắp xếp trên nhiều cột khác nhau

		Ví dụ: Sắp xếp khách hàng theo thứ tự quốc gia giảm dần (theo bảng chữ cái).
			SELECT * FROM Customers
			WHERE Country = 'Italy' OR Country = 'USA'
			ORDER BY Country DESC

* Cú pháp mở rộng: Lọc dữ liệu theo điều kiện.

	-- Mệnh đề WHERE được sử dụng để làm bộ lọc (filter),
	-- giúp lựa ra dữ liệu theo một tiêu chí nào đó
	-- (Càng nhiều bộ lọc thì sẽ càng có ít dữ liệu được hiển thị ra.)

	-- Tìm theo từng dòng, với cột chứa giá trị cần lọc,
	-- kiểm tra xem giá trị trong ô đó có thoả với điều kiện lọc hay không
	-- (Kiểm tra theo cột và so sánh giá trị được chứa trong cột,
	--  sau đó lấy dòng ra theo tiêu chí / giá trị của cột.)
	SELECT [Tên các cột, cách nhau bởi dấu phẩy]
	FROM [Tên bảng]
	WHERE [Điều kiện lọc
		1. Tên cột
		2. Giá trị của cột
		3. Toán tử so sánh
		4. Toán tử luận lý]

	-- * Lưu ý 1: Vì bộ lọc liên quan đến giá trị được chứa bên trong một ô,
	--	      nên ta phải quan tâm đến kiểu dữ liệu
	--		- Số (Numeric): số nguyên và thực, chỉ cần ghi con số (ví dụ: 1, 2, 3.14, 9.8...)
	--		- Kí tự / Chuỗi (String): 'A', 'Ahihi'...
	--		- Ngày / Giờ (Date/Time): '2002-01-10'

	-- * Lưu ý 2: Nếu có sử dụng thêm mệnh đề ORDER BY thì phải để sau WHERE
	--	      và mặc định sẽ được sắp xếp tăng dần (ASC)

		Ví dụ 1:
			- Lọc ra toàn bộ những sinh viên có quê quán ở TP.HCM.
			- Lọc ra toàn bộ những sinh viên có quê quán ở TP.HCM và điểm trung bình >= 8.

		Ví dụ 2:
			-- Mệnh đề WHERE kết hợp với toán tử luận lý
			SELECT * FROM Customers
			WHERE Country = 'Italy' OR Country = 'USA'
			
			-- Mệnh đề WHERE kết hợp với toán tử luận lý và toán tử so sánh
			SELECT * FROM Students
			WHERE City = N'Hồ Chí Minh' AND GPA >= 8
			
			-- Mệnh đề WHERE kết hợp với hàm để tính toán
			SELECT * FROM Employees
			WHERE YEAR(BirthDate) >= 2010 OR YEAR(BirthDate) >= 2020

* Cú pháp mở rộng: Lấy dữ liệu trong một đoạn / khoảng nhưng không sử dụng WHERE.

	-- Để lọc dữ liệu trong một đoạn / khoảng / tập giá trị cho trước,
	-- thay vì sử dụng mệnh đề WHERE kết hợp với các toán tử ">= ... AND <= ...",
	-- ta có thể sử dụng toán tử BETWEEN và AND
	-- (Giá trị nằm trong khoảng giữa hai giá trị.)
	BETWEEN [Giá trị 1] AND [Giá trị 2]

	-- Khi có một tập hợp các giá trị / mệnh đề đơn lẻ, rời rạc
	-- và được kết nối với nhau bằng toán tử OR
	-- (giống như việc sử dụng mệnh đề Switch-Case),
	-- ta có thể thay thế bằng toán tử IN
	-- (Giá trị rơi vào một trong những giá trị đã được liệt kê.)
	IN (Danh sách các giá trị, cách nhau bởi dấu phẩy)

	-- * Lưu ý: Chỉ sử dụng được toán tử IN khi có thể liệt kê được tập giá trị
	--	    và sau đó so sánh bằng chính xác một giá trị nào đó,
	--	    còn những khoảng số thực sẽ không thể liệt kê được
	--	    vì giữa hai số thực sẽ có vô vàn những số thực khác,
	--	    mặc dù đối với BETWEEN và AND
	--	    thì vẫn có thể sử dụng khoảng số thực bình thường

		Ví dụ: Chỉ lấy những đơn hàng được giao đến 1 trong 3 quốc gia được liệt kê.
			SELECT * FROM Orders
			WHERE ShipCountry IN ('UK', 'France', 'USA')
			ORDER BY ShipCountry

* Cú pháp mở rộng: Kiểu dữ liệu và trạng thái NULL.

	-- Trong thực tế, sẽ có những lúc mà ta không thể
	-- xác định được giá trị / thông tin của dữ liệu
	-- Vì dữ liệu đa chưa xác định nên ta không thể sử dụng toán tử so sánh,
	-- mà chỉ có thể sử dụng toán tử:
	IS NULL
	IS NOT NULL
	NOT (Tên bảng IS NULL)

	-- * Lưu ý: NULL ở đây là một trạng thái (với ô được tô màu vàng),
	--	    chứ không phải là một chuỗi 'NULL'

		Ví dụ: Lọc ra những nhân viên có quốc gia khác NULL.
			SELECT * FROM Employees
			WHERE Region IS NOT NULL
			
			SELECT * FROM Employees
			WHERE NOT (Region IS NULL)

* Cú pháp mở rộng: Toán tử, phép toán so sánh gần đúng / có sự xuất hiện.

	-- Đôi lúc, ta sẽ chỉ muốn lọc / tìm kiếm dữ liệu ở mức gần đúng (kiểu chuỗi)
	-- Để sử dụng được toán tử LIKE, ta cần sử dụng thêm:
	--	1. Dấu _: Đại diện cho một kí tự bất kì.
	--	2. Dấu %: Đại diện cho một chuỗi bất kì.
	LIKE

	-- * Lưu ý: Không được phép sử dụng toán tử so sánh bằng ('=')
	--	    khi muốn so sánh gần đúng,
	--	    vì so sánh bằng nghĩa là phải đi so trùng 100%

		Ví dụ 1:
			Liệt kê ai đó có tên [CHÍNH XÁC] là Anh
				≠
			Liệt kê ai đó có tên [GẦN ĐÚNG / CÓ SỰ XUẤT HIỆN] là An

		Ví dụ 2:
			-- Bất kì ai có tên bắt đầu bằng chữ 'A',
			-- phần còn lại (một kí tự hoặc một chuỗi) không quan tâm
			SELECT * FROM Employees
			FirstName LIKE N'A%' ≈ An, Anh...

			-- Bất kì ai trong tên chỉ có hai chữ cái
			-- và bắt đầu bằng chữ 'A'
			SELECT * FROM Employees
			FirstName LIKE N'A_' ≈ An, Ân, Ái...

* Cú pháp mở rộng: Cú pháp tạm đầy đủ của SELECT.

	SELECT [Tên các cột, cách nhau bởi dấu phẩy]
		DISTINCT
		Hàm()
		Nested Query / Sub-Query: Câu truy vấn lồng nhau

	FROM [Tên bảng]
		Một bảng
		Nhiều bảng

	WHERE [Điều kiện lọc]

	GROUP BY

	HAVING

	ORDER BY [Tên cột muốn sắp xếp] [Kiểu sắp xếp: tăng hoặc giảm dần]

------------------------------------------------------------

Dù sử dụng cho mục đích nào thì kết quả hiển thị ra luôn dưới dạng bảng (gồm hàng và cột).

	Ví dụ 1: Công dụng 1 - Lấy dữ liệu lên, tính toán và in ra màn hình

		-- Hàm lấy ngày-giờ hiện tại của hệ thống (theo đồng hồ của máy tính cục bộ)
		-- sẽ luôn trả về thông tin dưới dạng bảng dù chỉ trả về một kết quả duy nhất
		SELECT GETDATE()

		-- Nhưng kết quả trả về dưới dạng bảng sẽ không có tên cột
		-- Vì vậy, ta có thể đặt tên giả cho bảng bằng câu lệnh AS
		SELECT GETDATE() AS [Hôm nay là ngày] -- Có khoảng trắng

		SELECT GETDATE() AS HômNayLàNgày -- Không có khoảng trắng


		-- Vì hàm có trả về giá trị nên ta hoàn toàn có thể
		-- đem giá trị sang một nơi khác để tiếp tục sử dụng
		-- (Hàm gọi hàm / Hàm lồng trong hàm)
		SELECT MONTH(GETDATE()) AS [Bây giờ tháng mấy?]

	Ví dụ 2: Công dụng 1 - Lấy dữ liệu lên, tính toán và in ra màn hình

		-- Sử dụng hàm lấy giá trị tuyệt đối của một số
		SELECT ABS(-5) AS [Trị tuyệt đối của (-5) là]

		-- Tính toán một phép tính và in ra kết quả
		SELECT 5 + 5 [Kết quả của 5 + 5 là]

		-- Hàm gọi hàm để tính toán
		SELECT YEAR(GETDATE()) - 2000 AS [My age is]

	Ví dụ 3: Công dụng 1 - Lấy dữ liệu lên, tính toán và in ra màn hình

		-- In ra một chuỗi, nhưng sẽ không hiểu được Unicode
		-- Vì vậy, phải sử dụng thêm N để in ra tiếng Việt có dấu
		SELECT N'Cơ sở dữ liệu'

		-- Nhưng để in ra thành công,
		-- toàn bộ các câu lệnh phải có cùng một kiểu dữ liệu
		SELECT N'Nguyễn Hoàng Thuận - ' + CONVERT(varchar, YEAR(GETDATE()) - 2000) + ' years old'
		AS [My full info is]

----------------------------------------

	Ví dụ 1: Công dụng 2 - In ra dữ liệu đang có trong bảng (dưới dạng hàng và cột)

--------------------------------------------------------------------------------

* Lưu ý: mặc dù có xử lý và tính toán, nhưng câu lệnh SELECT sẽ không làm ảnh hướng / thay đổi dữ liệu gốc trong cơ sở dữ liệu, mà chỉ đơn giản là hiển thị ra kết quả xử lý, cho dù có thực hiện bao nhiêu lần đi chăng nữa. Chỉ những câu lệnh như INSERT, UPDATE hoặc DELETE mới thay đổi dữ liệu gốc.

==========================================================================================

[CÁC CÂU TRUY VẤN LỒNG NHAU - NESTED QUERY / SUB-QUERY]

	* Tập hợp (Set): Không được phép trùng.
	* Danh sách (List): Được phép trùng.

Có rất nhiều cách khác nhau, và đây là một trong những cách đơn giản nhất.

Trong một câu SQL có chứa / lồng bên trong một câu SQL khác, mà cụ thể ở đây là ở bên trong mệnh đề WHERE. Kỹ thuật này được gọi là "Đặt câu hỏi gián tiếp" hoặc "So sánh tương quan".
	-> Kỹ thuật viết truy vấn theo kiểu hỏi gián tiếp.

Trong mệnh đề WHERE của câu lệnh SELECT, "bộ lọc" có thể là:

	1. WHERE [Tên cột] (Toán-tử-so-sánh: =, >, <...) Giá-trị
		-> Có thể thay thế phần "Giá-trị" bằng một câu SQL khác, miễn vẫn trả về duy nhất một ô chứa duy nhất giá trị.

	2. WHERE [Tên cột] LIKE '_ % _'
	3. WHERE [Tên cột] BETWEEN ... AND ...

	4. WHERE [Tên cột] IN (Một tập hợp các giá trị được liệt kê)
		-> Có thể thay thế phần "(Một tập hợp các giá trị được liệt kê)" bằng một câu SQL khác, miễn vẫn trả về một tập hợp gồm nhiều giá trị cùng kiểu của cùng một cột.

	5. WHERE [Tên cột] (Toán-tử-so-sánh: =, >, <...)
				ALL (Một câu truy vấn lồng trả về một cột nhiều giá trị)
				ANY (Một câu truy vấn lồng trả về một cột nhiều giá trị)

--------------------------------------------------------------------------------

- Câu truy vấn phụ / truy vấn lồng ở bên trong phải được thực thi thành công và trả về giá trị, thì câu truy vấn bên ngoài mới có thể thực thi tiếp được.

- Câu truy vấn bên ngoài có thể đón giá trị trả về từ câu truy vấn phụ / truy vấn lồng bằng các toán tử so sánh (=, >, <, IN...), miễn là có cùng kiểu dữ liệu trả về-nhận vào.

* Tuỳ vào cách viết mà một câu lệnh SELECT có thể:

------------------------------------------------------------

1. Trả về duy nhất một giá trị.

	- Một giá trị duy nhất, nằm trong một ô duy nhất, thuộc một cột duy nhất (không phải một dòng với nhiều ô / cột).

		Ví dụ: Sử dụng bộ lọc lên cột làm khoá chính và chỉ in ra duy nhất một giá trị trong một ô / cột.
			SELECT FirstName FROM Employees WHERE EmployeeID = 1

	- Vì kết quả cuối cùng là trả về duy nhất một giá trị (được chứa trong một ô), nên câu truy vấn này lại có thể tiếp tục tham gia / được lồng vào trong một câu truy vấn khác.

		Ví dụ: Liệt kê những ai cùng quê với King Robert
		
			---- * Câu hỏi trực tiếp: Quê quán của King Robert
			
			-- Lấy được ra chính xác King Robert
			SELECT * FROM Employees WHERE FirstName = 'Robert'
			
			-- Trả về duy nhất một ô chứa giá trị
			-- là thành phố - nơi King Robert đang sống
			SELECT City FROM Employees WHERE FirstName = 'Robert'
			
			---- * Câu hỏi gián tiếp: Những nhân viên cùng quê với King Robert
			SELECT * FROM Employees

			-- Lấy câu truy vấn trả về giá trị là một ô chứa thành phố
			-- gán vào nơi nhận giá trị đầu vào là một thành phố
					-- ≈ WHERE City = 'London'
			WHERE City = (
					SELECT City FROM Employees
					WHERE FirstName = 'Robert'
				     )

			 -- Loại King Robert ra khỏi kết quả tìm kiếm,
			 -- vì đang chỉ cần tìm người có cùng quê quán với King Robert			 
			 AND FirstName != 'Robert'

------------------------------------------------------------

2. Trả về một tập hợp các giá trị.

	- Tập hợp các kết quả đồng nhất (các giá trị khác nhau của cùng một biến / thuộc tính).

		Ví dụ: In ra một tập hợp các giá trị cùng kiểu của cùng một cột.
			SELECT FirstName FROM Employees

	- Được gọi là tập hợp vì các giá trị (dòng) bên trong đều có cùng một kiểu và thuộc cùng một cột.

		Ví dụ: Liệt kê những đơn hàng do những nhân viên có quê ở Luân Đôn phụ trách.
		
			---- * Câu hỏi trực tiếp: Danh sách các nhân viên có quê ở Luân Đôn
			
			-- Lấy được ra danh sách những nhân viên có quê ở Luân Đôn
			SELECT * FROM Employees WHERE City = 'London'
			
			-- Trả về danh sách những giá trị của cùng một cột
			-- là mã nhân viên của những nhân viên có quê là Luân Đôn
			SELECT EmployeeID FROM Employees WHERE City = 'London'
			
			---- * Câu hỏi gián tiếp: Những đơn hàng do những nhân viên quê ở Luân Đôn phụ trách
			SELECT * FROM Orders

			-- Lấy câu truy vấn trả về giá trị là danh sách mã nhân viên
			-- gán vào nơi nhận giá trị đầu vào là một tập hợp mã nhân viên
					-- ≈ EmployeeID IN (5, 6, 7, 9)
			WHERE EmployeeID IN (
						SELECT EmployeeID FROM Employees
						WHERE City = 'London'
					    )

------------------------------------------------------------

ALL và ANY

* ALL: Kiểm tra từng dòng và đảm bảo phải thoả mãn hết tất cả các giá trị trong tập hợp.

Tìm số lớn / bé nhất trong một tập hợp:
	- Lớn / Bé hơn tất cả các số còn lại.
	- Bằng chính mình.
	- Thường sẽ chỉ trả về một kết quả, nhưng nếu có nhiều giá trị cùng lớn / bé thì sẽ có nhiều kết quả cùng được trả về.
	-> Lớn / Bé hơn tất cả, ngoại trừ chính mình.

	Ví dụ: Tìm số lớn nhất bằng toán tử ALL.

		-- Tập hợp các số nguyên tố
		SELECT * FROM Num

		-- Tìm số lớn nhất trong tập hợp
		-- bằng cách lấy từng dòng giá trị ra và đi so sánh
		-- để tìm ra xem giá trị nào
		-- lớn hơn tất cả và bằng chính mình.
							-- Danh sách dãy các số nguyên tố
		SELECT * FROM Num WHERE Numbr >= ALL (
							SELECT * FROM Num
						     )

==========================================================================================

[TOÁN TỬ KẾT TẬP / HÀM GOM NHÓM - AGGREGATE FUNCTION]

Là những phép toán / hình thức để gom / kết hợp (aggregation) dữ liệu.

Trong Database Engine, câu lệnh SELECT ngoài việc đảm nhận nhiệm vụ hiển thị, còn hỗ trợ một loạt các hàm với nhiệm vụ gom dữ liệu (theo một nhóm dòng / cột) và tính toán trên nhóm dữ liệu đã gom được.

Bao gồm những hàm:
	COUNT()
	SUM()
	MIN()
	MAX()
	AVG()

* Cú pháp chuẩn:
	SELECT [Tên các cột, cách nhau bởi dấu phẩy], HÀM GOM NHÓM()
	FROM [Tên bảng]
	WHERE...

* Cú pháp mở rộng: Sử dụng GROUP BY.
	SELECT [Tên các cột, cách nhau bởi dấu phẩy], HÀM GOM NHÓM()
	FROM [Tên bảng]
	WHERE...
	GROUP BY [Gom theo cụm cột nào]

* Cú pháp mở rộng: Sử dụng HAVING.
	SELECT [Tên các cột, cách nhau bởi dấu phẩy], HÀM GOM NHÓM()
	FROM [Tên bảng]
	WHERE...
	GROUP BY [Gom theo cụm cột nào]
	HAVING...

--------------------------------------------------------------------------------

[HÀM ĐẾM - COUNT()]

Được sử dụng để đếm số lần xuất hiện của một thứ gì đó trong một cột.

	- Thực hiện tính toán và đếm theo dạng cột (từ trên xuống dưới), thay vì dạng dòng (từ phải sang trái) như các phép toán thông thường.

	- Muốn hiển thị thứ gì thì gom nhóm (GROUP BY) theo thứ đó.

COUNT(*): Đếm số dòng đang có trong bảng (vì dấu * đại diện cho tất cả các cột), không quan tâm đến tiêu chuẩn nào khác.

	- Dù dòng đang đếm có chứa trạng thái NULL, nhưng miễn là có một ô trong cột nào đó khác NULL, thì cũng được tính là một dòng.

	- Nếu toàn bộ giá trị trong dòng đều NULL thì sẽ không được tính là một dòng.

COUNT(*) FROM... WHERE...: Chọn ra những dòng thoả tiêu chí của bộ lọc WHERE trước rồi mới bắt đầu đếm (lọc rồi mới đếm).

COUNT [Tên cột nào đó]: Đếm trong phạm vi của một cột.

	- Nếu ô nào đó của cột mà chứa trạng thái NULL thì sẽ không được tính, vì đang đếm dựa trên sự xuất hiện của giá trị và NULL lại không được xem là sự xuất hiện.

	- Nếu muốn đếm ô chứa trạng thái NULL, ta có thể sử dụng cú pháp COUNT(*) để lấy ra được cả dòng và sau đó kết hợp với WHERE để lọc ra đúng dòng cần đếm, vì NULL là thứ không thể đếm được.
		-> Đếm sự xuất hiện của dòng thay vì trực tiếp đếm NULL.

----------------------------------------

Nếu trong câu hỏi có chứa từ khoá "mỗi (each)" thì cách viết phải có sư thay đổi.
	-> Chia để trị (chia cụm để gom và đếm).

	- Có nhiệm vụ gom những thứ giống nhau của một cột vào cùng một nhóm, sau đó cho phép sử dụng hàm COUNT() để đếm số lượng của mỗi nhóm vừa gom.

	- Lấy giá trị trong cột ra để chia nhóm, sau đó tính đếm hoặc tính toán trên dòng.

	- Mặc dù trạng thái NULL không phải là giá trị để có thể đếm hoặc tính toán, nhưng vẫn có thể chia nhóm được.

	- Ngoại trừ hàm COUNT(), trong câu lệnh SELECT có xuất hiện bất kì cột nào - nghĩa là sẽ thực hiện việc đếm trên cột này, thì trong mệnh đề GROUP BY cũng phải có những cột giống vậy. Điều này giúp đảm bảo tính hợp lý: gom và đếm theo số cột đang hiển thị, còn gom và đếm cột đang không hiển thị là vô nghĩa.

		Ví dụ: Đếm xem MỖI thành phố có bao nhiêu nhân viên.

			-- Gom những thành phố trùng nhau thành cùng một nhóm,
			-- Sau đó tiến hành đếm số nhân viên của mỗi nhóm
			SELECT Country, City, COUNT(City) AS [Number of employees]
			FROM Employees
			GROUP BY Country, City

	- Nếu gom nhóm theo cột khoá chính, thì việc này là vô nghĩa, vì khoá chính đã đảm bảo mỗi dòng là một nhóm riêng. Vì vậy, chỉ nên đếm trên những cột có khả năng đếm.

		Ví dụ:
			- "Mã số nhân viên" -> Không có gì để đếm
			- "Mã chuyên ngành" -> Đếm số sinh viên thuộc chuyên ngành
			- "Mã quốc gia" -> Đếm số đơn hàng của tỉnh
			- "Điểm thi" -> Đếm số lượng sinh viên đạt được điểm cao

* Cú pháp:
	GROUP BY [Tên các cột, cách nhau bởi dấu phẩy]

		Ví dụ: Đếm xem MỖI thành phố có bao nhiêu nhân viên.

			-- 1. Chia nhóm
			GROUP BY City

			-- 2. Đếm số lượng xuất hiện trong mỗi nhóm,
			--    tăng biến đếm và sau đó đặt lại cho mỗi nhóm
			SELECT City, COUNT(City) AS [Number of employees]
			FROM Employees
			GROUP BY City

----------------------------------------

Nếu trong quá trình đếm và gom nhóm lại phát sinh nhu cầu lọc dữ liệu (cần lọc dữ liệu đến hai lần).

	- Ta không thể trực tiếp sử dụng WHERE như thông thường, mà phải sử dụng HAVING.

	- Cũng là bộ lọc giống như WHERE, nhưng được đổi tên để tránh trị trùng, chỉ được sử dụng sau khi đã đếm và gom nhóm xong.

	- Vì là bộ lọc và có kết hợp với các toán tử so sánh, nên mệnh đề HAVING cũng được phép có những câu lệnh lồng bên trong.

		Ví dụ 1: Lọc ra những thành phố có từ hai nhân viên trở lên.

			-- Đếm số lượng nhân viên của mỗi thành phố
			SELECT Country, City, COUNT(City) AS [Number of employees]
			FROM Employees
			GROUP BY Country, City

			-- Bắt đầu lọc kết quả đếm
			SELECT Country, City, COUNT(City) AS [Number of employees]
			FROM Employees
			GROUP BY Country, City
			HAVING COUNT(City) >= 2

		Ví dụ 2: Thành phố nào có nhiều nhân viên nhất.

			-- Đếm số lượng nhân viên của mỗi thành phố
			SELECT Country, City, COUNT(City) AS [Total number of employees]
			FROM Employees
			GROUP BY Country, City

			-- Bắt đầu lọc kết quả đếm
			SELECT Country, City, COUNT(City) AS [Total number of employees]
			FROM Employees
			GROUP BY Country, City
			HAVING COUNT(City) >= ALL (
							SELECT COUNT(City)
							FROM Employees
							GROUP BY City
						  )

------------------------------------------------------------

[CÂU TRUY VẤN LỒNG TRONG MỆNH ĐỀ FROM]

Vì mệnh đề FROM nhận vào một bảng, nên miễn là câu truy vấn SELECT có trả về kết quả là một bảng, thì có thể được lồng vào bên trong FROM.

	- Mệnh đề FROM yêu cầu một tên bảng. Vì vậy, sau khi thay thế bằng một câu truy vấn (được xem là một biểu thức tính toán và kết quả trả về là một bảng, nhưng lại chưa có tên), ta phải đặt một tên giả bằng câu lệnh AS để có thể tham chiếu trong mệnh đề WHERE ở phía sau.

	Ví dụ: Đếm số lượng thành phố xuất hiện (không trùng) của bảng nhân viên.

		-- Câu lệnh trả về kết quả là một cột thành phố không trùng nhau
		SELECT DISTINCT City FROM Employees

		-- Đếm số lượng thành phố dựa trên một biểu thức đã được đặt tên giả
		SELECT COUNT(*)
		FROM (SELECT DISTINCT City FROM Employees) AS Cities

--------------------------------------------------------------------------------

[CÁC HÀM TÍNH TOÁN TRÊN SỐ - SUM() / MIN() / MAX() / AVG()]

Chỉ có thể sử dụng trên những số liệu có thể tính toán được. Cũng thực hiện tính toán theo dạng cột (từ trên xuống dưới).

	- Cách sử dụng tương tự COUNT() khi cũng tính toán các giá trị của một cột.

	- Về mặt hiệu năng, câu truy vấn lồng thường sẽ chạy chậm hơn, vì cơ bản thì đều là những câu lệnh độc lập, cần được tính toán trước và sau đó phối hợp với nhau. Vì vậy, nếu sử dụng những hàm có sẵn thì bộ lập lịch của Database Engine sẽ dễ dàng tính toán thuật toán để tối ưu và thay đổi giá trị khi đang hoàn toàn nằm trong một câu truy vấn.

* Tìm giá trị nhỏ nhất - MIN().

	Ví dụ: Tìm trọng lượng nhẹ nhất trong cột trọng lượng
		SELECT MIN(Freight) AS [Smallest freight]
		FROM Orders

* Tìm giá trị lớn nhất - MAX().

	Ví dụ: Tìm trọng lượng nặng nhất trong cột trọng lượng
		SELECT MAX(Freight) AS [Highest freight]
		FROM Orders

* Tính tổng - SUM().

	Ví dụ: Tính tổng trọng lượng trong cột trọng lượng
		SELECT SUM(Freight) AS [Freight in total]
		FROM Orders

* Tính trung bình cộng - AVG().

	Ví dụ: Tính trọng lượng trung bình trong cột trọng lượng
		SELECT AVG(Freight) AS [Freight in average]
		FROM Orders

==========================================================================================
==========================================================================================
==========================================================================================

[KẾT NỐI CÁC BẢNG - SQL JOIN]

Vì những kỹ thuật thiết kế mà dữ liệu sẽ được tách ra và nằm rải rác ở các bảng khác nhau. Vì vậy, ta cần sử dụng JOIN để có thể cùng một lúc tương tác trên những bảng có liên hệ với nhau.

	- Cần có một sự am hiểu nhất định về các bảng trước khi ghép.

	- Toàn bộ các dòng dữ liệu từ các bảng sẽ được gom về cùng một bảng (bảng tạm) trong RAM của Database Engine, hợp lại thành một bảng duy nhất và không làm ảnh hưởng đến những dữ liệu gốc trong mỗi bảng.

	- Các dữ liệu sẽ được ghép ngang thay vì ghép dọc.

		* Ghép ngang: Để các dòng của các bảng sát vào nhau (kè kè / kế bên / song song bên nhau) về bên trái hoặc phải.
			-> Thêm cột.

		* Ghép dọc: Dữ liệu sẽ được chèn vào đầu hoặc cuối bảng trong cùng một cột, giúp gia tăng thêm dữ liệu cho một bảng.
			-> Thêm dòng.

	- Việc sử dụng JOIN để ghép bảng chỉ khiến cho dữ liệu nhiều lên, chứ không làm thay đổi tư duy tính toán về SQL, nghĩa là ta có thể tận dụng lại toàn bộ kiến thức khi tương tác với một bảng.

	- Không ngại việc nhân bản thêm dữ liệu để ghép, miễn hợp nhau là được.

	- Việc quét chọn và thực thi hai câu lệnh SQL sẽ không được gọi là JOIN, vì đây mới chỉ là hai câu lệnh riêng biệt được thực thi cùng một lúc, nhưng sẽ cho ra hai tập kết quả riêng biệt nhau. Trong khi đó, JOIN là hợp tất cả về thành cùng một bảng.

	- Vì hai bảng khác nhau có quyền đặt tên cột trùng nhau, nên khi ghép lại sẽ có hiện tượng tên cột bị trùng và gây bối rối (ambiguous). Vì vậy, để tránh nhầm lẫn cũng như tránh bị trùng lặp, ta cần phải:

		+ Chỉ định cột thuộc bảng nào (tham chiếu cột qua tên bảng), giống như dấu chấm trong lập trình hướng đối tượng (OOP).
			Ví dụ: Ghép bảng bằng CROSS JOIN
				-- Sắp xếp theo cột Nmbr của bảng VnDict
				-- (tránh nhầm với cột Nmbr của bảng EnDict)
				SELECT * FROM VnDict, EnDict
				ORDER BY VnDict.Nmbr

		+ Đặt tên giả (Alias) cho bảng để tham chiếu cho các cột. Có thể đặt một tên giả vừa đủ ngắn, vì tên thật của bảng có thể rất dài và không tiện trong việc tham chiếu.
			Ví dụ: Ghép bảng bằng CROSS JOIN
				-- Có sử dụng AS
				SELECT vn.Nmbr, vn.VnDesc, en.EnDesc
				FROM VnDict AS vn, EnDict AS en
				ORDER BY vn.Nmbr
				
				-- Không sử dụng AS
				SELECT vn.Nmbr, vn.VnDesc, en.EnDesc
				FROM VnDict vn, EnDict en
				ORDER BY vn.Nmbr

	-> Tạm thời ghép các bảng sát nhau theo chiều ngang để tổng hợp dữ liệu.
		(Việc SELECT cùng lúc được nhiều bảng.)

* Cột chung (Common Column): Là cột gồm những dòng chứa bên trong những giá trị tương quan (hợp cạ / hợp rơ) nhau giữa hai bảng. Không quan trọng tên cột, chỉ quan tâm dữ liệu bên trong có sự tương đồng để có thể tiến hành ghép.

* Tiêu chuẩn ghép (Join condition): Điều kiện của cột để ghép nối.

--------------------------------------------------------------------------------

* Các kỹ thuật ghép bảng:

------------------------------------------------------------

1. Ghép xả láng - CROSS JOIN.

	- Ghép bừa bãi và vô tội vạ, hay còn được gọi với tên khác là tích Đềcác (Cartesian product) - các phép toán về tập hợp.

	- Số cột = tổng hai bên, số dòng = tích 2 bên (hai bên nhân với nhau).
		
	- Trước khi chuyển sang dòng mới, một dòng bên này sẽ phải ghép với tất cả các dòng ở bên kia.

	- Bùng nổ "dân số" kết quả.

		-> Nguyên team đi vào hết.

	* Cú pháp chuẩn:
		SELECT *
		FROM [Tên bảng 1] CROSS JOIN [Tên bảng 2]
		-- Không được phép sử dụng WHERE

	* Cú pháp thực dụng:
		SELECT *
		FROM [Tên bảng 1], [Tên bảng 2]
		-- Được phép sử dụng WHERE

		Ví dụ:
			-- Sử dụng cú pháp chuẩn và tường Minh
			SELECT *
			FROM VnDict CROSS JOIN EnDict
			ORDER BY VnDict.Nmbr

			-- Sử dụng cú pháp nhanh và ngầm định
			SELECT *
			FROM VnDict, EnDict
			ORDER BY VnDict.Nmbr

	- Trong các cặp được ghép vô tội vạ, sẽ có những cặp ghép đúng và những gặp ghép sai.
		
		+ Những cặp đúng, nếu kết hợp với mệnh đề WHERE để tìm điểm chung sẽ được gọi là INNER JOIN hoặc OUTER JOIN (đôi khi còn được gọi là EQUI JOIN).
			* EQUI JOIN: Ghép có mục đích với dấu =
			* NON-EQUI JOIN: Ghép có mục đích, nhưng với dấu >, >=, <, <=, !=

		+ Mặc dù được viết dưới dạng tích Đềcác, nhưng thuật toán của Database Engine sẽ tính toán lại để ghép nhằm giúp tăng tốc độ.

		Ví dụ: Tìm điểm chung giữa hai bảng.

			-- Sử dụng tích Đềcác kết hợp với mệnh đề WHERE
			SELECT *
			FROM VnDict vn, EnDict en
			WHERE vn.Nmbr = en.Nmbr

------------------------------------------------------------

2. Ghép môn đương hộ đối - INNER JOIN.

	- Ghép có chọn lọc, dựa trên điểm chung / cột chung (tương quan và hợp lý) để ghép. Trên cột chung, chỉ đi tìm và ghép những dòng có điểm chung, những dòng chứa giá trị khác biệt sẽ tự động bị loại.

	- Ngắm nhìn cấu trúc bên trong bảng một hồi lâu rồi mới bắt đầu ghép.

	- Ghép khi thoả tiêu chí / điều kiện và ghép bằng toán tử = hoặc >=, <=...

		-> Gió tầng nào gặp mây tầng đó.

	* Cú pháp chuẩn:
		-- Cách tường minh
		SELECT *
		FROM [Tên bảng 1] INNER JOIN [Tên bảng 2]
		ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
		WHERE...

		-- Cách ngầm định
		SELECT *
		FROM [Tên bảng 1] JOIN [Tên bảng 2]
		ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
		WHERE...

	* Cú pháp thực dụng:
		SELECT *
		FROM [Tên bảng 1], [Tên bảng 2]
		WHERE [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]

		Ví dụ: Từ điển Anh-Việt / Việt-Anh
			-- EQUI JOIN
			SELECT *
			FROM EnDict en INNER JOIN VnDict vn
			ON en.Nmbr = vn.Nmbr

			-- NON-EQUI JOIN
			SELECT *
			FROM EnDict en INNER JOIN VnDict vn
			ON en.Nmbr != vn.Nmbr

------------------------------------------------------------

3. Ghép dâng hiến - OUTER JOIN.

	- Cũng ghép có chọn lọc, nhưng ngoài phần chung thì còn cống hiến thêm phần riêng nếu đối phương không có.

	- Thường thấy trong hai cột giống nhau, nhưng lại có sự khác nhau đôi chút về dòng.

	- Tuỳ vào việc cột nào sẽ được lấy để làm chuẩn, mà cột còn lại sẽ được tự động gán trạng thái NULL.

	- Khi đã chấp nhận "ở bên nhau" nhưng lại không hoàn toàn "tìm được tiếng nói chung" thì "trời không chịu đất, đất phải chịu trời".

	- Thứ tự của các bảng được bố trí trong mệnh đề FROM và việc lấy vế bên nào làm mốc / làm chuẩn đều sẽ có ảnh hưởng đến kết quả (của LEFT / RIGHT OUTER JOIN).

	- Được sử dụng để phục vụ cho việc thống kê và đảm bảo việc ghép bảng sẽ không bị mất dữ liệu, trong khi INNER JOIN chỉ quan tâm đến duy nhất điểm chung của đôi bên.

	- Ngoài ra, cũng có kỹ thuật khác để chọn được những dòng khác nhau, được gọi là UNION.

		-> Chơi hết mình, phần còn lại phụ thuộc vào đối phương.

	* Có ba nhánh nhỏ:

----------------------------------------

		1. LEFT OUTER JOIN.

			- Lấy bảng bên trái để làm mốc / làm chuẩn.
				+ Chung của cả hai.
				+ Riêng của bên trái.
				+ Bên phải mặc định là NULL.

			* Cú pháp:
				-- Tường minh
				SELECT *
				FROM [Tên bảng 1] LEFT OUTER JOIN [Tên bảng 2]
				ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
				WHERE...
				
				-- Ngầm định
				SELECT *
				FROM [Tên bảng 1] LEFT JOIN [Tên bảng 2]
				ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
				WHERE...

				Ví dụ: Khi cột tiếng Anh có Four nhưng cột tiếng Việt lại chỉ có Năm.
					-- Lấy hết phần chung
					-- và lấy thêm phần riêng của EnDict
					SELECT *
					FROM EnDict e LEFT OUTER JOIN VnDict v
					ON e.Nmbr = v.Nmbr

----------------------------------------

		2. RIGHT OUTER JOIN.

			- Lấy bảng bên phải để làm mốc / làm chuẩn.
				+ Chung của cả hai.
				+ Riêng của bên phải.
				+ Bên trái mặc định là NULL.

			* Cú pháp:
				-- Tường minh
				SELECT *
				FROM [Tên bảng 1] RIGHT OUTER JOIN [Tên bảng 2]
				ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
				WHERE...
				
				-- Ngầm định
				SELECT *
				FROM [Tên bảng 1] RIGHT JOIN [Tên bảng 2]
				ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
				WHERE...

				Ví dụ: Khi cột tiếng Anh có Four nhưng cột tiếng Việt lại chỉ có Năm.
					-- Lấy hết phần chung
					-- và lấy thêm phần riêng của VnDict
					SELECT *
					FROM EnDict e RIGHT OUTER JOIN VnDict v
					ON e.Nmbr = v.Nmbr

----------------------------------------

		3. FULL OUTER JOIN

			- Không còn quan trọng bên nào làm mốc / làm chuẩn.
				+ Chung của cả hai.
				+ Riêng của mỗi bên.

			* Cú pháp:
				-- Tường minh
				SELECT *
				FROM [Tên bảng 1] FULL OUTER JOIN [Tên bảng 2]
				ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
				WHERE...
				
				-- Ngầm định
				SELECT *
				FROM [Tên bảng 1] FULL JOIN [Tên bảng 2]
				ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
				WHERE...

				Ví dụ: Khi cột tiếng Anh có Four nhưng cột tiếng Việt lại chỉ có Năm.
					-- Lấy hết phần chung,
					-- lấy thêm phần riêng của cả EnDict và VnDict
					SELECT *
					FROM EnDict e FULL OUTER JOIN VnDict v
					ON e.Nmbr = v.Nmbr

----------------------------------------

	- Sau khi đã tìm ra được dữ liệu bao gồm cả phần chung và riêng, ta vẫn có quyền sử dụng thêm bộ lọc WHERE trên một ô nào đó như bình thường (HAVING chỉ sử dụng khi có gom nhóm - GROUP BY).

------------------------------------------------------------

4. SELF JOIN

--------------------------------------------------------------------------------

Thứ tự thực hiện các mệnh đề truy vấn trong SQL:
	- https://www.sisense.com/blog/sql-query-order-of-operations/
	- https://laptrinhvb.net/bai-viet/co-so-du-lieu/--DATABASE---Thu-tu-thuc-hien-menh-de-truy-van-SELECT-trong-Sqlserver/060b94c58a5831db.html

==========================================================================================
==========================================================================================
==========================================================================================

[THIẾT KẾ CƠ SỞ DỮ LIỆU - DATABASE DESIGN]

--------------------------------------------------------------------------------

[NHỮNG LƯU Ý KHI ĐƯA DỮ LIỆU VÀO BẢNG]

Khi nhập dữ liệu bằng câu lệnh INSERT INTO [Tên bảng](Thứ tự cột nếu cần) VALUES(...)

	- Mặc định, nếu khi thiết kế không gài thêm ràng buộc, các giá trị (và toàn bộ giá trị) trong bảng được phép mang trạng thái NULL.

* Chỉ định những tên cột sẽ nhập dữ liệu:

	* Nếu không chỉ định những tên cột sẽ nhập dữ liệu.

		- Bắt buộc phải nhập đầy đủ giá trị cho tất cả các cột đã thiết kế.

		- Giá trị nhập vào sẽ phải được liệt kê theo đúng với thứ tự khi thiết kế.

		- Những giá trị nếu muốn mang trạng thái NULL thì phải ghi rõ NULL (không phải chuỗi NULL).

	* Nếu có chỉ định những tên cột sẽ nhập dữ liệu.

		- Những cột không được liệt kê sẽ tự động được gán trạng thái NULL.

		- Giá trị nhập vào sẽ tuân theo thứ tự liệt kê của tên cột trong câu lệnh INSERT INTO.

		- Nếu muốn những cột đang liệt kê cũng mang trạng thái NULL thì vẫn có thể gán trạng thái NULL.

* Ràng buộc dữ liệu:

	* Nếu không có bất kì ràng buộc nào:

		- Sẽ có trường hợp toàn bộ giá trị của một dòng đều là NULL.

		- Sẽ có trường hợp hai đối tượng / thực thể khác nhau hoàn toàn nhưng lại có cùng một mã số, gây khó khăn trong việc xác định duy nhất một đối tượng / thực thể.

	* Nếu có bất kì ràng buộc nào:

		- Dữ liệu nhập vào sẽ theo đúng định dạng đã được quy định từ trước.

		- Nhưng cần tránh việc lạm dụng ràng buộc và gây khó chịu cho người cung cấp thông tin.

--------------------------------------------------------------------------------

[VẼ SƠ ĐỒ Ý NIỆM BẰNG VISUAL PARADIGM]

Bước 01: Tạo mới dự án trong Visual Paradigm.

	Tab Project > New
		Data type set: UML

	Chuyển đổi mức độ sơ đồ:
		Chuột phải > Open Specification...

Bước 02: Tạo sơ đồ.

	Tab Diagram > New
		Tìm (Search): Entity Relationship Diagram
		Mẫu (Template): Blank
		Tên sơ đồ (Diagram Name): ConceptualLevel.Student
			Thư mục (Folder): ConceptualLevel

Bước 03: Thiết kế sơ đồ ở mức ý niệm (ERD)

	Entity > Chuột phải > New Column
		- Dấu + tương đương với khoá chính.
		- Chữ 'N' đại diện cho việc được phép NULL.
			+ Chuột phải vào cột > Bỏ chọn 'Nullable'

Bước 04: Chuyển đổi từ mức ý niệm sang mức luận lý (Logical).

	Chuột phải > Ultilities > Synchronize to Logical ERD...
		> Chọn lại Project > Tạo mới thư mục LogicalLevel

Bước 05: Chuyển từ mức luận lý sang mức vật lý (Physical).

	Chuột phải > Ultilities > Synchronize to Physical ERD...
		> Chọn lại Project > Tạo mới thư mục PhysicalLevel
		> Giữa nguyên toàn bộ tên đã đặt trong quá trình thiết kế

Bước 06: Chuyển thành những câu lệnh SQL.

	Tab Tools > DB > Database Configuration...
		> Chuột phải > Ultilities > Generate SQL...

==========================================================================================

[TRIẾT LÝ THIẾT KẾ BẢNG]



==========================================================================================

[DẠNG CHUẨN - NORMAL FORM / DATABASE NORMALIZATION]

-- Tại sao lại tách dữ liệu thành nhiều bảng?

-- Ưu và nhược điểm của việc tách bảng?

-- Cần bao nhiêu bảng là đủ?

==========================================================================================

* Tham khảo thêm:

	- Cách viết các chỉ số trên và dưới:
		+ Chỉ số trên (Superscript): https://lingojam.com/SuperscriptGenerator
		+ Chỉ số dưới (Underscript / Subscript): https://lingojam.com/SubscriptGenerator

	- eBook tiếng Anh:
		+ https://opendsa-server.cs.vt.edu/ODSA/Books/Database/html/
		+ https://opentextbc.ca/dbdesign01/front-matter/preface/

	- Học cách viết SQL: https://viblo.asia/s/tu-con-ga-den-master-sql-GyZJZlY2Vjm

	- Video bài giảng KMA: https://youtube.com/playlist?list=PLSe6_C9mboBDG8wVFZfSycRQnS51T0H3M&si=JAZKPaot1Fp3egHN

	- ĐH Kinh tế Đà Nẵng: https://www.youtube.com/playlist?list=PLPmbtynBsWO6XdduvLW2U0kLHM2gS6DDA

	- UET-VNU: https://youtube.com/playlist?list=PLe1PkMlDihehJmeTYx9WWI3mhoCHu6jyx&si=T0XQGRF4f-Vc0OPy

	- UIT: https://www.youtube.com/watch?v=Xk2zPvDCWPU&list=PL9Crvl2mNSur7gCYgfrpE4DXsNfM9Wu5O&index=3

	- Ôn tập (HUFLIT): https://www.youtube.com/playlist?list=PL58ota9C8kWTdpGIlbOKeaNhT2MTtp-VN

	- CSDL - PTIT:
		+ https://youtube.com/playlist?list=PLMPM2docCU5izIGBKXugspYApt3J0_mLu&si=oZtEf-XxntLgEeN-
		+ https://youtube.com/playlist?list=PLwrMEg5Wges6U8QcNIUrr_P-AtKWSiC3S&si=FJX3Rlu-595tu2AW

	- Dạng chuẩn (Tiếng Anh) - Studytonight with Abhishek: https://youtube.com/playlist?list=PLLGlmW7jT-nTr1ory9o2MgsOmmx2w8FB3&si=sZmFvmD2TA7T-oD-

	- Dạng chuẩn (Tiếng Anh) - Decomplexify: https://www.youtube.com/playlist?list=PLNITTkCQVxeXryTQvY0JBWTyN9ynxxPH8

	- Ôn tập nhanh (Tiếng Anh) - CS 105: https://www.youtube.com/playlist?list=PLiwphLky56kCx_ir3wMiEbWSK6K6hklrd

	- Blog về lược đồ quan hệ: https://nthnhung.wordpress.com/2020/11/11/bai-2-relational-schemas-la-gi-ma-dan-tinh-thi-nhau-hoi-info-hoa-ra-con-hot-con-hon-ca-erd/

	- Database Design Crash Course for Beginners: https://www.youtube.com/playlist?list=PL9YxAB0kJj9lUpg-kWt2MfZ7K7sX7mh8X

==========================================================================================

==========================================================================================

--------------------------------------------------------------------------------

------------------------------------------------------------

----------------------------------------

--------------------

----------






















[NHẬP MÔN CƠ SỞ DỮ LIỆU VỚI MICROSOFT SQL SERVER]

	"Trứng rán cần mỡ, bắp cần bơ, ỨNG DỤNG CẦN CƠ SỞ DỮ LIỆU"

								   (Database)
									^
									|
									|
						 SQL >			V
(Ngôn ngữ lập trình) <------------------[Internet]--------------> (DBMS - Server)
			< Text / Data					^
									|
								SQL >	|
(SSMS - Client) <-----------------------[Internet]-----------------------
		   < Text / Data

==========================================================================================

[ÔN TẬP KHÁI NIỆM]

* Thông tin (Information): Là tất cả các sự việc, sự kiện, ý tưởng, phán đoán,...
	- Phản ánh về tự nhiên và xã hội (thế giới vật chất) thông qua ngôn từ (con số, chữ viết, ký hiệu), âm thanh, hình ảnh,...
	- Tác động lên giác quan của con người để làm tăng thêm những hiểu biết có được về một đối tượng nào đó.

	-> Những hiểu biết về một đối tượng nào đó.

--------------------------------------------------------------------------------

* Dữ liệu (Data): Là những thông tin nguyên thủy (thô), chưa qua xử lý, không có ý nghĩa rõ ràng.
	- Có thể là số liệu, ký tự, hình ảnh, âm thanh, video hoặc bất kỳ dạng nào của thông tin chưa được xử lý.
	- Mô tả hình thức để thể hiện thông tin hay hoạt động nào đó lên những phương tiện mang tin (dữ liệu được thể hiện thông qua tờ giấy, bức ảnh, chiếc loa,...).
	- Là những thông tin đã được đưa vào thiết bị lưu trữ.

	-> Là thông tin, nhưng được biểu diễn khác đi.

------------------------------------------------------------

Phân loại dữ liệu theo tính chất:

	1. Tĩnh (Static): Không có hoặc rất ít khi có sự thay đổi theo thời gian.
		Ví dụ: Tên, ngày sinh, số CCCD,...

	2. Động (Dynamic): Thường xuyên có sự thay đổi theo thời gian.
		Ví dụ: Tuổi, doanh thu, số lượng hàng trong kho,...

------------------------------------------------------------

Phân loại dữ liệu theo cấu trúc:

	1. Không có cấu trúc / Phi cấu trúc (UnStructured): Là dữ liệu không theo một định dạng cụ thể và không thể được lưu trữ trong một hệ thống hoặc cơ sở dữ liệu truyền thống.
		- Là các tập tin hình ảnh, âm thanh, văn bản,...
		- Chiếm 80% tổng dữ liệu của doanh nghiệp.
			+ Tốn nhiều dung lượng bộ nhớ.
			+ Khó quản lý và bảo mật dữ liệu.

	2. Có cấu trúc (Structured): Dữ liệu ở định dạng chuẩn hoá để con người và phần mềm dễ dàng truy cập.
		- Thường ở dạng bảng (Table), bao gồm các hàng (Row) và cột (Column) xác định rõ ràng các thuộc tính dữ liệu.
		- Là các con số, chuỗi và ngày-tháng-năm.
		- Chỉ chiếm 20% tổng dữ liệu của doanh nghiệp.
			+ Đây là những giá trị thực sự có giá trị sử dụng.
			+ Tốn ít dung lượng bộ nhớ hơn.
			+ Dễ dàng quản lý và bảo mật dữ liệu hơn.

Khi dữ liệu được để lung tung sẽ giống như "mò kim đáy biển" vì chúng đang được tổ chức không theo cấu trúc.
	- Nếu có một dữ liệu quan trọng cần lưu trữ, việc lưu trữ trong một nơi không có cấu trúc sẽ tiêu tốn rất nhiều thời gian trong việc tìm kiếm về sau này.
	- Vì vậy, cần phải sắp xếp dữ liệu theo một cấu trúc để giúp việc truy cập trở nên dễ dàng hơn.

--------------------------------------------------------------------------------

Mọi sự việc diễn ra xung quanh chúng ta đều tạo ra thông tin.
	- Về cơ bản, con người có thể sử dụng các giác quan để thu thập thông tin.
	- Nhưng với nhu cầu muốn biết thêm nhiều hơn, hiểu thế giới quanh mình rõ hơn và đúng hơn, con người đã tạo ra nhiều loại thiết bị thu nhận các tín hiệu từ thế giới xung quanh.
	- Các loại thiết bị nhu nhận tín hiệu này sẽ trả về dữ liệu.
	- Dữ liệu sau đó sẽ được lưu vào thiết bị lưu trữ hoặc được gửi đi qua đường truyền dữ liệu.
	- Từ dữ liệu, thông qua quá trình xử lý, chúng ta có thể rút ra được nhiều thông tin khác nhau.

	-> Con người tiếp nhận dữ liệu qua các giác quan để chuyển thành thông tin.

	Ví dụ:

				Con người
				đến tham quan			Chuyển thành
				trực tiếp			thông tin
	"Hội An có Chùa Cầu --------------------> [Giác quan] ------------------> Não bộ
	với mái vòm cong				^
	rất độc đáo"					|
		|					|
		|					|
		--------------------------------> [Hình ảnh về Chùa Cầu]
		   Thiết bị thu nhận tín hiệu
		   (Máy ảnh, điện thoại...)

Mối quan hệ giữa thông tin và dữ liệu:

	- Thông tin -> dữ liệu:
		+ Quá trình nói, viết, vẽ, cử chỉ,... sẽ chuyển thông tin trong não bộ thành dữ liệu để lưu trữ hay gửi đi khi trao đổi thông tin.
		+ Thông tin có thể được biểu diễn dưới các dạng / hình thức (dữ liệu) khác nhau.
		(Nhiều dữ liệu cùng biểu diễn một thông tin.)

		Ví dụ 1: Để mô tả về ngôi nhà (thông tin), chúng ta có thể chuyển thông tin thành dữ liệu dưới dạng:
			- Hình ảnh: Vẽ tranh.
			- Văn bản: Viết văn.
			- Âm thanh: Sáng tác bài hát.
			-> Chuyển thông tin thành dữ liệu dưới nhiều dạng khác nhau.

		Ví dụ 2: Để tránh làm phiền người khác nơi đông người, để trao đổi thông tin, ta có thể sử dụng các dấu hiệu: gật/lắc đầu, mỉm cười,...
			-> Thông tin được trao đổi dưới nhiều dạng khác nhau.

	- Dữ liệu -> Thông tin:
		+ Dữ liệu là nguồn thông tin, có nhiều cách thức khác nhau để thể hiện thông tin, nên văn bản chữ và số, hình vẽ, hình ảnh, âm thanh, video,... đều là dữ liệu.
		+ Từ dữ liệu có thể rút ra nhiều thông tin khác nhau nhờ vào quá trình xử lý.
		(Một dữ liệu chứa nhiều thông tin.)

		Ví dụ 1: Từ bước tranh, bài văn, bài hát,... (dữ liệu) về ngôi nhà, ta có thể rút ra được nhiều thông tin khác nhau:
			- Ngôi nhà có đẹp hay không?
			- Chủ nhà theo đuổi phong cách gì?
			-> Rút ra được nhiều thông tin từ dữ liệu.

		Ví dụ 2: Dũng gửi mảnh giấy (dữ liệu) cho Hoàng: "Tan học chờ tớ ở cổng trường nhé!".
			- Dòng chữ trên mảnh giấy là dữ liệu văn bản, nội dung dòng chữ là thông tin (mảnh giấy là cách biểu diễn thông tin dưới dạng văn bản).
			- Nếu Hoàng đọc được mảnh giấy, thông qua nét chữ, kiểu viết,... Hoàng sẽ biết là do Dũng gửi và Dũng muốn hẹn gặp mình ở cổng trường sau khi tan học.
			- Nhưng nếu một người khác đọc mảnh giấy, người này sẽ không biết được người gửi và nhận là ai, chỉ biết có một cuộc hẹn diễn ra ở cổng trường khi tan học.
			-> Rút ra được nhiều thông tin từ dữ liệu.

		Ví dụ 3: Khi nghe một đoạn âm thanh (dữ liệu), ta có thể rút ra được những thông tin:
			- Nội dung của đoạn âm thanh.
			- Chất giọng (vùng miền) của người nói.
			- Cảm xúc của người nói.
			-> Rút ra được nhiều thông tin từ dữ liệu.

	-> Thông tin và dữ liệu có tính độc lập tương đối.
		- Một thông tin có thể được thể hiện dưới nhiều dạng dữ liệu.
		- Một dữ liệu có thể chứa nhiều thông tin.

--------------------------------------------------------------------------------

* Thông tin hữu ích / Thông tin có giá trị gia tăng (Value added information): Các dữ liệu đã qua xử lý (phân loại, phân tích, sắp xếp, tổng hợp, tính toán, chọn lựa,...) để thu được những thông tin có giá trị cao hơn.
	- Khi dữ liệu được thu thập từ các nguồn khác nhau, nó cần được xử lý để loại bỏ nhiễu, đảm bảo tính chính xác và đáng tin cậy.
	- Sau đó, phân tích dữ liệu có thể được thực hiện để tìm ra mẫu, xu hướng hoặc quan hệ giữa các yếu tố khác nhau.
	- Thông qua quy trình phân tích, các phương pháp và công cụ thích hợp được áp dụng để giải mã dữ liệu và tạo ra thông tin ý nghĩa.
	- Các kỹ thuật, như máy học, khai phá dữ liệu, phân tích thống kê và mô hình hóa, có thể được sử dụng để xác định các mẫu ẩn, tìm kiếm thông tin quan trọng và đưa ra dự đoán.
	- Sau khi dữ liệu đã được xử lý và phân tích, các thông tin quan trọng và giá trị được tổng hợp lại thành một cách dễ hiểu.
	- Giúp mang lại hiểu biết và kiến thức để giải quyết vấn đề, đưa ra quyết định hoặc truyền đạt ý kiến.

	Ví dụ 1: Từ bảng điểm tổng kết các môn học của học sinh cả lớp, cần tìm ra 3 học sinh có điểm trung bình môn học cao nhất lớp để làm danh sách đề nghị nhà trường tuyên dương và khen thưởng.
		- Thông tin đầu vào: Tên học sinh và điểm tổng kết các môn của học sinh.
		- Dữ liệu đầu vào: Bảng điểm liệt kê tên (văn bản) và điểm trung bình (số).
		- Thông tin đầu ra: 3 học sinh có điểm trung bình môn học cao nhất lớp.
		- Dữ liệu đầu ra: Danh sách tên (văn bản) của 3 học sinh.
		-> Nhận bảng điểm để xử lý và cho ra danh sách tương ứng để khen thưởng.

	Ví dụ 2: Tóm tắt quá trình dữ liệu trở thành thông tin hữu ích.

		[Dữ liệu]					[Thông tin hữu ích]

		Điểm số của		     Xử lý		- Điểm trung bình của sinh viên
		tất cả sinh viên	--------------->	- Sinh viên có điểm cao nhất

--------------------------------------------------------------------------------

* Tri thức / Kiến thức (Knowledge): Là các hiểu biết hoặc kĩ năng về một điều gì đó, có được nhờ trải nghiệm thực tế hoặc học tập.

==========================================================================================

[CƠ SỞ DỮ LIỆU & CÁC THUẬT NGỮ LIÊN QUAN]

Con người đã lưu trữ và sử dụng dữ liệu từ lâu, nhưng gần đây con người bắt đầu lưu trữ một lượng lớn dữ liệu ở định dạng dễ dàng truy xuất.
	+ Kể từ khi bắt đầu nền văn minh, người Babylon cổ đại đã khắc thông tin lên những tấm đất sét.
	+ Lượng dữ liệu được ghi chép lại tăng lên khi phát minh ra hệ số Ả Rập và thêm một bước nhảy vọt khác khi máy tin được phát minh.
	+ Với mỗi tiến bộ công nghệ, lượng dữ liệu lại càng tăng lên và việc lưu trữ để sử dụng cũng tăng theo.

Trong tin học, để máy tính xử lý được thông tin, thông tin đó phải được chuyển thành dữ liệu trong máy tính (dữ liệu số hoá).

Khi số lượng dữ liệu ngày càng lớn, đặc biệt là trong các hệ thống thương mai điện tử khi số lượng dữ liệu được tăng liên tục mỗi ngày (kể cả những hành động đơn giản như lưu lại lịch sử xem sản phẩm cũng sẽ phát sinh dữ liệu).
	- 80% dữ liệu của doanh nghiệp sẽ ở dạng phi cấu trúc.
	- Để quản lý (lưu trữ, thao tác (thêm-sửa-xoá) và truy xuất (xem)) một lượng dữ liệu.
		+ Cần phải biến những dữ liệu phi cấu trúc thành dữ liệu có cấu trúc.
		+ Cần phải sử dụng thêm những hệ thống hỗ trợ quản lý.
	- Phục vụ cho nhu cầu khai thác thông tin của một hoặc nhiều người (mà chủ yếu là nhiều người).

	-> Dữ liệu cần được lưu một cách có cấu trúc và có cơ chế cho phép truy xuất nhanh.

--------------------------------------------------------------------------------

* Quản lý dữ liệu: Là các hành động liên quan đến việc lập kế hoạch, phát triển, thực hiện và quản trị các hệ thống để thu thập, lưu trữ, bảo mật, truy xuất và xử lý dữ liệu.

Để giải quyết một bài toán, có hai việc mà chúng ta cần quan tâm:
	1. Phương pháp để quản lý dữ liệu.
	2. Thuật toán tương ứng để xử lý dữ liệu.

Khi nhắc đến các phương pháp để quản lý dữ liệu, ta có các hệ thống quản lý dữ liệu: Mỗi ứng dụng khác nhau sẽ phát sinh ra những dữ liệu khác nhau và yêu cầu một hệ thống để quản lý toàn bộ dữ liệu.

	1. Hệ thống quản lý bằng tập tin: Mỗi ứng dụng sẽ có nhiều tập tin và mỗi người dùng sẽ có một tập tin riêng để lưu trữ và quản lý thông tin dựa theo nhu cầu riêng của mình (quản lý không tập trung).
		- Là hệ thống lưu trữ không có cấu trúc.
		- Dữ liệu sẽ không có liên kết với nhau.

		* Ưu điểm:
			- Có thể sử dụng được ngay mà không cần cài đặt thêm phần mềm.
			- Tốc độ phản hồi khi truy xuất sẽ rất nhanh.

		* Nhược điểm:

			- Trùng lặp, dư thừa và mâu thuẫn dữ liệu: Toàn bộ những thông tin cần thiết sẽ được đưa vào cùng một tập tin.
				+ Tuy cùng nói về một thông tin, nhưng mỗi người sẽ sở hữu một tập tin riêng và có toàn quyền trên tập tin đó.
				+ Cấu trúc lưu trữ có thể khác nhau dù cho nhiều người cùng lưu trữ về cùng một loại dữ liệu giống nhau.
				+ Việc sửa đổi dữ liệu sẽ không được diễn ra đồng bộ, làm mất đi tính toàn vẹn dữ liệu.

				Ví dụ: Cùng một tập tin về một loại dữ liệu, nhưng những người dùng thuộc những phân hệ khác nhau (kế toán, bán hàng,...) sẽ có những cách khác nhau để lưu trữ.
					- Khi lưu trữ dữ liệu về ngày-tháng-năm.
						+ Sẽ có người thích lưu trữ theo định dạng: ngày/tháng/năm.
						+ Sẽ có người thích lưu trữ theo định dạng: năm/tháng/ngày.

					- Khi lưu trữ dữ liệu về giới tính.
						+ Sẽ có người thích lưu trữ theo định dạng: Nam / Nữ / Khác.
						+ Sẽ có người thích lưu trữ theo định dạng: 0 / 1 / 2.

			- Hạn chế chia sẻ và truy cập đồng thời: Dữ liệu sẽ không được quản lý tập trung tại một nơi và không hỗ trợ truy cập đồng thời từ nhiều người dùng.
				+ Để chia sẻ được tập tin, bắt buộc phải có một máy chia sẻ dữ liệu qua mạng.
				+ Nếu nhiều người cần truy cập dữ liệu cùng một lúc sẽ dễ gây ra vấn đề về tính nhất quán của dữ liệu, nên cần phải sắp xếp thứ tự khi nhiều người cùng sử dụng một tập tin được chia sẻ qua mạng.

			- Bảo mật: Việc kiểm soát quyền truy cập vào tập tin có thể phức tạp và không an toàn vì một máy tính trong hệ thống mạng có thể bị nhiễm mã độc và lây lan cho những máy khác đang truy cập để lấy dữ liệu trong cùng mạng.

			- Sao lưu và phục hồi: Phụ thuộc phần lớn vào hệ điều hành với các thao tác sao chép và dán tập tin sang một ổ đĩa khác.
				+ Việc sao lưu và phục hồi dữ liệu từ tập tin có thể mất nhiều thời gian và công sức hơn vì dữ liệu được phân tán ở nhiều nơi.
				+ Khó được thực hiện một cách thường xuyên (theo thời gian thực) khi có người dùng đang sử dụng.

			- Tính linh hoạt: Hệ thống tập tin có giới hạn về khả năng mở rộng và linh hoạt trong việc xử lý các yêu cầu dữ liệu phức tạp.

	2. Hệ thống quản lý bằng cơ sở dữ liệu: Dữ liệu được lưu trữ tập trung tại một nơi và chia sẻ cho nhiều người cùng sử dụng.
		- Dữ liệu sẽ được tổ chức, chuẩn hoá và lưu trữ có cấu trúc.
		- Giúp quản lý dữ liệu một cách hiệu quả và nhanh chóng.

Khi lập trình, dữ liệu chỉ được lưu trữ tạm thời trong các biến trên RAM, sau khi kết thúc chương trình thì toàn bộ dữ liệu sẽ bị mất đi.
	- Để lưu trữ lại dữ liệu, cách đơn giản nhất là sử dụng một tập tin văn bản.
	- Nhưng tập tin văn bản không thích hợp để sử dụng trong một hệ thống có nhiều người dùng cùng truy cập vào một tài nguyên.
	- Vì vậy, trong các hệ thống lớn, cơ sở dữ liệu thường được sử dụng để lưu trữ dữ liệu.

--------------------------------------------------------------------------------

	* Data: Dữ liệu.
	* Base: Nền tảng, khu vực, không gian.
		-> Cơ sở dữ liệu / Không gian để lưu trữ dữ liệu.
* Cơ sở dữ liệu (Database - DB): Giống như một chiếc thùng hoặc tủ đồ, nơi chuyên được sử dụng để lưu những dữ liệu có tổ chức liên quan đến nhau (dữ liệu bên trong được cất một cách ngăn nắp trong các kệ - bảng).

	- Là một tập hợp các dữ liệu...
		+ Phải có liên quan với nhau, nhưng không phải là một tập dữ liệu tuỳ tiện.
		+ Được tổ chức theo một cách có hệ thống (có cấu trúc, có liên quan luận lý và ràng buộc với nhau) và theo một mô hình.
		+ Cho phép lưu trữ, truy xuất và thao tác (xem-thêm-sửa-xoá) dữ liệu một cách hiệu quả.

		Ví dụ 1: Cơ sở dữ liệu Bệnh Viện lưu trữ bác sĩ, bệnh nhân, chẩn đoán, điều trị của bệnh nhân, hóa đơn của bệnh nhân...
			-> Các dữ liệu có liên quan với nhau.

		Ví dụ 2: Để quản lý dữ liệu về việc sở hữu ô tô, ta cần một số thông tin:
			- Công dân: Thông tin về công dân có thể sở hữu ô tô.
			- Ô tô: Thông số về ô tô.
			- Thông tin sở hữu: Là sự liên kết (mối liên quan) giữa công dân và ô tô, cho biết thông tin về việc sở hữu ô tô của công dân.

			-> Các dữ liệu có liên quan với nhau.

	- Yêu cầu cần có để được gọi là một cơ sở dữ liệu:
		+ Dữ liệu được mô hình hóa theo cấu trúc, được tổ chức để hỗ trợ tìm kiếm.
		+ Là sự kết hợp giữa dữ liệu và một hệ thống quản lý (tìm kiếm, truy vấn, in báo cáo,...).
		+ Dữ liệu sẽ không bị mất, trừ khi bị xoá.
		+ Dữ liệu lưu trữ có mối quan hệ (Relational / Relationship) với nhau.
		+ Các cơ sở dữ liệu có khả năng kết nối với nhau (Relational / Relationship).
		+ Hỗ trợ nhiều người dùng cùng một lúc.
		+ Dễ dàng mở rộng, chứa nhiều dữ liệu mà không tốn quá nhiều dung lượng, nhờ vào khả năng liên kết các cơ sở dữ liệu.
		+ Quản lý truy cập bằng cách cấp quyền truy cập riêng biệt cho từng cột thuộc tính trong một bảng thay vì cấp quyền truy cập cho toàn bộ bảng.

	- Để xem-thêm-sửa-xoá dữ liệu, hầu hết các cơ sở dữ liệu đều sử dụng ngôn ngữ truy vấn có cấu trúc (Structured Query Language - SQL).

	-> Tập hợp những dữ liệu được tổ chức có cấu trúc và liên quan với nhau.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Cơ sở dữ liệu gồm nhiều dữ liệu liên quan với nhau,	│
│	được lưu trữ có cấu trúc để dễ dàng truy xuất		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------------------------------------

"Một tập tin văn bản hoặc một bảng tính (Spreadsheet) chứa nhiều dữ liệu có được xem là cơ sở dữ liệu không?"

Có rất nhiều thảo luận về việc được hay không được xem là một cơ sở dữ liệu, nhưng hướng giải thích sau đây sẽ tập trung vào việc một tập tin dữ liệu (Flat File) không được xem là cơ sở dữ liệu.
	- Là loại dữ liệu không có cấu trúc, hoặc kể cả khi một bảng tính có cấu trúc hàng và cột, nó vẫn không được xem là cơ sở dữ liệu.
	- Tập tin dữ liệu không chứa liên kết đến bất kì tập tin nào khác.
	- Tại một thời điểm, chỉ cho phép duy nhất một người dùng tương tác.
	- Không thể lựa chọn dữ liệu để hiển thị, chỉ được phép hoặc hiển thị hết hoặc không cho truy cập.

------------------------------------------------------------

Đặc tính / Đặc trưng (lợi ích) của cơ sở dữ liệu:

	- Tính tự mô tả: Hệ CSDL không chỉ chứa mỗi CSDL, mà còn chứa chi tiết về mô tả của CSDL (cấu trúc tập tin, kiểu dữ liệu, ràng buộc dữ liệu, miền giá trị,...).
		+ Thông tin mô tả cấu trúc đầy đủ của CSDL được lưu trữ trong bản liệt kê mục lục (Catalog).
		+ Dữ liệu của catalog được gọi là siêu dữ liệu (Metadata - dữ liệu cung cấp thông tin về một dữ liệu khác, cụ thể là thông tin về đặc tả của CSDL).
		+ Nhờ vào thông tin cấu trúc được lưu trong catalog mà các ứng dụng có thể hiểu được và có thể truy xuất đến CSDL.

		-> Phải tự mô tả cấu trúc và ràng buộc được để nơi khác sử dụng.

	- Tính độc lập giữa ứng dụng và dữ liệu: Cho phép thay đổi cấu trúc hoặc dữ liệu (thêm-sửa-xoá) trong CSDL mà không cần phải thay đổi ứng dụng đang sử dụng CSDL.
		+ Độc lập dữ liệu mức luận lý: Cấu trúc mức luận lý của CSDL thay đổi (ví dụ: thêm cột vào bảng, xoá bảng,...) sẽ không ảnh hưởng đến ứng dụng.
		+ Độc lập dữ liệu mức vật lý: Cấu trúc vật lý của CSDL thay đổi (ví dụ: đổi HQTCSDL, đổi cách tổ chức dữ liệu, đưa dữ liệu từ ổ đĩa lên "mây",...) sẽ không ảnh hưởng đến ứng dụng. 

		-> CSDL có thay đổi cũng không ảnh hưởng đến ứng dụng.

	- Tính trừu tượng dữ liệu: Dữ liệu chỉ được biểu diễn ở mức ý niệm, chi tiết về cách thức lưu trữ sẽ được che giấu.
		- Hỗ trợ cho tính độc lập, tách biệt giữa ứng dụng và dữ liệu khi toàn bộ những câu lệnh truy vấn sẽ được lưu trữ trong CSDL thay vì trong ứng dụng.
			+ Mỗi khi có thay đổi gì trong dữ liệu, những truy vấn liên quan sẽ được thực hiện trực tiếp tại hệ quản trị cơ sở dữ liệu, sẽ không cần phải chỉnh sửa trong ứng dụng.
		- Dữ liệu được trừu tượng hoá bằng cách xác định mô hình dữ liệu (tìm ra: thực thể, thuộc tính và mối kết hợp), sau đó đưa cho máy để máy hiểu về ý tưởng và cách thức lưu trữ.

		-> Đảm bảo tính độc lập, che giấu đi chi tiết thiết kế CSDL.

	- Tính nhất quán dữ liệu: Dữ liệu được lưu tập trung ở một nơi nên sẽ tránh được tình trạng trùng lặp và thiếu nhất quán trong thông tin.
		+ Phải có cơ chế điều khiển truy xuất dữ liệu hợp lý để tránh tranh chấp dữ liệu và đảm bảo dữ liệu luôn đúng tại mọi thời điểm.
		+ Phải xây dựng CSDL thoả được các tính chất trong dạng chuẩn.

		-> Dữ liệu phải luôn thống nhất để tránh xung đột.

	- Đa khung nhìn dữ liệu: CSDL cho phép nhiều người dùng khác nhau (với những mục đích khác nhau) cùng sử dụng.
		+ Mỗi người dùng, với những phân quyền khác nhau, sẽ có một cách nhìn (View) khác nhau về dữ liệu.
		+ Cách nhìn / Góc nhìn / Khung nhìn / Giao diện (View) có thể là một phần (hàng và cột) sẵn có trong CSDL được rút trích ra hoặc yêu cầu phải tổng hợp và tính toán từ CSDL mà thành.

		-> Cung cấp nhiều góc nhìn tương ứng với những loại người dùng khác nhau.

------------------------------------------------------------

Những nhóm người sử dụng cơ sở dữ liệu:

	1. Người thiết kế cơ sở dữ liệu (Database Designer): Phân tích yêu cầu phần mềm và thiết kế ra cơ sở dữ liệu để lập trình viên sử dụng.
		- Trao đổi với người dùng để nắm bắt yêu cầu phần mềm và đưa ra sơ đồ thiết kế (từ ý niệm đến vật lý) để thoả mãn yêu cầu.
		- Lựa chọn cấu trúc và HQTCSDL phù hợp để lưu trữ dữ liệu.
		- Quyết định những dữ liệu nào cần được lưu trữ và những dữ liệu này có liên quan với nhau như thế nào.
		- Định nghĩa các chỉ mục (Index) và phương pháp lập chỉ mục để tối ưu quá trình khai thác CSDL.

	2. Người quản trị cơ sở dữ liệu (Database Administrator - DBA): Tuy không phải là người trực tiếp tạo ra cơ sở dữ liệu, nhưng lại là người xử lý những vấn đề xoay quanh cơ sở dữ liệu như:
		- Đảm bảo máy tính (phần cứng) và HQTCSDL (phần mềm) được hoạt động thông suốt.
		- Phân quyền, giới hạn và thu hồi quyền truy cập của người dùng để ngăn chặn những truy cập không được phép.
		- Tổ chức sao lưu và phục hồi dữ liệu để tránh rủi ro về mất mát dữ liệu trong những trường hợp: ổ đĩa bị hỏng, hệ điều hành bị hỏng, máy chủ bị hỏng, mất điện, thiên tai,...
		- Bảo mật cơ sở dữ liệu khỏi những cuộc tấn công mạng.

	3. Người dùng cuối (End-user): Đa phần đều là những người sử dụng ứng dụng (thông qua giao diện của ứng dụng) để truy cập vào dữ liệu trong cơ sở dữ liệu.

		3.1. Người sử dụng ít (Casual User / Temporary User): Thường là những người quản lý, ít có nhu cầu truy cập vào CSDL, nhưng nếu có thì thường yêu cầu những câu truy vấn phức tạp.

		3.2. Người sử dụng thường xuyên (Naive / Parametric End User): Thường xuyên phải sử dụng CSDL nhưng không yêu cầu phải có những hiểu biết về HQTCSDL, có thể sử dụng thông qua giao diện của một ứng dụng nào đó.

		3.3. Người sử dụng đặc biệt (Sophisticated User): Người có kiến thức sâu rộng về CSDL (ví dụ: BA, nhà khoa học,...) và có thể sử dụng SQL để tương tác với HQTCSDL và thực hiện những truy vấn phức tạp.

		3.4. Người sử dụng cá nhân (Stand-alone User): Người sử dụng các ứng dụng để phục vụ công việc cá nhân (ví dụ: quản lý thuế cá nhân, quản lý bảo hiểm xã hội,...).

	4. Người lập trình (Developer): Viết ra các chương trình có kết nối đến cơ sở dữ liệu.

------------------------------------------------------------

Phân loại mô hình cơ sở dữ liệu:

	- Thế hệ đầu tiên (truyền thống):
		+ CSDL phân cấp (Hierarchical).
		+ CSDL mạng (Network).

	- Thế hệ thứ hai:
		+ CSDL quan hệ (Relational).

	- Thế hệ thứ ba:
		+ CSDL hướng đối tượng (Object-Oriented).

------------------------------------------------------------

Trong thời đại ngày nay, mọi hành xử của những ứng dụng mà chúng ta đang sử dụng, đằng sau nó hầu hết đều là cơ sở dữ liệu.
	- Tất cả các lĩnh vực trong cuộc sống như kinh doanh, ngân hàng và tài chính, giáo dục, hành chính, giải trí..., đều phát sinh rất nhiều dữ liệu cần đến cơ sở dữ liệu.
	- Thậm chí, trong dữ liệu lớn, trí tuệ nhân tạo..., cơ sở dữ liệu là điều bắt buộc phải có vì đây là cơ sở để khai thác, tìm quy luật và đưa ra quyết định.
	- Để tương tác được với cơ sở dữ liệu (Server), ta sẽ có hai cách:
		1. Sử dụng ngôn ngữ lập trình để gọi đến cơ sở dữ liệu trong code.
		2. Sử dụng câu lệnh / cú pháp để tương tác trực tiếp với dữ liệu.

Có thể xem các thuật ngữ Server, Servcie, Database Instance, Database Engine, Database Server... là một và đều nói về nơi chứa dữ liệu, một loại dịch vụ (Service) chạy ngầm (background) để phục vụ cho những nơi khác (Client).

--------------------------------------------------------------------------------

* Hệ quản trị cơ sở dữ liệu / Hệ thống quản lý cơ sở dữ liệu (Database Management System - DBMS): Là một ứng dụng hỗ trợ phân tích, thiết kế và quản lý tự động các cơ sở dữ liệu (lưu trữ, xem-thêm-sửa-xoá thông tin trong một nhóm dữ liệu nhất định).

	- Chuyên cung cấp giao diện để người dùng sử dụng những tiện ích như:
		+ Định nghĩa: Tạo ra cấu trúc của dữ liệu (cấu trúc hàng và cột) và các mô tả chi tiết về dữ liệu (kiểu dữ liệu, mối quan hệ giữa các bảng và các ràng buộc).
		+ Xây dụng: Đưa dữ liệu vào bảng và lưu vào bộ nhớ, dựa vào cấu trúc đã định nghĩa trước (nhập giá trị vào đúng cột đã thiết kế).
		+ Xử lý / Thao tác: Truy vấn (xem-thêm-sửa-xoá) dữ liệu và thực hiện tổng hợp, tạo báo cáo.

		-> Thiết kế cấu trúc và khai thác dữ liệu.

	- Đồng thời, giúp các DBA thuận tiện trong việc sao lưu, phục hồi, giám sát hiệu suất, báo cáo dữ liệu, kiểm soát đa truy cập và bảo mật.

		-> (Tạo,) Quản lý và duy trì cơ sở dữ liệu.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Hệ quản trị cơ sở dữ liệu là phần mềm		│
│	giúp tương tác với dữ liệu trong cơ sở dữ liệu	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

Một số đặc điểm (và tiêu chuẩn) của HQTCSDL:

	- Tăng tính chia sẻ dữ liệu khi dữ liệu được quản lý tập trung tại một nơi (Server).
		+ Nhưng vẫn bảo mật dữ liệu bằng cách giới hạn khả năng truy cập (phân quyền) của người dùng hoặc ứng dụng vào dữ liệu.
		+ Đồng thời giải quyết tranh chấp khi cả hai người dùng cùng truy cập và chỉnh sửa trên một dữ liệu, người đến trước sẽ có được quyền tương tác và đặt một khoá cho dữ liệu, người đến sau sẽ không thể chỉnh sửa được vì dữ liệu đang tạm thời bị khoá.

	- Đảm bảo các ràng buộc toàn vẹn (Integrity Constraint), đề ra các quy tắc bắt buộc (Rule) phải tuân theo để dữ liệu phản ảnh đúng với thực tế.

	- Tránh được việc dư thừa và trùng lặp dữ liệu tại nhiều nơi (tối thiểu hoá dư thừa thông tin).
		+ Các dòng thông tin trong cùng một bảng không được phép lặp lại, nhiều người dùng cùng lưu một thông tin thì chỉ có một dòng thông tin được lưu vào cơ sở dữ liệu.
		+ Dựa vào các mối quan hệ giữa các thực thể, xác định những thuộc tính nào của bảng này được phép "chay" sang bảng khác để làm tham chiếu (không phải lưu toàn bộ thuộc tính của bảng này vào bảng khác).
		+ Hạn chế những mẫu tin ma (Phantom Row) khi dữ liệu tự động có mặc dù không thêm.

	- Tăng tính chính xác, nhất quán và chất lượng của dữ liệu khi dữ liệu đã có cấu trúc (được lưu trữ theo hàng và cột), mỗi cột chỉ lưu trữ đúng kiểu dữ liệu mà mình được quy định.

	- Giảm chi phí sao lưu, bảo trì và phục hồi khi gặp sự cố về mất mát dữ liệu hoặc những hư hỏng về phần cứng và phần mềm.

	- Bảo mật và bảo vệ dữ liệu:
		+ Cung cấp các cơ chế bảo mật bằng cách phân quyền và giới hạn quyền truy cập thông qua 4 mức bảo mật.
			1. Máy chủ: Phân quyền truy cập vào máy chủ dữ liệu (bằng tài khoản và mật khẩu).
			2. Cơ sở dữ liệu: Sau khi đã truy cập được vào máy chủ dữ liệu, phân quyền truy cập và tương tác với từng cơ sở dữ liệu.
			3. Bảng: Phân quyền truy cập và tương tác với từng bảng trong cơ sở dữ liệu.
			4. Trường dữ liệu: Phân quyền truy cập và tương tác với từng trường trong bảng.
		+ Bảo vệ dữ liệu bên trong khi có xảy ra tấn công (tạo nên nhiều lớp bảo mật và dữ liệu sẽ không được đính kèm chung với ứng dụng nữa).

Bên cạnh SQL Server của Microsoft, ta còn có nhiều HQTCSDL khác, nhưng tất cả đều sử dụng SQL với cùng một ý tưởng và cách thức hoạt động.

	Vi dụ: Oracle Database, IBM Db2, MongoDB, PostgreSQL, MySQL, Redis, SQLite...
	
------------------------------------------------------------

* Hệ quản trị cơ sở dữ liệu quan hệ (Relational Database Management System - RDBMS): Là dạng phổ biến nhất của HQTCSDL.

	- Hệ thống quản lý cơ sở dữ liệu theo mô hình dữ liệu quan hệ (Relational Data Model).

	- Nhấn mạnh vào tính chất quan hệ giữa các bảng và hỗ trợ các ràng buộc quan hệ giữa các bảng thông qua các khóa chính và khóa ngoại.

	- Yêu cầu tuân thủ theo các quy tắc được gọi là dạng chuẩn (Normal form / Database normalization).

------------------------------------------------------------

Vì là một phần mềm nên Database Engine (HQTCSDL) còn hỗ trợ:

	1. Lập trình (Programming): giống như một môi trường lập trình khi có thể sử dụng các câu lệnh rẻ nhánh...

	2. Kiểu dữ liệu (Data type): hỗ trợ nhiều kiểu dữ liệu khác nhau để có thể lưu được hết tất cả các dữ liệu.

		* Kiểu chuỗi & nhị phân:

			- BINARY: Kích thước tối đa 8000 kí tự.
			- VARBINARY: Kích thước tối đa 8000 kí tự.
			- IMAGE

			- CHAR: Kích thước tối đa 8000 kí tự.
				+ Xin bao nhiêu, cấp cố định bấy nhiêu.
				+ Chỉ sử dụng khi thật sự biết rõ độ dài cần lưu trữ, vì những kí tự đã xin cấp phát nhưng không sử dụng sẽ tự động được thay bằng những kí tự khoảng trắng về phía bên phải.
				+ Tuy tốn dung lượng, nhưng lại cấp phát rất nhanh vì đã biết trước kích thước cần sử dụng, không cần phải tốn thời gian và tài nguyên để tính toán.
				+ Không chứa kí tự trong bảng mã Unicode.

			- NCHAR: Kích thước tối đa 4000 kí tự.
				- 'N' giúp lưu những kí tự trong bảng mã Unicode.
				- Giống CHAR, nhưng kích thước tối đa ít hơn vì có hỗ trợ lưu trữ những kí tự Unicode.

			- VARCHAR: Kích thước tối đa 8000 kí tự.
				+ Sử dụng bao nhiêu thì cấp bấy niêu, dù trước đó có xin nhiều hơn (biến thiên độ dài).
				+ Giúp tiết kiệm về mặt lưu trữ, nhưng lại tốn về mặt xử lý khi phải tìm vùng nhớ trên ổ đĩa khớp với dung lượng cần sử dụng.
				+ Không chứa kí tự trong bảng mã Unicode.

			- NVARCHAR: Kích thước tối đa 4000 kí tự.
				- 'N' giúp lưu những kí tự trong bảng mã Unicode.
				- Được sử dụng phổ biến nhất, đặc biệt là khi xây dựng những ứng dụng sử dụng cho nhiều quốc gia khác nhau.

			- TEXT: Kích thước tối đa 2 GB.
			- NTEXT:  Kích thước tối đa 1.073.741.823 byte.
				+ Không cần thiết phải chỉ định kích thước tối đa.
				+ Cho phép lưu trữ nhiều đoạn văn (nhiều câu).

		* Kiểu số:

			* Số chính xác (Exact numeric):
			- BIT: Chỉ bao gồm 0, 1 hoặc NULL.
			- TINYINT: Từ 0..255 (1 byte).
			- SMALLINT: Từ -32.768..32.767 (2 byte).
			- INT: Từ -2.147.483.648..2.147.483.647 (4 byte).
			- BIGINT: (8 byte).
			- MONEY
			- SMALLMONEY
			- DECIMAL (precision, scale): Là một kiểu số thực, nhưng vẫn được xem là số chính xác vì chúng không làm tròn.
				+ Độ chính xác (precision): Tổng số chữ số (1..38) sẽ có, bao gồm cả dấu chấm/ phẩy.
				+ Tỷ lệ (scale): Số chữ số bên phải dấu chấm thập phân, mặc định là 0.
			- NUMERIC

			* Số gần đúng (Approximate numeric):
			- FLOAT
			- REAL

		* Kiểu ngày & giờ:

			- DATE: Có định dạng là yyyy-MM-dd.
			- DATETIME: Có định dạng là yyyy-MM-dd hh:mm:ss[.mmm].
				+ Phạm vi ngày: 01/01/1753..31/12/9999.
				+ Phạm vi thời gian: 00:00:00..23:59:59.997.
			- DATETIME2
			- DATETIMEOFFSET
			- SMALLDATETIME
				+ Phạm vi ngày: 01/01/1900..06/06/2079.
				+ Phạm vi thời gian: 00:00:00..23:59:59.
			- TIME: Có định dạng là hh:mm:ss.

	3. Hàm (Function): có cung một số hàm đã được xây dựng sẵn và chỉ trả về giá trị, ta chỉ việc gọi lên để sử dụng.

		Ví dụ: ABS(), GETDATE(), YEAR(), MONTH()...

	4. Câu lệnh để xử lý dữ liệu (SQL): các câu lệnh được dùng để xử lý những dữ liệu nằm trong bảng.

	5. Toán tử so sánh (Comparison Operator): =, <>, >, >=, <, <=

		- Nếu có nhiều điều kiện lọc đi kèm, có thể sử dụng thêm những toán tử luận lý (Logical Operators).

			* Biểu thức (Expression): Là sự kết hợp giữa các ký hiệu (hằng số, biến số, hàm số, dấu ngoặc, dấu chấm, dấu thay đổi độ ưu tiên...) để tạo nên một công thức toán học.
				Ví dụ: "3 + 7" sẽ là biểu thức gồm có 3 và 7 kết hợp với nhau bằng phép toán cộng.

			* Mệnh đề (Clause): Một câu phát biểu hoặc một biểu thức so sánh (+, -, >, <, =, IS...) với ý nghĩa đúng / sai.
				Ví dụ: "Số 8 là số chẵn" là một mệnh đề đúng.

		- Đặc biệt, để thay thế cho toán tử khác (<>) với nhiệm vụ đảo ngược một điều đang diễn ra, ta có thể sử dụng đảo mệnh đề bằng toán tử NOT.
			+ Toán tử NOT sẽ thường đi kèm với mệnh đề.

	-> Cuối cùng vẫn chỉ trả về dữ liệu thô.

------------------------------------------------------------

* Phân loại HQTCSDL:

	1. Dựa trên mô hình dữ liệu: Song hành với sự ra đời và phát triển của công nghệ thông tin, được phân chia thành các thế hệ dựa theo cấu trúc dữ liệu trong CSDL.

		- Thế hệ đầu tiên:
			+ Hệ thống CSDL phân cấp (Hierarchical).
			+ Hệ thống CSDL mạng (Network).

		- Thế hệ thứ hai:
			+ Hệ thống CSDL quan hệ (Relational).

		- Thế hệ thứ ba:
			+ Hệ thống CSDL hướng đối tượng (Object-Oriented).

	2. Dựa trên số người dùng: HQTCSDL có thể được phân loại dựa trên số lượng người dùng mà nó hỗ trợ.
		- Hệ thống đơn người dùng (Single-user): Hỗ trợ một người dùng tại một thời điểm.
		- Hệ thống đa người dùng (Multi-user): Hỗ trợ nhiều người dùng đồng thời.

	3. Dựa trên vị trí đặt (phân phối) hệ thống:
		- Hệ thống tập trung (Centralized): CSDL và HQTCSDL được tập trung tại một nơi để những ứng dụng khác cùng sử dụng.
		- Hệ thống phân tán (Distributed): CSDL và HQTCSDL được phân tán khắp nơi và kết nối bằng mạng máy tính.
		- Hệ thống phân tán đồng nhất (Homogeneous Distributed): Các ứng dụng sẽ sử dụng cùng một HQTCSDL.
		- Hệ thống phân tán không đồng nhất (Heterogeneous Distributed): Các ứng dụng sẽ sử dụng các HQTCSDL khác nhau, nhưng sẽ có chung một ứng dụng để trao đổi dữ liệu.

Tuỳ thuộc vào dữ liệu, loại ngôn ngữ lập trình và ứng dụng mà sẽ có một hệ cơ sở dữ liệu tương ứng.
	- Vì hệ cơ sở dữ liệu sẽ quyết định hình thức lưu trữ dữ liệu và quyết định cơ chế mà ứng dụng sẽ tương tác với cơ sở dữ liệu.

--------------------------------------------------------------------------------

* Hệ cơ sở dữ liệu (Database System) = (Cơ sở dữ liệu + HQTCSDL + Ứng dụng) + Người dùng CSDL.

--------------------------------------------------------------------------------

* Ngôn ngữ thủ tục (Procedural Language): Thường để ám chỉ các ngôn ngữ lập trình khi người dùng phải chỉ định cả WHAT (yêu cầu) và HOW (các bước thực hiện).
	- Các bước đã thiết kế sẽ được thực thi tuần tự.
	- Được thiết kế như thế nào thì sẽ tự thực thi đúng như vậy, không thể tự phát sinh thêm các bước nếu không được con người thiết kế.
	- Mục đích là để giải quyết các yêu cầu đã đề ra.

	Ví dụ: Các bước để tính giai thừa bằng ngôn ngữ C.

		int main() {

			// Bước 1: Nhập một số nguyên dương n từ bàn phím.
			int n;
			printf("Hay nhap mot so nguyen duong: ");
			scanf("%d", &n);

			// Bước 2: Bắt đầu tính giai thừa.
			int acc = 1;

			// 2.1. Kiểm tra điều kiện đặc biệt
			if (n == 0 || n == 1)
				return 1;

			// 2.2. Sử dụng vòng lặp từ 2..n để tính giai thừa
			for (int i = 2; i <= n; i++)
				acc *= i;
			
			// Bước 3: Hiển thị kết quả tính.
			printf("%d! = %d\n", n, acc);

			return 0;			
		}

* Ngôn ngữ phi thủ tục (Non-procedural Language / Applicative Language / Functional Language): Người chỉ cần chỉ định WHAT (yêu cầu), không cần chỉ định HOW (các bước thực hiện).

	Ví dụ: Lấy ra danh sách sinh viên có điểm trung bình lớn hơn 7.

		SELECT name
		FROM Students
		WHERE gpa > 7;

		-> Chỉ nói nhu cầu, không chỉ cách làm.

* Ngôn ngữ dữ liệu / Ngôn ngữ cho CSDL (Database Language): Là ngôn ngữ để thiết kế cấu trúc cho CSDL, cho phép truy cập và thao tác trên dữ liệu của CSDL.
	- Là tập hợp các mệnh lệnh do HQTCSDL định nghĩa, tuỳ thuộc vào HQTCSDL mà sẽ có những tập lệnh tương ứng.
	- Chỉ những mệnh lệnh này mới được HQTCSDL thực thi.

* Ngôn ngữ quan hệ (Relational Language): Là ngôn ngữ được sử dụng để truy vấn và thao tác với dữ liệu trong CSDL quan hệ (dữ liệu trong dòng và cột của bảng).

	- Đại số quan hệ (Relational Algebra) và Phép tính quan hệ (Relational Calculus) là hai dạng chính của ngôn ngữ quan hệ.

		+ Đại số quan hệ (Relational Algebra): Được sử dụng để thực hiện các phép toán trên dữ liệu, bao gồm cả chi tiết về cách thức và thứ tự để thực hiện truy vấn.

			Ví dụ: Tìm tất cả tựa sách xuất bản năm 2000.
				π (Book name) ( σ (yr_pub = 2000) (book) )

		+ Phép tính quan hệ (Relational Calculus): Được sử dụng để mô tả điều kiện cụ thể mà dữ liệu cần thỏa mãn để trích xuất, không quan tâm thứ tự thực hiện truy xuất mà chỉ quan tâm kết quả.

			Ví dụ: Tìm tất cả tựa sách xuất bản năm 2000.
				S = { t | ∃ u ∈  book (t[book name] = u[book name]) ∧ (u[yr_pub] = 2000 ) }

	- Giúp phân rã các yêu cầu của người dùng và hướng dẫn HQTCSDL thực hiện chúng.

------------------------------------------------------------

* Structured Query Language (SQL): Là một trong những ngôn ngữ truy vấn (hỏi/đáp, thao tác) cơ sở dữ liệu quan hệ phổ biến nhất, được sáng chế bởi IBM vào những năm 1970.

	- Là ngôn ngữ được sử dụng rộng rãi để quản lý cơ sở dữ liệu quan hệ.
		+ Gồm những câu lệnh cho phép tương tác với chính cấu trúc của cơ sở dữ liệu bằng các lệnh: Tạo mới, thêm-sửa, xoá... bảng (Table) và thiết lập mối quan hệ giữa các bảng.
		+ Ngoài ra, SQL còn giúp giao tiếp với Server để xem-thêm-sửa-xoá... khai thác dữ liệu bên trong các bảng của một cơ sở dữ liệu quan hệ.
		+ Và còn nhiều câu lệnh khác để thực hiện những công việc có liên quan như: gán và gỡ quyền truy cập vào dữ liệu, sao lưu và phục hồi dữ liệu,...

	- Là một ngôn ngữ dữ liệu, nhưng tuỳ thuộc vào ngữ cảnh sử dụng mà có thể là ngôn ngữ thủ tục hoặc phi thủ tục.

	- Người dùng sẽ viết những câu lệnh ở dạng văn bản, sau đó Client sẽ chịu trách nhiệm mã hoá và chuyển sang cho Server để Server xử lý và trả kết quả lại về cho người dùng.

	- Ban đầu, khi tạo ra ngôn ngữ này, IBM đặt tên nó là SEQUEL (viết hoa tất cả).
		+ Là viết tắt của cụm từ Structured English Query Language (Ngôn ngữ truy vấn tiếng Anh có cấu trúc).
		+ Cú pháp của ngôn ngữ rất giống cú pháp của tiếng Anh, nhưng nó có cấu trúc chặt chẽ hơn tiếng Anh thông thường.
		+ Khi chuẩn bị ra mắt, IBM phát hiện ra đã có một công ty khác đăng ký bản quyền cho cái tên SEQUEL rồi, nên IBM đã bỏ các nguyên âm đi và gọi ngôn ngữ của họ là SQL.

	-> Ngôn ngữ giúp giao tiếp với Database Engine.

----------------------------------------

Các câu lệnh (Command) của SQL thường được phân loại thành các nhóm ngôn ngữ:

	1. Ngôn ngữ định nghĩa dữ liệu (Data Definition Language - DDL): Là những câu lệnh cho phép tương tác trên cấu trúc của một cơ sở dữ liệu / bảng (chứ không phải dữ liệu bên trong).

		- Cho phép thay đổi cấu trúc của bảng như: thêm-sửa-xoá bảng và tạo ra các chỉ mục để hỗ trợ truy xuất dữ liệu.

		- Cho phép BDA hoặc người dùng miêu tả và đặt tên cho các thực thể, thuộc tính và các mối kết hợp cần thiết của ứng dụng.

		- Ngoài ra, DDL còn được dùng để tạo ra sự toàn vẹn trong kết hợp dữ liệu (Associated Integrity) và sự ràng buộc an toàn dữ liệu (Security Constraint).

			Ví dụ: Các ràng buộc.
				- Điểm của sinh viên phải từ 0..10.
				- Giới tính chỉ có ba giá trị.
				- Một khách chỉ được phép chuyển tiền 10 lần/ngày.

		- Có thể tưởng tượng rằng đây là những câu lệnh để tạo lớp (Class) trong lập trình hướng đối tượng (Object Oriented Programming - OOP).

		-> Tương tác ở mức toàn bảng / cơ sở dữ liệu.

		- CREATE: Tạo mới một bảng / CSDL (chưa có dữ liệu bên trong).
		- DROP: Xoá một bảng / CSDL (kèm những dữ liệu bên trong).
		- ALTER: Chỉnh sửa lại cấu trúc của một bảng / CSDL (thường là cột thuộc tính).
		- TRUNCATE: Xóa tất cả hàng khỏi bảng và giải phóng không gian chứa bảng / CSDL.
		- RENAME: Thay đổi tên của bảng / CSDL.

	2. Ngôn ngữ truy vấn dữ liệu (Data Query Language - DQL): Câu lệnh cho phép lấy dữ liệu từ cơ sở dữ liệu sẵn có và thao tác với dữ liệu lấy được mà không làm ảnh hưởng đến dữ liệu gốc, vì kết quả đã được biên dịch thành một bảng tạm khác.
		-> Chỉ xem nội dung bên trong bảng.

		- SELECT: Lấy dữ liệu lên để tính toán hoặc chỉ đơn giản là hiển thị ra bên ngoài.

	3. Ngôn ngữ thao tác dữ liệu (Data Manipulation Language - DML): Là những câu lệnh cho phép thao tác với dữ liệu trong cơ sở dữ liệu.
		- Là ngôn ngữ phi thủ tục (Non-procedural), cho phép người dùng chỉ cần đưa ra yêu cầu, còn chi tiết cách thực hiện sẽ do HQTCSDL lo (trái ngược với ngôn ngữ lập trình khi các lập trình viên phải hướng dẫn từng bước cho máy tính).
		- Đối với những hành động thường xuyên lặp lại, DML cũng cho phép thiết kế các thủ tục / hàm (Stored Procedure) để nhanh chóng tương tác với CSDL.
		- 
		-> Tương tác ở mức bên trong bảng.

		- INSERT: Chèn thêm một dòng dữ liệu vào bảng.
		- UPDATE: Cập nhật hoặc sửa đổi giá trị của một cột trong bảng.
		- DELETE: Xoá một dòng dữ liệu khỏi bảng.
		- CALL: Câu lệnh liên quan đến lập trình, có nhiệm vụ gọi một hàm của cơ sở dữ liệu.
		- EXPLAIN CALL

	4. Ngôn ngữ điều khiển dữ liệu (Data Control Language - DCL): Là những câu lệnh cấu hình và phân quyền, thường được những DBA sử dụng để giới hạn quyền thao tác trên dữ liệu của người dùng (tác động lên 3 ngôn ngữ DDL, DQL và DML).

		- GRAND: Trao quyền cho người dùng.
		- REVOKE: Thu hồi quyền đã trao cho người dùng.

	5. Ngôn ngữ kiểm soát giao tác trên CSDL (Transaction Control Language - TCL): Là những câu lệnh cho phép trao đổi, thay đổi trạng thái của một số dữ liệu, kiểm soát việc xử lý các giao tác trong CSDL.

		- COMMIT: Lưu tất cả các thao tác khi thực hiện trên CSDL.
		- SAVEPOINT
		- ROLLBACK
		- SET TRANSACTION
		- SET CONSTRAINT

(* Tham khảo thêm: https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/)

------------------------------------------------------------

* Đại số quan hệ (Relational Algebra - RA): Là mô hình toán học, lý thuyết chạy ngầm đằng sau Database Engine, giúp hiện thực hoá các câu lệnh SQL.

	- Chỉ hoạt động trên giấy, không thể hoạt động trên máy tính.

	- Bao gồm những phép toán để xử lý dữ liệu.

	- Thuật toán của đại số quan hệ chính là các câu lệnh SQL.

	- Toàn bộ dữ liệu sẽ được lưu trữ ở dạng tập hợp các bit nhị phân, do Database Engine thực hiện bằng toán học.

		Ví dụ:
			- Câu lệnh WHERE trong SQL -> Phép chọn (σ) trong Đại số quan hệ
			- Câu lệnh SELECT trong SQL -> Phép chiếu (π) trong Đại số quan hệ

------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Đại số quan hệ cung cấp "lý thuyết" toán học,		│
│	mô tả trừu tượng cách truy vấn và thao tác dữ liệu	│
│								│
│	SQL là ngôn ngữ truy vấn cụ thể để "thực hành" truy vấn,│
│	dựa trên các nguyên tắc của Đại số quan hệ		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

Về bản chất, vì cơ sở dữ liệu sẽ không có giao diện và chỉ hoạt động ngầm (background) để cung cấp tính năng / dịch vụ (Service) cho một nơi khác để sử dụng, nên ta hoàn toàn có thể tương tác dưới dạng thô / nguyên thuỷ thông qua một công cụ với giao diện đồ hoạ người dùng (GUI).

	- Dữ liệu trên ổ cứng dữ sẽ được lưu dưới dạng nhị phân, sau đó sử dụng một công cụ (Client tool) để hiển thị dưới dạng bảng (Table) và cho phép tương tác thông qua những câu lệnh SQL.

	- Toàn bộ những câu lệnh sẽ được công cụ đồ hoạ (Client) gửi lên Server ngầm (hoạt động ở chế độ dịch vụ - Service) để Server xử lý và trả về kết quả.

		Ví dụ:
			1. Tạo mới một truy vấn bằng nút [New Query]
			2. Thực thi câu lệnh, chẳng hạn như chọn cơ sở dữ liệu: USE tên-cơ-sở-dữ-liệu
			3. Nhấn nút thực thi [Execute]

	- Server sẽ có nhiệm vụ quản lý và chuyển những dữ liệu ở dạng thô thành dạng đẹp, sau đó cung cấp cho ngôn ngữ lập trình để cuối cùng hiển thị ra giao diện cho người dùng.

	-> Thao tác với dữ liệu ở dạng thô, không bị che / ẩn giấu bởi những giao diện người dùng (GUI).

==========================================================================================
==========================================================================================
==========================================================================================

[BÊN TRONG MỘT HỆ QUẢN TRỊ CƠ SỞ DỮ LIỆU - DATABASE ENGINE INSIDE]

Các thành phần của một HQTCSDL, cụ thể là Microsoft SQL Server:
	- Ngôn ngữ giao tiếp giữa người dùng và CSDL.
	- Database: Là một dịch vụ (Servcie) chạy ngầm trong Windows (MSSQLSERVER), cho phép tạo CSDL và thực hiện truy vấn.
	- Data Communication: Cho phép truyền dữ liệu giữa các máy.
	- Database Dictionary: Cho phép định nghĩa và xem từ điển của CSDL.

--------------------------------------------------------------------------------

Kiến trúc 3 mức ANSI-SPARC (ANSI-SPARC Three-level architecture) trong các HQTCSDL.
	- Được đề xuất lần đầu vào năm 1975, được đặt tên theo tiêu chuẩn của Viện Tiêu chuẩn Quốc gia Hoa Kỳ (American National Standards Institute - ANSI) và Hội nghị Các nhà nghiên cứu về Hệ thống Cơ sở dữ liệu và Ứng dụng (Standards Planning And Requirements Committee - SPARC).
	- Giúp mọi người dùng đều có thể truy xuất được dữ liệu như nhau.
	- Góc nhìn (View) của người dùng này không bị thay đổi khi các góc nhìn khác bị thay đổi.
	- Người dùng chỉ cần biết cách sử dụng, không cần biết chi tiết cách CSDL được lưu trữ (mức vật lý, được người thiết kế CSDL xây dựng nên).
		+ Người quản trị CSDL (BDA) có thể thay đổi cấu trúc lưu trữ CSDL (cấu trúc mức ý niệm) mà không làm ảnh hưởng đến góc nhìn của người dùng.
		+ Cấu trúc mức trong của CSDL không bị ảnh hưởng bởi sự thay đổi các yếu tố mức vật lý.

	-> Tăng khả năng độc lập dữ liệu, tách biệt giao diện người dùng với cách cơ sở dữ liệu được biểu diễn vật lý.

------------------------------------------------------------

Kiến trúc này bao gồm ba mức để biểu diễn một CSDL:

	1. Mức ngoài (External Level / View Level).
		- Đây là mức giao diện người dùng / nhóm người dùng.
			+ Thể hiện quan điểm của người dùng về CSDL (người dùng quan tâm đến phần dữ liệu nào trong CSDL).
			+ Bao gồm các góc nhìn (View) của người dùng, nơi người dùng tương tác với hệ thống.
		- Miêu tả từng phần của CSDL có liên quan đến từng người dùng và những dữ liệu ấy giống thế giới thực đến mức nào.
		- Chỉ hiển thị phần dữ liệu mà người dùng cần, không hiển thị toàn bộ dữ liệu trong CSDL.
		- Không đi vào chi tiết về cấu trúc tổ chức, mối quan hệ của dữ liệu, kiểu dữ liệu,... (che giấu đi những phần còn lại của CSDL).

		-> Dữ liệu hiển thị ra cho người dùng như thế nào.

		Ví dụ 1: Tuy giảng viên có rất nhiều thông tin (mã, tên, năm sinh, quê quán, số điện thoại, email, bằng cấp, bậc lương, số năm kinh nghiệm,...), nhưng dưới góc nhìn của một sinh viên, chỉ một số thông tin được hiển thị (mã, tên, email).

		Ví dụ 2: Để tiện cho việc xem thông tin, tuổi sẽ được tính toán và hiển thị đối với người dùng, nhưng khi lưu trong CSDL thì chỉ lưu ngày-tháng-năm sinh.

	2. Mức ý niệm / Mức luận lý (Conceptual Level / Logic Level).
		- Là một góc nhìn (View) tổng quát cho cả CSDL, miêu tả tổng quát (trừu tượng) dữ liệu gì được lưu trong CSDL và mối quan hệ giữa các dữ liệu đó ra sao.
		- Là một lược đồ liệt kê tất cả các thuộc tính (dữ liệu) cần lưu trữ và quan hệ giữa chúng, chưa bao gồm kiểu dữ liệu.

		-> Dữ liệu nào cần lưu trữ và liên quan đến nhau như thế nào.

	3. Mức trong / Mức vật lý (Internal Level / Physical Level).
		- Là sự thể hiện ở mức vật lý của CSDL trên máy tính, miêu tả chi tiết dữ liệu được lưu trữ và tổ chức như thế nào trên thiết bị lưu trữ vật lý.
		- Là các thuộc tính (dữ liệu) đi kèm với kiểu dữ liệu.
		- Giúp xác định các phương pháp tiếp cận, cách tổ chức tệp, cách truy xuất (tuần tự hay ngẫu nhiên), phương pháp lập chỉ mục và cấu trúc lưu trữ được sử dụng để tối ưu hóa hiệu suất truy xuất dữ liệu.
		- Tuỳ thuộc vào hệ quản trị CSDL mà sẽ có ngôn ngữ dữ liệu tương ứng.

		-> Cơ sở dữ liệu được lưu trữ và truy xuất trong máy tính như thế nào.

--------------------------------------------------------------------------------

* Mô hình dữ liệu (Data Model) / Cấu trúc dữ liệu (Data Structure): Là sơ đồ (tập khái niệm và ký hiệu) về cách thức tổ chức, lưu trữ và truy xuất dữ liệu, các mối quan hệ và các ràng buộc giữa các dữ liệu.

	- Được xây dựng trong giai đoạn thiết kế dữ liệu (có thể thực hiện trước hoặc sau khi chọn HQTCSDL), sau khi nhận được yêu cầu phần mềm từ các bên có liên quan.

	- Sau đó, dữ liệu sẽ được biểu diễn dưới dạng sơ đồ và các kí hiệu nhờ vào quá trình mô hình hoá dữ liệu (Data Modeling).
		+ Chỉ biểu diễn ở mức trừu tượng, không đi vào chi tiết.
		+ Để vẽ được sơ đồ, ngoài các kí hiệu, ta còn cần thêm một bộ quy tắc để kết hợp các kí hiệu lại với nhau.

	- Việc mô hình hoá dữ liệu (Data Modeling) giúp xác định:

		+ Dữ liệu có trong CSDL.
			Ví dụ: Các thực thể: sinh viên, giảng viên, khóa học, môn học,...

		+ Mối quan hệ giữa các thực thể.
			Ví dụ:
				- Sinh viên được giảng viên giám sát.
				- Giảng viên giảng dạy các khóa học.

		+ Các ràng buộc về dữ liệu.
			Ví dụ:
				- Mã số sinh viên có chính xác tám chữ số.
				- Một môn học sẽ có ba, bốn hoặc tám đơn vị tín chỉ.

	- Biểu diễn dữ liệu theo cách dễ hiểu nhất để nhìn vào mô hình là biết dữ liệu sẽ được tổ chức như thế nào trong CSDL và được lưu trữ thực tế như thế nào trên máy tính.
		+ Giúp đánh giá sự thiếu/đủ của dữ liệu được thiết kế so với yêu cầu của khách hàng.
		+ Giúp hình dung nhanh những dữ liệu sẽ có trong hệ thống và tránh những tổn thất lớn khi CSDL được đưa vào vận hành thật sự.

	- HQTCSDL sẽ sử dụng mô hình dữ liệu để tạo và quản lý CSDL theo các quy tắc được xác định trong mô hình.

	-> Quá trình tìm hiểu cấu trúc và mối quan hệ của dữ liệu.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Mô hình dữ liệu giúp hiểu rõ cấu trúc dữ liệu	│
│	và quan hệ giữa các phần tử trong CSDL		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------------------------------------

Một mô hình dữ liệu sẽ gồm 3 thành phần:
	1. Cấu trúc (Structure) của dữ liệu: CSDL được tổ chức từ các thành phần nào.
	2. Ràng buộc (Constraint) giữa các dữ liệu: Đảm bảo dữ liệu không bị sai sót.
	3. Phép toán xử lý (Operation) trên dữ liệu: Những thao tác trên dữ liệu.

------------------------------------------------------------

Có 3 loại mô hình dữ liệu khác nhau trong xây dựng hệ CSDL (Database System): Mỗi loại tương ứng với một giai đoạn, cố gắng đưa CSDL đến gần hơn với thực tế.

	1. Mô hình dữ liệu ý tưởng / ý niệm / quan niệm / khái niệm (Conceptual Data Model / Domain Model): Nhìn vào một vấn đề thực tế, từ những mô tả về phần mềm của khách hàng, suy ra những dữ liệu cần lưu trữ là gì bằng một sơ đồ.
		- Cho biết hệ thống chứa những dữ liệu gì (WHAT), giống như thế giới thực.
		- Là một sơ đồ tổng quát (mức trừu tượng cao nhất) khi chỉ tập trung vào thực thể và mối liên kết (có thể có hoặc không có thuộc tính của thực thể).
		- Sau này, chỉ cần nhìn vào sơ đồ thay vì phải liên ục đọc lại yêu cầu phần mềm.

		-> Tập trung vào đối tượng cần biểu diễn.

	2. Mô hình dữ liệu luận lý (Logical Data Model / Representational Data Model).
		- Cho biết hệ thống sẽ được triển khai thế nào mà chưa cần đến HQTCSDL (HOW WITHOUT DBMS).
		- Bao gồm đại số quan hệ (Relational Algebra) và phép tính quan hệ (Relational Calculus).
		- Thuộc tính của thực thể sẽ có thêm kiểu dữ liệu, miền giá trị và khoá chính.
		- Áp dụng dạng chuẩn hoá (Normalization) thứ ba - 3NF.

	3. Mô hình dữ liệu vật lý (Physical Data Model): Mô tả cách mà hệ thống dữ liệu được triển khai bằng một HQTCSDL.
		- Cho biết hệ thống thực sự được triển khai như thế nào và dữ liệu sẽ được lưu trữ bằng HQTCSDL (HOW WITH DBMS).
		- Để máy tính có thể hiểu được, cần tiếp tục chuyển thành những sơ đồ ở mức vật lý.
		- Cho biết dữ liệu được triển khai, lưu trữ thực tế trong máy tính như thế nào.
		- Cồn một HQTCSDL cụ thể.

		-> Tập trung vào cách thức biểu diễn.

	-> Cho thấy dữ liệu được biểu diễn từ nhiều góc độ khác nhau.

	* Bảng so sánh (chỉ mang tính tương đối, vì mỗi nơi lại đang có một cách định nghĩa khác nhau về 3 loại mô hình dữ liệu).

	-------------------------------------------------------------------------
	|			|  Ý niệm	|    Luận lý	|   Vật lý	|
	|-----------------------------------------------------------------------|
	| Thực thể		|	x	|	x	| Được thay bằng|
	|			|		|		| tên bảng	|
	|-----------------------|---------------|---------------|---------------|
	| Mối kết hợp		|	x	|	x	| Bảng trung 	|
	|			|		|		| gian nếu n-n	|
	|-----------------------|---------------|---------------|---------------|
	| Thuộc tính		|      [x]	|	x	| Được thay bằng|
	|			|		|		| tên cột	|
	|-----------------------|---------------|---------------|---------------|
	| Khoá chính		|      [x]	|	x	|	x	|
	|-----------------------|---------------|---------------|---------------|
	| Khoá ngoại		|		|      [x]	|	x	|
	|-----------------------|---------------|---------------|---------------|
	| Kiểu dữ liệu của tt	|		|		|	x	|
	-------------------------------------------------------------------------

		(Cặp dấu "[]" đại diện cho việc có hoặc không, tuỳ theo cách nhìn nhận của từng tác giả.)

------------------------------------------------------------

Lập mô hình dữ liệu (trong HQTCSDL quan hệ):

	- Mô hình dữ liệu thực thể - mối kết hợp (Entity-Relationship Data Model - E-R Model).
		+ Thường được gọi tắt là "mô hình thực thể kết hợp".
		+ Được đề xuất bởi Peter Pin-Shan Chen (Peter Chen / PP Chen) vào năm 1976.
		+ Tồn tại ở mức ý niệm (Conceptual).
		+ Được xây dựng dựa trên việc nhận thức thế giới thực thông qua tập các đối tượng (được gọi là các thực thể), các thuộc tính của đối tượng và các mối quan hệ giữa các đối tượng này.
		+ Từ đó xây dựng nên mô hình dưới dạng đồ thị vô hướng (không có các đường mũi tên để chỉ hướng).
		+ Giúp phân tích dữ liệu, xác định các đơn vị thông tin cơ bản cần thiết của tổ chức, mô tả cấu trúc và mối liên hệ giữa chúng.

		-> Cho một cái nhìn tổng quan về CSDL mà không cần phải xây dựng CSDL.

		(* Lưu ý: Trong E-R Model, Relationship sẽ được dịch là "mối kết hợp" để tránh nhầm lẫn với Relational trong R Model khi cũng có nghĩa là "mối quan hệ".)

	- Mô hình dữ liệu quan hệ (Relational Data Model - R Model).
		+ Thường được gọi tắt là "mô hình quan hệ".
		+ Được đề xuất bởi Edgar Frank "Ted" Codd (Edgar F. Codd / EF Codd) vào năm 1970.
		+ Tồn tại ở mức luận lý (Logical).
		+ Được xây dựng dựa trên lý thuyết về tập hợp và quan hệ, các phép toán thao tác với dữ liệu được mô tả bằng ĐSQH.
		+ Thay vì chỉ sử dụng những hình vẽ với một bộ kí hiệu được quy ước riêng, ta sử dụng các bảng để biểu diễn thông tin và mối quan hệ giữa chúng (và nhiều bảng sẽ tạo thành một CSDL).
		+ Mỗi bảng tượng trưng cho một thực thể, cho phép trực tiếp hình dung được các câu lệnh (các cách) để thao tác với dữ liệu.
		+ Các ràng buộc:
			1. Ràng buộc trên dữ liệu: Ràng buộc về kiểu dữ liệu, miền giá trị tối thiểu và tối đa,...
			2. Ràng buộc về tổ chức dữ liệu: Nếu có dữ liệu trong bảng này thì phải tồn tại trong bảng khác,...

		-> Dựa vào cách quản lý trong thực tế.

		(CSDL được tổ chức theo mô hình quan hệ được gọi là CSDL quan hệ - Relational Database, phần mềm sử dụng để duy trì CSDL quan hệ là HQTCSDL quan hệ - RDBMS.)

==========================================================================================
==========================================================================================
==========================================================================================

[THIẾT KẾ CƠ SỞ DỮ LIỆU - DATABASE DESIGN]

Có nhiều giai đoạn trong quá trình thiết kế cơ sở dữ liệu, mỗi giai đoạn có những mô hình dữ liệu (ý niệm, luận lý và vật lý) tương ứng.

Mục đích thiết kế:
	- Đáp ứng được các yêu cầu của người dùng.
	- Cung cấp cấu trúc thông tin hợp lý và hiệu quả cho quá trình hoạt động của ứng dụng.
	- Hỗ trợ được tất cả các yêu cầu của chương trình trong quá trình vận hành.

--------------------------------------------------------------------------------

* Vòng đời phát triển CSDL (Database Life Cycle): Các bước phải trải qua để có được một CSDL.

------------------------------------------------------------

	1. Thu thập và phân tích yêu cầu (Requirements Gathering / Problem Defined): Kỹ thuật lấy yêu cầu của một bài toán (nghiệp vụ) trong thực tế từ phía khách hàng để bắt đầu phân tích yêu cầu.

		- Khách hàng có thể cung cấp những thông tin gì về nghiệp vụ để biết hệ thống yêu cầu có những tính năng gì và cần lưu trữ những dữ liệu gì.
			+ Mục tiêu là cố gắng thu thập sao cho đúng nhất với những vận hành thực tế của khách hàng.
			+ Có được càng nhiều thông tin thì sẽ càng dễ dàng cho các bước thiết kế ở phía sau.

		- Sau đó chọn lọc thông tin và trao đổi lại với khách hàng (nếu cần) để:
			+ Xác định được những thực thể và thuộc tính của thực thể.
			+ Xác định mối quan hệ giữa các thực thể và thuộc tính của những mối kết hợp (nếu có).

------------------------------------------------------------

	2. Thiết kế ở mức trừu tượng (Conceptual Design): Vẽ những sơ đồ ở mức độ ý niệm.

		- Nguyên tắc của những công trình lớn là luôn luôn phải có những bảng thiết kế, giúp tách ra khỏi những gì cụ thể.

		- Biểu diễn lại những yêu cầu phức tạp về dữ liệu bằng một loại sơ đồ.
			+ Gom những gì chung nhất của các thực thể thành một giàn khung.
			+ Không nhất thiết phải có kiểu dữ liệu, kiểu dữ liệu chỉ cần khi bắt đầu thiết kế CSDL ở mức vật lý hoặc khi bắt đầu lập trình.

		- Được sử dụng để trao đổi giữa người thiết kế và khách hàng (người dùng).
			+ Sơ đồ này sẽ không bao gồm những chi tiết liên quan đến kĩ thuật để các bên có liên quan có thể đọc được.
			+ Đảm bảo rằng người thiết kế đã nắm được đầy đủ các thực thể, thuộc tính và mối quan hệ cần lưu trữ.

------------------------------------------------------------

	3. Logical Design (Data Model Mapping) & Implementation: Hiện thực hoá các sơ đồ ý tưởng thành các sơ đồ mức luận lý, sau đó chuyển đổi thành các câu lệnh (bảng trong cơ sở dữ liệu).

		- Các hệ quản trị khác nhau có thể sẽ có khác nhau đôi chút về cú pháp để tạo dựng giàn khung lưu trữ dữ liệu, nhưng các khái niệm thì vẫn không thay đổi.

		- Mô tả những dữ liệu nào sẽ được lưu trữ trong cơ sở dữ liệu. Bao gồm các thuộc tính, kiểu dữ liệu và mối quan hệ của chúng với nhau.

		- Để xử lý, Database Engine sẽ chuyển các câu lệnh thành mô hình toán học - ĐSQH.

		- Sử dụng ngôn ngữ truy vấn cơ sở dữ liệu (ví dụ: SQL) để tạo bảng và chỉnh sửa cấu trúc cơ sở dữ liệu.

------------------------------------------------------------

	4. Execution / Populating: Đưa dữ liệu vào, thực thi các thiết kế để cho ra được kết quả.

==========================================================================================

[PHÂN TÍCH - MỨC Ý NIỆM]

	(Thuật ngữ Diagram đôi khi còn được gọi là Schema Diagram / Scheme Diagram.)

* Lược đồ thực thể - mối kết hợp (Entity-Relationship Diagram - ERD):

	- Hay còn được biết đến là Peter Chen Notation / Crow's Foot Notation, là một tập các kí hiệu đã được quy ước sẵn.

	- Cho phép tạo nên một bản vẽ thiết kế CSDL ở mức ý niệm (trực quan hóa E-R Model), biểu diễn trừu tượng cấu trúc tổng thể của CSDL.
		+ Liệt kê danh sách các thực thể (đối tượng) cần quản lý, đi kèm với thuộc tính và mối kết hợp giữa các thực thể.
		+ Liệt kê một số ràng buộc dữ liệu đơn giản (không phải ràng buộc về kiểu dữ liệu), ví dụ: Một Sinh viên chỉ được học tối đa 2 Khoa.
		+ Không liệt kê các thao tác trên dữ liệu (hành động).

		-> Giúp xác định thực thể, thuộc tính và mối kết hợp giữa các thực thể.

	* Cấu trúc của E-R Model - Các thành phần chính:

		1. Thực thể / Đối tượng (Entity / Object): Là một đối tượng cần được lưu trữ và quản lý, đại diện cho một sự vật hoặc hiện tượng trong thế giới thực.
			- Trong sơ đồ, thường được vẽ bằng hình chữ nhật.
			- Tên của thực thể sẽ là một danh từ hoặc cụm danh từ, ví dụ: NhânViên, HoáĐơn, HồSơ, GiaoDịch,...

			(* Lưu ý: Khi vẽ sơ đồ, không liệt kê những thực thể không có thuộc tính hoặc những thực thể mà ta đang đi thiết kế ERD cho nó.)

		2. Tập thực thể / Kiểu thực thể / Lớp thực thể (Entity Set / Entity Type): Gồm nhiều đối tượng có những điểm giống nhau, tạo thành một tập thực thể chia sẻ chung đặc điểm.
			- Là khuôn mẫu để lưu trữ nhiều đối tượng cùng loại.
			- Mỗi đối tượng được tạo ra từ một tập thực thể đều sẽ có những thuộc tính giống nhau (chỉ khác giá trị bên trong thuộc tính).
			- Tương đương với lớp (Class) trong lập trình hướng đối tượng (OOP).

			Ví dụ: Từng con người tự do ngoài đời với rất nhiều thông tin khác nhau...
				- Tụ họp lại tại một nơi và chọn lọc ra những thông tin cần lưu trữ như: tên, năm sinh, quê quán, email, số điện thoại, ngày vào học, môn học, điểm số, điểm rèn luyện, học phí,...
				- Bỏ qua những thông tin không cần thiết như: chiều cao, cân nặng, nhóm máu, màu tóc, danh sách bạn bè, công việc làm thêm,...
				- Tạo thành một tập thể sinh viên của một trường học.

			(* Lưu ý: Thông thường, khái niệm về tập thực thể sẽ bị bỏ qua và sử dụng khái niệm về thực thể để thay thế.
				Tập thực thể -> Thực thể
				Từng thực thể trong tập thực thể -> Đối tượng)

		3. Thuộc tính (Attribute): Từng đặc điểm riêng biệt của một thực thể hoặc mối kết hợp, giá trị trong thuộc tính (được quy định bởi kiểu dữ liệu) sẽ giúp tạo nên sự khác biệt (đặc trưng) giữa các thực thể.
			- Trong sơ đồ, thường được vẽ bằng hình elip.
			- Tên của thuộc tính sẽ là một danh từ hoặc cụm danh từ, ví dụ: MãNhânViên, TênPhòngBan, ĐơnGiá,...

		4. Mối kết hợp / Mối liên kết / Mối liên quan / Mối quan hệ (Relationship): Mối quan hệ hai chiều giữa các thực thể với nhau.

			- Trong sơ đồ, thường được vẽ bằng hình thoi.

			- Kiểu liên kết (Type): Tên của mối kết hợp (ví dụ: <Làm việc cho>, <Thuộc>, <Có>, <Quản lý>,...).
				+ Tên của mối kết hợp phải là động từ, giới từ hoặc bổ ngữ.

			- Giữa hai thực thể, có thể có nhiều mối kết hợp khác nhau.

				Ví dụ: Thực thể NhânViên có hai mối kết hợp khác nhau với thực thể PhòngBan.
					| NhânViên |―――――< Làm việc >―――――| PhòngBan |
					| NhânViên |―――――< Là trưởng phòng >―――――| PhòngBan |

			- Đặc biệt, mặc dù chỉ là mối kết hợp, nhưng vẫn được phép có những thuộc tính riêng của mình.
				+ Thuộc tính sẽ được gắn với mối kết hợp khi nó không thể thuộc về bất kì thực thể nào khác.
				+ Thuộc tính sẽ chỉ bắt đầu phát sinh (bắt đầu có ý nghĩa) khi hai thực thể bắt đầu phát sinh mối kết hợp với nhau (khi có mối liên kết thì mới cần đến thuộc tính này).
				+ Thuộc tính này thường liên quan đến nhiều thực thể khác nhau, nên sẽ không thể thuộc về riêng thực thể nào, mà bắt buộc phải thuộc về mối liên kết giữa các thực thể.
				+ Chủ yếu diễn ra trong các mối kết hợp nhiều-nhiều.

				-> Thuộc tính bắt đầu phát sinh chỉ khi hai thực thể bắt đầu có mối kết hợp.

				Ví dụ 1: NhânViên <LàmTrưởngĐơnVị> ĐơnVị, mối kết hợp "LàmTrưởngĐơnVị" sẽ có thuộc tính đi kèm là NgàyKíQuyếtĐịnh.
					- Thuộc tính NgàyKíQuyếtĐịnh chỉ bắt đầu có ý nghĩa khi NhânViên thực sự LàmTrưởngĐơnVị trong ĐơnVị (khi nhân viên bắt đầu được bổ nhiệm chức vụ).
					- Nếu NhânViên không LàmTrưởngĐơnVị trong ĐơnVị thì thuộc tính này sẽ không tồn tại.
					-> NgàyKíQuyếtĐịnh không thể thuộc về NhânViên hay ĐơnVị.

				Ví dụ 2: NhânViên <ThamGia> DựÁn, mối kết hợp "ThamGia" sẽ có thuộc tính đi kèm là SốGiờLàmViệc.
					- Thuộc tính SốGiờLàmViệc chỉ bắt đầu có ý nghĩa khi NhânViên thực sự ThamGia trong DựÁn (khi nhân viên bắt đầu được phân công vị trí công việc).
					- Nếu NhânViên không ThamGia trong DựÁn thì thuộc tính này sẽ không tồn tại.
					-> SốGiờLàmViệc không thể thuộc về NhânViên hay DựÁn.

				Ví dụ 3: Sách <Thuộc> PhiếuMượnSách, mối kết hợp "Thuộc" sẽ có thuộc tính đi kèm là NgàyTrảSách.
					- Thuộc tính NgàyTrảSách chỉ bắt đầu có ý nghĩa khi Sách thực sự Thuộc vào PhiếuMượnSách (khi có người bắt đầu mượn sách).
					- Nếu Sách không Thuộc vào PhiếuMượnSách thì thuộc tính này sẽ không tồn tại.
					-> NgàyTrảSách không thể thuộc về Sách hay PhiếuMượnSách.

				Ví dụ 4: SinhViên <LàmLớpTrưởng> LớpHọc, mối kết hợp "LàmLớpTrưởng" sẽ có thuộc tính đi kèm là NgàyNhậnChức.
					- Thuộc tính NgàyNhậnChức chỉ bắt đầu có ý nghĩa khi SinhViên thực sự LàmLớpTrưởng trong LớpHọc (khi sinh viên bắt đầu được bầu làm ban cán sự lớp).
					- Nếu SinhViên không LàmLớpTrưởng trong LớpHọc thì thuộc tính này sẽ không tồn tại.
					-> NgàyNhậnChức không thể thuộc về SinhViên hay LớpHọc.

		5. Thực thể kết hợp (Associative Entity): Là trường hợp đặc biệt khi đối tượng vừa là thực thể, vừa là mối kết hợp.
			- Mỗi lần hai thực thể liên kết với nhau sẽ phát sinh ra một mối kết hợp (chứa các thuộc tính gắn liền với hai thực thể).
				+ Nhưng mối kết hợp này lại đóng vai trò như thực thể.
				+ Thực thể ở đây là những thứ hữu hình, có thể cầm/ nắm trên tay được; trong khi mối kết hợp là những thứ vô hình, chỉ nằm ở mức ý tưởng (trừu tượng).
				+ Vì là thực thể nên được phép có thuộc tính riêng, đặc biệt là có khoá định danh.
			- Trong sơ đồ, thường được vẽ bằng hình chữ nhật, nhưng có thêm hình thoi bên trong.

			Ví dụ: Các nhân viên trong một công ty được phép tham gia các khoá học bên ngoài để hỗ trợ cho quá trình làm việc.

						n		 n
				| NhânViên |―――――| < ChứngChỉ > |―――――| KhoáHọc |
						     |      |
					    (M̲ã̲C̲h̲ứ̲n̲g̲C̲h̲ỉ̲)  (NgàyHoànThành)

				- Một nhân viên được phép tham gia nhiều khoá học.
					+ Mỗi khoá học cũng cho phép có nhiều nhân viên tham gia.
					+ Mỗi lần tham gia sẽ được cấp một chứng chỉ.
				- Chứng chỉ là một đối tượng cụ thể, có những thuộc tính riêng.
				- Mỗi lần học viên tham gia khoá học sẽ được cấp một chứng chỉ, mỗi chứng chỉ sẽ có một mã chứng chỉ riêng.

				-> Mỗi lần có mối kết hợp sẽ phát sinh ra một thực thể.
					(Nhân viên tham gia khoá học sẽ phát sinh chứng chỉ.)

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Sơ đồ để thiết kế cơ sở dữ liệu, phác thảo về cách lưu trữ dữ liệu.	│
│	Mô hình hoá những thực thể, thuộc tính và các mối liên kết giữa chúng	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

* Lưu ý 1: Peter Chen là người đầu tiên giới thiệu các kí hiệu của ERD vào năm 1976.

	- Tuy nhiên, sau đó đã có một số kí hiệu khác được phát triển để biểu diễn ERD:
		+ Bộ kí hiệu "chân quạ" (Crow's foot) của Gordon Everest.
		+ Bộ kí hiệu của Charles Bachman.
		+ Bộ kí hiệu Richard Barker.
		+ ...

	- Ngoài ra, để biểu diễn phần trọng số (Cardinality) của các mối kết hợp.
		+ Ta còn có thể sử dụng bộ kí hiệu cặp số nhỏ nhất-lớn nhất (Min-Max) để thay thế cho các bộ kí hiệu truyền thông của Peter Chen, Gordon Everest,...
		+ Min-Max cho phép chỉ định rõ số lượng đối tượng tham gia vào mối kết hợp (ví dụ: mỗi lớp học có tối thiểu 30 và tối đa là 80 sinh viên,...).

	- Trong ghi chú này, để tiện cho việc vẽ hình.
		+ Đa phần các kí hiệu thực thể, thuộc tính, mối kết hợp và những khái niệm liên quan sẽ được minh hoạ bằng bộ kí hiệu gốc của Peter Chen.
		+ Các kí hiệu về trọng số sẽ được HIỂU theo bộ kí hiệu chân quạ của Gordon Everest.
		+ Nhưng lại được VẼ bằng kí hiệu min-max, nên các kí hiệu min-max trong ghi chú này đều bị vẽ ngược.

		-> Đọc và hiểu theo "chân quạ" nhưng lại được vẽ bằng "min-max".
	
	(* Tham khảo sự khác nhau giữa các bộ kí hiệu:
		- https://opendsa-server.cs.vt.edu/ODSA/Books/Database/html/ERDNotations.html
		- https://michael-fuchs-sql.netlify.app/2021/03/03/entity-relationship-diagram-erd/
		- https://viblo.asia/p/hieu-va-phan-biet-3-loai-erd-notation-thuong-gap-6J3ZgpPBlmB)


* Lưu ý 2: Về cách đọc (dành cho bộ kí hiệu chân quạ), ta có hai cách đọc khác nhau.

	| E1 |―――(c1)―――――< R >―――――(c2)―――| E2 |

	* Cách đọc 1: Theo tự nhiên, bắt đầu bằng một đối tượng trong thực thể, sau đó nhảy sang trọng số phía đối diện.
		E1 -> R -> c2 -> E2

	* Cách đọc 2: Chỉ dành cho Min-Max, bắt đầu bằng một đối tượng trong thực thể, sau đó sử dụng cặp trọng số ngay bên cạnh mình.
		E1 -> R -> c1 -> E2

	* Cách đọc 3: Tác giả TỰ CHẾ, bắt đầu bằng cặp trọng số gắn liền với thực thể.
		c1 -> E1 -> R -> E2

	Ví dụ 1:
		| BácSĩ |―――(1)―――――< Chăm sóc >―――――(n)―――| BệnhNhân |

		* Cách đọc 1: 
			- Mỗi bác sĩ chăm sóc cho nhiều bệnh nhân.
			- Mỗi bệnh nhân được chăm sóc bởi 1 bác sĩ.

		* Cách đọc 3: 
			- Có 1 bác sĩ chăm sóc cho một bệnh nhân.
			- Có nhiều bệnh nhân được một bác sĩ chăm sóc.

	Ví dụ 2:
		| BácSĩ |―――(0, n)―――――< Chăm sóc >―――――(1, 1)―――| BệnhNhân |

		* Cách đọc 2: 
			- Mỗi bác sĩ chăm sóc cho 0 hoặc nhiều bệnh nhân.
			- Mỗi bệnh nhân được chăm sóc bởi 1 và chỉ 1 bác sĩ.

--------------------------------------------------------------------------------

[PHÂN LOẠI CÁC THÀNH PHẦN CỦA ERD]

* Thực thể - Phân loại thực thể theo khoá:

	1. Thực thể mạnh (Strong Entity):
		- Có thể tồn tại độc lập cùng với những thực thể khác.
		- Yêu cầu phải có ít nhất một thuộc tính để làm khoá.

	2. Thực thể yếu (Weak Entity): Tồn tại phụ thuộc vào một kiểu thực thể mạnh khác.

		- Không thể tồn tại độc lập mà phải chỉ rõ đang phụ thuộc vào thực thể mạnh nào (yêu cầu thực thể khác phải tồn tại để mình được tồn tại).

		- Trong trường hợp này, thực thể mạnh còn được gọi là thực thể sở hữu (Owner Entity / Dominant Entity), còn thực thể yếu được gọi là thực thể phụ thuộc (Dependent Entity / Subordinate Entity).

		- Không thể xác định được thuộc tính để làm khoá vì thực thể yếu đang phụ thuộc vào một thực thể khác, mà thay vào đó sẽ xác định thông qua một bộ thuộc tính định danh (Identifier / Key).
			+ Định danh riêng phần (Partial Identifier / Partial Key / Discriminator): Là những thuộc tính riêng của thực thể yếu, giúp xác định thực thể yếu, nhưng chỉ là trong phạm vi của thực thể mạnh mà nó đang phụ thuộc, nghĩa là vẫn có nguy cơ bị trùng với những thực thể khác trong lược đồ.
			+ Định danh đầy đủ (Full Identifier): Định danh riêng phần của thực thể yếu sẽ kết hợp với định danh riêng của thực thể mạnh để tạo ra một định danh hoàn chỉnh.

			Ví dụ: Một căn hộ dịch vụ với rất nhiều phòng.

				- CănHộ (thực thể mạnh): M̲ã̲C̲ă̲n̲H̲ộ̲ (khoá định danh), ĐịaChỉ
				- Phòng (thực thể yếu): S̰ố̰P̰h̰ò̰n̰g̰ (khoá định danh riêng phần), SứcChứa

				-> M̲ã̲C̲ă̲n̲H̲ộ̲, S̲ố̲P̲h̲ò̲n̲g̲: Định danh đầy đủ.

		- Có thể được chuyển thành mối kết hợp.

		- Thực thể yếu sẽ được kí hiệu bằng hình chữ nhật nét đôi.
			+ Mối kết hơp để phát sinh dữ liệu cho thực thể yếu (được gọi là mối kết hợp định danh - Identifying Relationship) sẽ được kí hiệu bằng hình thoi nét đôi.
			+ Thuộc tính định danh riêng phần của thực thể yếu vẫn được gạch nhân nhưng phải bằng nét đứt.

		Ví dụ 1: Nhân viên có người thân là người cùng hưởng bảo hiểm.

			| NhânViên |―――――<< Có >>―――――|| NgườiThân ||
			     |				     |
			  (M̲ã̲N̲V̲)			      (T̰ḛ̂n̰N̰T̰)

		Ví dụ 2: Hoá đơn trong giao dịch mua hàng có chi tiết hoá đơn.

			| HoáĐơn |―――――<< Thuộc >>―――――|| ChiTiếtHoáĐơn ||
			     |					|
			  (S̲o̲H̲D̲)			      (S̲o̲H̲D̲,̲ ̲M̲ã̲S̲P̲)

		Ví dụ 3: Sinh viên trong một trường có thông tin đăng ký môn học.

			| SinhViên |―――――<< Có >>―――――|| ThôngTinĐăngKýMônHọc ||

------------------------------------------------------------

* Thuộc tính - Phân loại thuộc tính theo nhóm:

	1. Nhóm thuộc tính đơn & thuộc tính tổ hợp.

		* Thuộc tính đơn / nguyên tử (Simple Attribute / Single Attribute / Atomic Attribute): Thuộc tính không thể phân chia nhỏ hơn được nữa (không nói về giá trị bên trong của thuộc tính).

			Ví dụ: Màu sắc, cân nặng,...

		* Thuộc tính tổ hợp / phức hợp (Composite Attribute): Chứa bên trong nhiều thuộc tính đơn hoặc phức.
			- Vẫn còn ở mức chung chung, do nhiều thuộc tính đơn hoặc phức tạo thành, nên có thể được chia nhỏ hơn nếu cần thiết.
			- Được biểu diễn bằng cách đặt tên thuộc tính trong cặp dấu ngoặc tròn "()" và vẽ tiếp những thuộc tính đơn khác có liên kết với thuộc tính phức này.

			Ví dụ:
				- Địa chỉ bao gồm: Số nhà, tên đường, quận, huyện, thành phố,...
				- Họ tên bao gồm: Họ, tên đệm và tên.

	2. Nhóm thuộc tính đơn trị & thuộc tính đa trị.

		* Thuộc tính đơn trị (Single-valued Attribute): Thuộc tính chỉ nhận đồng thời 1 giá trị.

			Ví dụ: Một người chỉ có duy nhất một năm sinh.

		* Thuộc tính đa trị (Multi-valued Attribute): Thuộc tính được phép nhận đồng thời nhiều giá trị (có một tập hợp danh sách các giá trị).
			- Chỉ nên sử dụng để lưu trữ những thuộc tính quan trọng, cần lọc và phân tách để xử lý sau này.
				+ Ngoài ra, không khuyến khích sử dụng vì sẽ gây khó khăn cho quá trình thống kê.
				+ Thay vào đó, có thể lưu toàn bộ giá trị trong một chuỗi, tập tin hoặc đường dẫn.
			- Được biểu diễn bằng hình elip nét đôi.

			Ví dụ:
				- Sở thích: Một người có thể có nhiều sở thích khác nhau.
				- Số điện thoại: Một người có thể có nhiều điện thoại, mỗi loại hỗ trợ nhiều sim.
				- Ngoại ngữ: Mỗi người có thể nói được nhiều ngoại ngữ khác nhau.
				- Bằng cấp/ Chứng chỉ: Mỗi người có thể sở hữu nhiều bằng cấp và chứng chỉ khác nhau.

	3. Nhóm thuộc tính lưu trữ & thuộc tính dẫn xuất.

		* Thuộc tính lưu trữ / cơ sở (Stored Attribute): Nếu để trống, sẽ không thể biết giá trị của thuộc tính là gì và cũng không có cách nào để suy ra (không thể nhìn rồi đoán), nên bắt buộc phải được nhập vào (từ bàn phím).

			Ví dụ: Tên, năm sinh,...

		* Thuộc tính dẫn xuất / suy diễn / suy dẫn / phái sinh (Derived Attribute / Computed Attribute): Để tránh sai xót hoặc mâu thuẫn khi phải nhập thủ công, giá trị của thuộc tính sẽ được suy ra nhờ vào những thuộc tính có sẵn khác.
			- Phục vụ cho việc tổng hợp và thống kê một cách tự động.
			- Thường chỉ nên là thuộc tính dẫn xuất khi được tính toán ra từ một biểu thức đơn giản.
			- Trong thực tế, để đạt chuẩn thiết kế CSDL, thuộc tính dẫn xuất sẽ thường được tách ra thành một bảng tạm thay vì được sử dụng làm thuộc tính của một thực thể.
			- Được biểu diễn bằng hình elip nét đứt.

			Ví dụ:
				- Tuổi: Được tính nhờ vào có nhập thuộc tính năm sinh.
				- Thời gian (kinh nghiệm) làm việc: Được tính từ ngày vào làm.
				- Số lượng nhân viên của Phòng Ban: Được tính nhờ vào việc đếm số lượng nhân viên trong bảng Nhân Viên.
				- Giá trị của hoá đơn trong bảng Hoá Đơn: Được tính nhờ vào việc đi vào bảng Sản Phẩm, tính tổng của (số lượng * đơn giá từng mặt hàng).
				- Lương thực lĩnh: Được tính nhờ vào (hệ số lương * lương cơ bản).

	(Complex Attribute: Khi thuộc tính phức và thuộc tính đa trị kết hợp.)

--------------------

* Lưu ý 1: Đối với nhóm thuộc tính 1 và 3, nếu xác định bị sai thì chỉ gây khó khăn trong việc lấy dữ liệu ra để sử dụng, nhưng nếu nhóm thuộc tính 2 bị xác định sai thì sẽ ảnh hưởng đến việc lưu trữ dữ liệu.


* Lưu ý 2: Khi thiết kế ERD, cần có một số lưu ý sau đối với thuộc tính.
	- Chỉ nên sử dụng thuộc tính đơn và đơn trị, không nên sử dụng thuộc tính phức và đa trị.
	- Mỗi ứng dụng sẽ chỉ tương tác với một vài thuộc tính chứ không phải với tất cả các thuộc tính.
	- Mỗi đối tượng sẽ có một thuộc tính định danh để phân biệt với các đối tượng khác và mỗi thực thể có thể có nhiều thuộc tính cùng làm định danh.

----------------------------------------

	Ngoài ra, ta có thể phân loại thuộc tính theo khoá (Identifier).

		- Tên gọi ban đầu là định danh (Identifier), nhưng công dụng giống hết như khoá (Key) trong mô hình quan hệ, nên dần được gọi là thuộc tính khoá (Key Attribute).

		- Xuất phát từ yêu cầu phải có cách để phân biệt giữa các đối tượng trong cùng một tập thực thể khi giá trị của tất cả các thuộc tính giữa các thực thể đều trùng nhau, giúp đảm bảo việc lưu trữ là duy nhất.

		- Thuộc tính khoá là một thuộc tính hoặc tập hợp các thuộc tính, được sử dụng để xác định một đối tượng duy nhất trong tập thực thể.
			+ Giá trị của thuộc tính là duy nhất cho mỗi thực thể.
			+ Giúp phân biệt giữa đối tượng này với những đối tượng khác trong cùng một kiểu thực thể.

		- Mỗi thực thể yêu cầu phải có ít nhất một thuộc tính khoá để định danh (Identify).

		- Thuộc tính khoá có thể được suy đoán thông qua những suy đoán về mặt luận lý.

		-> Giúp phân biệt giữa các dòng dữ liệu trong bảng.

		1. Thuộc tính khoá chính (Primary Key): Giúp xác định duy nhất một đối tượng trong một thực thể.

			- Trong ERD, thường chỉ là một thuộc tính duy nhất, nhưng đôi khi cũng yêu cầu phải là sự kết hợp của từ hai thuộc tính trở lên.

			- Nếu trong danh sách thuộc tính của một thực thể không có sẵn thuộc tính để phục vụ cho mục đích định danh.
				+ Vì giá trị của một thuộc tính sẵn có sẽ không tuân theo quy luật và có nhiều biến động (ví dụ: tên sẽ có độ dài khác nhau, có khoảng trắng và có dấu tiếng Việt,...).
				+ Vì vậy, nên thiết kế thêm một thuộc tính riêng, không nên cố gắng sử dụng những thuộc tính sẵn có, vì khả năng trùng lặp dữ liệu và khả năng gây ra khó khăn trong việc định danh là rất cao.
				+ Nếu không thể tự xây dựng thuộc tính định danh do thực thể đang là thực thể yếu, cần phải sử dụng mối kết hợp để chỉ rõ thực thể yếu này đang phụ thuộc vào thực thể nào.

			- Được biểu diễn bằng cách gạch dưới / gạch chân tên thuộc tính.

			-> Chỉ cần một giá trị của thuộc tính là có thể xác định được cả một đối tượng.
				("Giá trị của thuộc tính là thứ tồn tại duy nhất. Còn tất cả những cái khác, trùng hay không trùng, không quan trọng.")

		2. Thuộc tính khoá ngoại (Foreign Key): Không có trong ERD, chỉ có trong RS.
			- Là điểm chung giữa hai thực thể, giúp hai thực thể liên kết với nhau.
			- Là một thuộc tính hoặc tập hợp các thuộc tính trong một bảng, tham chiếu đến khoá chính của bảng khác.
			- Được sử dụng để thiết lập quan hệ giữa hai hay nhiều bảng khi thuộc tính khoá chính của bảng khác "chạy" sang để làm thuộc tính khoá ngoại trong bảng này.

			-> Khoá chính của bảng này "vi hành" sang làm khoá ngoại của bảng khác.

------------------------------------------------------------

* Mối kết hợp - Phân loại mối kết hợp & Ràng buộc cấu trúc (Structural Constraint) trên mối kết hợp:

--------------------

	* Số ngôi / Bậc / Cấp (Degree): Dựa vào số lượng thực thể tham gia vào mối kết hợp.

		1. Liên kết một ngôi / đơn phân / đệ quy / hồi quy (Unary / Recursive): Mối liên kết / tương tác giữa các đối tượng trong cùng một thực thể (thực thể có thể tự tham gia vào liên kết với vai trò khác nhau).

			Ví dụ:
				| NhânViên |―――――< Chịu sự giám sát của >―――――| NhânViên |
				| NhânViên |―――――< Kết hôn với >―――――| NhânViên |

		2. Liên kết hai ngôi / nhị phân (Binary): Là mối liên kết giữa hai thực thể.

		3. Liên kết nhiều ngôi / ≥ tam phân ≈ đa phân (≥ Ternary ≈ N-ary): Là mối liên kết giữa ba thực thể trở lên.
			- Có thể và ưu tiên chuyển đổi thành nhiều liên kết hai ngôi.
				+ Tên của mối liên kết (kiểu liên kết) sẽ được chuyển đổi thành một thực thể riêng biệt.
				+ Được biểu diễn bằng thoi, nhưng được bao quanh bên ngoài bởi hình chữ nhật.

			Ví dụ: Liên kết ba ngôi, nhưng không thể tách rời được.

				| GiảngViên |―――――< Hướng dẫn >―――――| MônHọc |
							│
							│
							│
						    | LớpHọc |

				Khi tách ra, GiảngViên sẽ không biết giảng MônHọc gì cho LớpHọc và LớpHọc cũng sẽ không biết MônHọc do GiảngViên nào giảng.

--------------------

	* Ràng buộc trọng số (Cardinality Ratio / Mapping Cardinality):
		- Dựa vào trọng số / bản số / lượng số tối đa (số lượng đối tượng tối đa của các thực thể) tham gia vào mối kết hợp.
		- Chỉ quan tâm đến trọng số tối đa (Maximum Cardinality).

		1. Liên kết một-một (one-to-one, 1-1): Mỗi đối tượng trong thực thể A <có liên kết> với 1 đối tượng trong thực thể B, và ngược lại.

			Ví dụ:
						  1			1
				| SinhViên |―――(1, 1)―――――< Có >―――――(1, 1)―――| ThẻSinhViên |

				- Mỗi sinh viên sẽ được nhà trường cung cấp sẵn một thẻ sinh viên.
				- Mỗi thẻ sinh viên đã tạo ra phải và chỉ có thể thuộc về một sinh viên duy nhất.

		2.1. Liên kết một-nhiều (one-to-many, 1-n):
			- Mỗi đối tượng trong thực thể A <có liên kết> với nhiều đối tượng trong thực thể B.
			- Nhưng mỗi đối tượng trong thực thể B chỉ <có liên kết> với 1 đối tượng trong thực thể A.

			Ví dụ:
						  1			 n
				| SinhViên |―――(1, 1)―――――< Nộp >―――――(0, n)―――| BàiTập |

				- Mỗi sinh viên có thể không nộp hoặc nộp nhiều bài tập đã làm.
				- Mỗi bài tập chỉ được nộp bởi một sinh viên duy nhất.

		2.2. Liên kết nhiều-một (many-to-one, n-1):
			- Mỗi đối tượng trong thực thể A chỉ <có liên kết> với 1 đối tượng trong thực thể B.
			- Nhưng mỗi đối tượng trong thực thể B <có liên kết> với nhiều đối tượng trong thực thể A.

			Ví dụ:
						  n			   1
				| SinhViên |―――(0, n)―――――< Thuộc >―――――(1, 1)―――| Khoa |

				- Mỗi sinh viên chỉ được phép thuộc về một khoa duy nhất (trừ văn bằng 2).
				- Mỗi khoa được phép chưa có hoặc có nhiều sinh viên.

		3. Liên kết nhiều - nhiều (many-to-many, n-n): Mỗi đối tượng trong thực thể A <có liên kết> với nhiều đối tượng trong thực thể B, và ngược lại.

			Ví dụ:
						  n			       n
				| SinhViên |―――(0, n)――――< Đăng kí >――――(0, n)―――| MônHọc |

				- Trong một học kì, Mỗi sinh viên có thể không đăng ký (bảo lưu học kì) hoặc đăng kí nhiều môn học.
				- Mỗi môn học có thể không có sinh viên nào đăng kí hoặc có nhiều sinh viên cùng đăng kí.

		4. Liên kết đệ quy / vòng: Mỗi loại thực thể có thể tham gia nhiều lần vào một quan hệ với nhiều vai trò khác nhau.

			Ví dụ:
						  n			    n
				| SinhViên |―――(0, n)―――――< Hỗ trợ >―――――(0, n)―――| SinhViên |

				- Mỗi sinh viên có thể hỗ trợ học tập cho nhiều sinh viên khác.
				- Mỗi sinh viên có thể được nhiều sinh viên khác hỗ trợ học tập.

----------

		- Trọng số tối đa (Maximum Cardinality) sẽ gắn liền với thực thể gần với nó nhất, cách đọc trọng số cũng từ đó mà bị ảnh hưởng theo.
		
			Ví dụ:
				- Mỗi NhânViên làm việc cho 1..1 PhòngBan.
					-> Trọng số 1 được gán cho PhòngBan.

				- Mỗi PhòngBan có 0..n NhânViên làm việc.
					-> Trọng số nhiều được gán cho NhânViên.

					     n			1
				| NhânViên |―――――< Làm việc >―――――| PhòngBan |

				-> NhânViên làm việc cho PhòngBan là liên kết nhiều-một.

		- Đối với liên kết ba ngôi (n-n-n, 1-n-n, 1-1-n, 1-1-1,...).
			+ Có thể là liên kết giữa các thực thể.
			+ Cũng có thể là liên kết giữa các thực thể và mối kết hợp.
			+ Việc xác định trọng số của các thực thể cũng sẽ trở nên phức tạp hơn khi phải trả lời tuần tự 3 câu hỏi:
				1. Khi thực thể A và B kết hợp, có thể có bao nhiêu C?
				2. Khi thực thể A và C kết hợp, có thể có bao nhiêu B?
				3. Khi thực thể C và B kết hợp, có thể có bao nhiêu A?

		Ví dụ 1: Liên kết ba ngôi và trọng số.

			| GiảngViên |―――(1, n)――――< Hướng dẫn >――――(1, n)―――| MônHọc |
							│
							│
						      (1, n)
							│
						    | LớpHọc |

			- Một giảng viên - hướng dẫn cho một lớp, có thể hướng dẫn một hoặc nhiều môn.

			- Một giảng viên - hướng dẫn một môn học, có thể hướng dẫn cho một hoặc nhiều lớp.

			- Một lớp - được hướng dẫn một môn học, có thể có một hoặc nhiều giảng viên cùng hướng dẫn.

		Ví dụ 2: Liên kết ba ngôi và trọng số.

			| NhàCungỨng |―――(1, n)――――< CungCấp >――――(1, n)―――| CửaHàng |
							│
							│
						      (1, n)
							│
						    | MặtHàng |

			- Một nhà cung ứng - cung cấp một mặt hàng, cho nhiều cửa hàng.

			- Một nhà cung ứng - cung cấp cho một cửa hàng, nhiều mặt hàng.

			- Một mặt hàng - cung cấp cho một cửa hàng, bởi nhiều nhà cung ứng.

--------------------

	* Ràng buộc tham gia (Participation Constraint):
		- Dựa vào trọng số tối thiểu tham gia vào mối kết hợp.
		- Chỉ quan tâm đến trọng số tối thiểu (Minimum Cardinality).

		1. Tuỳ chọn (Optional - Opt) - Tham gia bộ phần (Partial Participation): Được phép không có đối tượng nào trong thực thể tham gia vào mối kết hợp.
			-> Số tối thiểu là 

		2. Bắt buộc (Mandatory - Man) - Tham gia toàn bộ (Total Participation): Phải có ít nhất một (hoặc nhiều) đối tượng trong thực thể tham gia vào mối kết hợp.

----------------------------------------

* Lưu ý: Khi thiết kế, phải nhìn trên tổng thể và hướng về tương lai, không nên chỉ thiết kế để giải quyết được những vấn đề trong hiện tại.
	-> Thà thiết kế thừa để sau này mở rộng còn hơn thiết kế thiếu.

	Ví dụ 1: Thiết kế thừa nhưng không sai.

		| NhânViên |―――(1, n)―――――< Làm việc >―――――(1, n)―――| PhòngBan |
							       ^
							       |
				 Cần xem xét là 1 hay n. -------

		Một nhân viên có thể làm việc trong một hoặc nhiều phòng ban.

			- Ở thời điểm hiện tại, một nhân viên chỉ đang thuộc một phòng ban.
				-> Có thể thiết kế trọng số của NhânViên là (1, 1).

			- Nhưng trong tương lai, một nhân viên có thể được thuyên chuyển sang nhiều phân hệ khác nhau (thăng cấp, hạ cấp).
				-> Phải thiết kế trọng số của NhânViên là (1, n).

			- Ngoài ra, việc thiết kế trọng số của NhânViên là (1, n) còn cho phép lưu lại lịch sử làm việc của một nhân viên, phục vụ cho công việc thống kê sau này.

	Ví dụ 2: Thiết kế thừa nhưng không sai.

		| GiảngViên |―――(1, n)―――――< Hướng dẫn >―――――(1, n)―――| MônHọc |
				    ^
				    |
				    ------- Cần xem xét là 1 hay n.

		Một môn học có thể được một hoặc nhiều giảng viên hướng dẫn.

			- Ở thời điểm hiện tại, có thể một môn chỉ cho phép một giảng viên phụ trách.
				-> Có thể thiết kế trọng số của MônHọc là (1, 1).

			- Nhưng trong tương lai, một môn có thể có đến hai giảng viên hướng dẫn, một thời phụ trách phần lý thuyết và người còn lại phụ trách phần thực hành.
				-> Phải thiết kế trọng số của MônHọc là (1, n).

--------------------------------------------------------------------------------

[ERD MỞ RỘNG - ENHANCED ERD (E-ERD)]

Khi độ phức tạp của dữ liệu ngày càng tăng.
	- ERD truyền thống sẽ không đủ đề mô hình hóa CSDL (biểu diễn các đối tượng và mối kết hợp giữa chúng).
	- Cần phải có thêm những khái niệm mới để giúp biểu diễn dữ liệu được rõ ràng và chính xác hơn.

	Ví dụ: Một công ty phần mềm có 3 loại nhân viên khác nhau:
		- Chuyên viên phân tích nghiệp vụ khách hàng (Business Analyst).
		- Lập trình viên (Developer).
		- Kiểm thử viên (Tester).

		-> Làm sao thể hiện được quy tắc nghiệp vụ bằng ER truyền thống?

			1. Tạo ra 3 thực thể riêng biệt.
				- Mỗi thực thể tương ứng với một loại nhân viên.
				- Những thông tin chung (ví dụ: tên, năm sinh, sđt, email...) sẽ bị lặp lại nhiều lần giữa các thực thể.

				-> Không tận dụng được những đặc điểm chung.

			2. Tạo ra một thực thể chung là NhânViên.
				- Tất cả những thông tin chung đã được gom vào cùng một nơi.
				- Có thêm 3 thuộc tính: ChuyênViênPhânTíchNghiệpVụ, LậpTrìnhViên, KiểmThửViên.
				- Cùng một lúc, chỉ có 1 trong 3 thuộc tính có thể có dữ liệu (2 thuộc tính còn lại sẽ luôn luôn được để trống).

				-> Một số thông tin luôn luôn bị để trống.

------------------------------------------------------------

1. Tổng quát hoá và chuyên biệt hoá / Cha-Con (Generalization and Specialization): Được lấy cảm hứng từ mô hình hướng đối tượng.

	- Khi giữa các thực thế có mối kết hợp Cha-Con (Cha tổng quát hoá, Con chuyên biệt hoá), nhận biết bằng dấu hiệu "là-một (is-a)".
		+ Thực thể Cha (Supper-type / Super-class / Generalized Class): Chỉ chứa đựng những đặc điểm hoặc mối kết hợp chung nhất của tất cả các Con.
		+ Thực thể Con (Sub-type / Sub-class / Specialized Class): Chỉ bao gồm những đặc điểm hoặc mối kết hợp riêng biệt mà Cha không có.

		Ví dụ: Một số đặc điểm mà chỉ riêng Con mới có.

			| KháchHàngThânThiết |―――――< Là một >―――――| KháchHàng |
				|
			(SốĐiểmThưởngTíchLuỹ)


			| LậpTrìnhViên |―――――< Là một >―――――| NhânViên |
				|
		      (SốTínhNăngViếtĐược)


			| GiảngViên |―――――< Là một >―――――| NhânViên |
			      |
			(GiảngDạyVàNCKH)

	- Thực thể Con sẽ kế thừa toàn bộ thuộc tính, khoá và mối liên kết của thực thể Cha.
		- Đồng thời, Con được phép có thêm những thuộc tính và mối liên kết khác cho riêng mình.
		+ Nhưng riêng về khoá thì Con không được phép có mà phải sử dụng khoá của Cha (Con có quyền sử dụng đồ dùng trong nhà, nhưng riêng chìa khoá nhà vẫn phải do Cha nắm giữ).

	- [???] Một thực thể kiểu Con cũng là một thực thể kiểu Cha, nhưng không nhất thiết một thực thể kiểu Cha phải thuộc về một kiểu Con.

	- Để biểu diễn được các thực thể Cha-Con:
		1. Gom những gì chung nhất, để ở Cha.
		2. Sử dụng một hình tròn nhỏ (vòng tròn chuyên biệt) để làm mấu nối / chốt rẻ nhánh.
		3. Từng Con riêng biệt sẽ nối với vòng tròn chuyên biệt và đi kèm với kí hiệu thuộc về (∈) hoặc kí hiệu tập hơp con (⊂).
			- Đầu tròn của kí hiệu ∈ / ⊂ sẽ quay về phía Con.
			- Đầu nhọn sẽ quay về phía vòng tròn chuyên biệt (mấu nối của Cha).
			(Ý nghĩa: Con ∈ Cha / Con ⊂ Cha.)

		Ví dụ: Các chức danh công việc trong một công ty CNTT.
		
			| LậpTrìnhViên |―――――――――――――――――――∈―――――\
			| ChuyênViênPhânTíchNghiệpVụ |―――――∈―――――〇―――――| NhânViên |
			| KiểmThửViên |――――――――――――――――――――∈―――――/

	* Kỹ thuật xác định Cha-Con:

		1. Tổng quát hoá (Generalization): Là quá trình tiếp cận từ cụ thể đến tổng quát (buttom-up).
			- Phát hiện ra giữa những thực thể Con có một số điểm chung (thuộc tính, mối liên kết,...).
			- Sau đó gom những điểm chung này lại và tạo thành thực thể Cha.

			-> Phát hiện ra những điểm chung trong từng cái riêng.

			Ví dụ: Cho một cơ sở dữ liệu phục vụ cho một hội nghị khoa học.
				- Trong đó, các tác giả sẽ gửi những bài báo của mình cho hội nghị. Thông tin tác giả bao gồm: Địa chỉ email (định danh), họ và tên, bộ môn, khoa, trường công tác, học vị, chức vị.
				- Hội nghị sẽ phân công một số nhà khoa học tham gia đánh giá các bài báo. Một bài báo sẽ được nhiều người đánh giá. Thông tin người đánh giá bao gồm địa chỉ email (định danh), họ và tên, số điện thoại liên lạc, học vị, chức vị và những hướng nghiên cứu.

				-> Cả tác giả và người đánh giá đều có những thông tin chung.
					=> Tổng quát hoá lên thành thực thể NhàKhoaHọc.

		2. Chuyên biệt hoá / Cụ thể hoá (Specialization): Là quá trình tiếp cận từ tổng quát về cụ thể (top-down).
			- Xem xét trong tập thực thể Cha.
				+ Ngoài những thông tin chung (thuộc tính, mối liên kết,...), có thực thể nào có "cá tính" không.
				+ Nếu có thì tách những thực thể có "cá tính" ra thành những thực thể Con.
			- Hoặc khi phát hiện trong thực thể Cha, một số thông tin lúc có/ lúc không có giá trị.
				+ Một số thông tin không phải lúc nào cũng có giá trị.
				+ Đôi khi, nếu thông tin này có giá trị hoặc thay đổi giá trị thì một số thông tin khác sẽ bị vô hiệu hoá tạm thời.
				+ Giống như các câu lệnh rẻ nhánh (if-else, switch-case). 

				Ví dụ: Một công ty gồm 3 loại nhân viên: Bán thời gian, toàn thời gian, chuyên viên tư vấn.
					- Nếu thuộc tính "Loại nhân viên" có giá trị là 1 (nhân viên bán thời gian).
						+ Chỉ thuộc tính "Số giờ làm việc" được phép có giá trị.
						+ Những thuộc tính "Số năm làm việc" (của nhân viên toàn thời gian) và "chiết khấu hợp đồng" (của chuyên viên tư vấn) sẽ tạm thời bị vô hiệu hoá.

			Ví dụ: Linh kiện để lắp ráp một sản phẩm trong công ty A bao gồm các thông tin: Mã số linh kiện, mô tả linh kiện, địa điểm lắp ráp. Linh kiện gồm hai loại:
				- Một loại có thể tự sản xuất được, cần ghi lại số hiệu sản xuất.
				- Một loại đặt mua từ nhà cung cấp bên ngoài, cần lưu giữ thông tin: Mã nhà cung cấp, giá thành.

				-> Trong linh kiện có những loại nhỏ hơn và có cá tính.
					=> Chuyên biệt hoá thành các thực thể LK_TSX và LK_DCC.

--------------------

* Lưu ý: Đôi khi, trong một số trường hợp, các thực thể tổng quát hoá và chuyên biệt hoá không được xem là Cha-Con.
	- Đó là khi trong quá trình tổng quát hoá, một số thực thể biến mất hoàn toàn vì không có bất kì đặc điểm riêng nào so với những thực thể khác.
	- Lúc này, thực thể được tổng quát hoá đang chứa mọi đặc điểm riêng của thực thể vừa biến mất (hai thực thể này có thể xem như đang hoà làm một).
	- Nhưng không thể gọi thực thể được tổng quát hoá là Cha của những thực thể khác, vì chưa chắc thực thể vừa biến mất đã đủ "tư cách" để làm Cha của những thực thể còn lại.

	Ví dụ: Sự biến mất của thực thể trong quá trình tổng quát hoá.

				-- Trước khi tổng quát hoá --

		| XeMáy |			| XeKhách |―――――(SốChỗNgồi)
		    |				     |
		    |				     |
		(M̲ã̲, ThươngHiệu, Giá,...)       (M̲ã̲, ThươngHiệu, Giá,...)

				| XeTải |―――――(TrọngTải)
				    |
				    |
				(M̲ã̲, ThươngHiệu, Giá,...)


				-- Sau khi tổng quát hoá --
		[Thực thể XeMáy đã "hoà tan" do không có bất kì điểm riêng nào]

		(SốChỗNgồi)
		     |
		     |
		| XeKhách |―――――――――――――――∈―――――\
						〇―――――| PhươngTiệnGiaoThông |
		| XeTải |―――――――――――――――――∈―――――/		|
		     |						|
		     |					(M̲ã̲, ThươngHiệu, Giá,...)
		(TrọngTải)

----------------------------------------

	* Ràng buộc trong quan hệ Cha-Con (cụ thể là ràng buộc trên thuộc tính Con):

		- Ràng buộc về tính đầy đủ (Completeness Constraint): Trong quá trình tổng quát hoá, các thực thể Con có còn đầy đủ hay đã bị "hoà tan" (Con ẩn, Con ngầm, Con rơi).

			1. Quy tắc chuyên biệt toàn phần (Total Specialization Rule).
				- Vẫn còn đầy đủ Con.
					+ Mọi đối tượng trong thực thể Cha bắt buộc phải thuộc một trong các thực thể Con đã được liệt kê.
					+ Tập hợp / Tổng các thực thể Con cộng lại phải bằng tổng thực thể Cha.
				- Được phép gọi là mối quan hệ Cha-Con.
				- Trong sơ đồ, được vẽ bằng đường nét đôi (song song), nối từ phía Cha đến vòng tròn chuyên biệt.

				Ví dụ: Trong một bệnh viện, nếu bệnh nhân (thực thể Cha) đi khám bệnh.
					- Sau khi có kết quả khám, bệnh nhân sẽ được chỉ định điều trị nội trú hoặc ngoại trú (các thực thể Con).
					- Tổng số bệnh nhân ngoại trú và nội trú, khi cộng lại phải bằng tổng số lượng bệnh nhân.

			2. Quy tắc chuyên biệt riêng phần (Partial Specialization Rule).
				- Một hoặc một số Con đã bị "hoà tan" (Con ẩn, Con ngầm, Con rơi).
					+ Có một số đối tượng trong thực thể Cha không thuộc về một trong các thực thể Con nào đã liệt kê.
					+ Tập hợp / Tổng các thực thể Con cộng lại không thể bằng tổng thực thể Cha.
				- Nên gọi là mối quan hệ Tổng quát hoá-Chuyên biệt hoá.
				- Trong sơ đồ, được vẽ bằng đường nét đơn, nối từ phía Cha đến vòng tròn chuyên biệt.

				Ví dụ: Khi phương tiện giao thông được tổng quát hoá thành thực thể Cha.
					- Trong quá trình tổng quát hoá, một số thực thể Con vì không có bất kì cá tính nào, nên đã bị "hoà tan" vào trong thực thể Cha.
					- Dẫn đến việc có một số loại phương tiện đặc biệt chỉ bao gồm những thuộc tính của Cha, không thể tạo thành thực thể Con.
					- Tổng số thực thể của lớp Con cộng lại sẽ không thể bằng tổng số thực thể của lớp Cha, do ban đầu đã có một số thực thể Con bị mất.

		- Ràng buộc về tính phân biệt / tách biệt (Disjointness Constraint): Kiểm tra một đối tượng kiểu Cha có thể đóng cùng một lúc nhiều vai (thuộc về nhiều) kiểu Con hay không.

			1. Quy tắc phân biệt / tách biệt / rời rạc (Disjoint Rule).
				- Tại một thời điểm, một đối tượng của Cha không thể thuộc về nhiều thực thể Con (chỉ chọn thuộc về duy nhất một trong số các Con).
				- Trong sơ đồ, kí tự 'd' được viết trong vòng tròn chuyên biệt.

				Ví dụ 1: Tại một thời điểm, không thể có hai phương thức điều trị (ngoại trú và nội trú) cho cùng một bệnh nhân.

				Ví dụ 2: Tại một thời điểm, một loại xe không thể nào cùng thuộc cả hai loại xe (môtô và ôtô).

			2. Quy tắc trùng lặp / phủ lấp / chồng chéo (Overlapped Rule).
				- Tại một thời điểm, một đối tượng của Cha có thể thuộc về nhiều thực thể Con.
				- Trong sơ đồ, kí tự 'o' được viết trong vòng tròn chuyên biệt.

				Ví dụ 1: Tại một thời điểm, có thể có hai loại linh kiện (tự sản xuất và nhập khẩu) cùng tồn tại trong một công ty phân phối linh kiện.

				Ví dụ 2: Tại một thời điểm, một nhân viên của công ty có thể nhận nhiều vai trò cùng một lúc (vừa làm chuyên viên phân tích nghiệp vụ khách hàng, vừa làm kiểm thử viên).

			(Nếu không chỉ định rõ, mặc định sẽ là phân biệt / rời rạc.)

		* Yếu tố phân biệt / Thuộc tính xác định thực thể Con (Sub-type Discriminator):
			- Là yếu tố được sử dụng để bổ sung thêm cho ràng buộc về tính phân biệt (Disjointness Constraint).
			- Tạo thêm một thuộc tính ở Cha, giá trị của thuộc tính này sẽ cho biết loại thực thể Con nào sẽ được sử dụng (giống if-else, switch-case).

			1. Các thực thể Con phân biệt (Disjoint Sub-type): Dùng một thuộc tính đơn (không thể phân tách) với các giá trị khác biệt nhau để chỉ ra các thực thể Con có thể có.

			2. Các thực thể Con trùng lặp (Overlapping Sub-type): Dùng một thuộc tính phức (có thể phân tách) mà các phần nhỏ hơn của nó nói đến các thực thể Con khác nhau.
				- Mỗi phần chứa một giá trị luận lý để chỉ ra một đối tượng có thuộc về thực thể Con tương ứng hay không.

			Ví dụ 1: Các thực thể con phân biệt (Disjoint).

					    "NgoạiTrú"
				| NgoạiTrú |――――――――――∈―――――\  LoạiBN = ...
							    〇―――――――――――――――| BệnhNhân |
				| NộiTrú |――――――――――――∈―――――/			  |
					    "NộiTrú"				  |
									       (LoạiBN)

				Thuộc tính LoạiBN sẽ là một cột.
					+ Tại một thời điểm, chỉ nhận vào một giá trị duy nhất.
					+ Cho biết loại bệnh nhân tương ứng là gì.

				* Bảng "Bệnh nhân":

				-----------------------------------------------------------
				| Mã BN	| Tên BN		| Năm sinh	| Loại BN |
				|-------|-----------------------|---------------|---------|
				| BN01	| Nguyễn Văn Anh	| 01/01/2001	| NgT	  |
				|-------|-----------------------|---------------|---------|
				| BN02	| Hoàng Minh Chiến	| 02/02/2002	| NT	  |
				|-------|-----------------------|---------------|---------|
				| BN03	| Hoàng Thị Giang	| 03/03/2003	| NT	  |
				|-------|-----------------------|---------------|---------|
				| BN04	| Nguyễn Mạnh Hùng	| 04/04/2004	| NgT	  |
				-----------------------------------------------------------

			Ví dụ 2: Các thực thể con trùng lặp (Overlap).

					  LK_TSX="Y"
				| LK_TSX |――――――――――∈―――――\  LoạiLK = ...
							  〇―――――――――――――――| LinhKiện |
				| LK_DCC |――――――――――∈―――――/			|
					  LK_DCC="N"				|
									―――――(LoạiLK)―――――
									|		 |
									|		 |
								     (LK_TSX)	      (LK_DCC)

				Thuộc tính LoạiLK sẽ được tách thành hai cột.
					+ Tại một thời điểm, cả hai cột cùng cho phép nhận giá trị.
					+ Mỗi cột sẽ là một giá trị luận lý (True/False, Yes/No).
					+ Loại linh kiện có thể có tận hai giá trị khác nhau.

				* Bảng "Linh kiện":
				
				---------------------------------------------------------
				| Mã LK	| Tên LK	| Số lượng	|   Loại LK	|
				|	|	    	| tồn kho	|---------------|
				|	|	    	|		| Tự SX	| Nhập	|
				|-------|---------------|---------------|-------|-------|
				| LK01	| Đầu nối   	| 3568		| Y	| N	|
				|-------|---------------|---------------|-------|-------|
				| LK02	| Điện trở  	| 4500		| N	| Y	|
				|-------|---------------|---------------|-------|-------|
				| LK03	| Công tắc 	| 8000		| Y	| Y	|
				|-------|---------------|---------------|-------|-------|
				| LK04	| Bo mạch   	| 68		| N	| Y	|
				---------------------------------------------------------

----------------------------------------

	* Các quy tắc nghiệp vụ / ràng buộc toàn vẹn ở mức ý niệm (Integrity Constraint): Giúp định nghĩa hoặc ràng buộc một số khía cạnh nghiệp vụ.
		- Đây là những mô tả (văn bản hoặc kí hiệu) mà sơ đồ thông thường chưa biểu diễn được.
		- Những quy tắc này giúp:
			+ Hỗ trợ thêm về khả năng diễn đạt ngữ nghĩa cho ERD.
			+ Đảm bảo tính đúng đắn của dữ liệu khi thực hiện các thao tác thêm-xoá-sửa.

		Ví dụ:
			- Một người chỉ có thể thuê xe nếu có bằng lái.
				-> Ràng buộc trước-sau.

			- Một giảng viên được phân công giảng dạy một học phần trong học kì chỉ khi:
				+ Giảng viên này có đủ trình độ để giảng dạy học phần tương ứng.
				+ Học phần này đã được sắp xếp trong thời khoá biểu.
				-> Ràng buộc tương đương.

			- Trong một học kì, giảng viên không được phân công giảng dạy quá 3 học phần.
				-> Ràng buộc tối thiểu-tối đa (cận trên-cận dưới).

	(* Tham khảo thêm các kí hiệu RBTV - Học viện Kỹ thuật mật mã: https://youtu.be/13VaPmqWmsc?si=OFLEKSb1Hcam16L-)

------------------------------------------------------------

2. Đa kế thừa (Multiple Inheritance): Một thực thể Con có thể có nhiều Cha khác nhau.
	- Thuộc tính của thực thể Con là tập hợp (union) thuộc tính của các thực thể Cha.

	Ví dụ: Một giảng viên có thể vừa là thực thể Con của Nhân viên, vừa là thực thể Con của Cựu sinh viên.

------------------------------------------------------------

3. Tập hợp (Union)

(* Tham khảo thêm: https://www.geeksforgeeks.org/enhanced-er-model/)

--------------------------------------------------------------------------------

* Thực hành vẽ ERD (nâng cao): https://thinhnotes.com/chuyen-nghe-ba/15-phut-thuc-hanh-voi-so-do-erd/

==========================================================================================

[THIẾT KẾ - MỨC LUẬN LÝ]

--------------------------------------------------------------------------------

[CÁC THÀNH PHẦN, ĐẶC TRƯNG CỦA MÔ HÌNH DỮ LIỆU QUAN HỆ]

------------------------------------------------------------

	[1. DƯỚI GÓC NHÌN CỦA CẤU TRÚC DỮ LIỆU - STRUCTURE]

* Mô hình dữ liệu quan hệ (Relational Model / Relational Data Model): Là mô hình dữ liệu được sử dụng phổ biến nhất.

	- Có thành phần chính là một bảng (Table) gồm các dòng (Row) và cột (Column).
		+ Giống như bảng tính (Spreadsheet) trong Microsoft Excel.
		+ Nhưng bảng tính chỉ được thiết kế cho một người dùng, trong khi CSDL được thiết kế cho phép nhiều người dùng cùng lúc.

	- Tập trung vào mối quan hệ (Relational) giữa các bảng.

	- Cho phép sử dụng ngôn ngữ SQL để tương tác và quản lý: xem-thêm-sửa-xoá... dữ liệu.

	- Nếu dữ liệu được tổ chức theo mô hình quan hệ sẽ đạt được sự cân bằng giữa:
		+ Hiệu suất cao.
		+ Tiết kiệm không gian lưu trữ.
		+ Dễ dàng truy vấn.

* Lược đồ quan hệ (Table Schema / Relation Schema - RS):
	(Schema = Scheme)

	- Là lược đồ thể hiện cấu trúc của một bảng trong CSDL quan hệ.
		+ Bao gồm tên bảng, các cột, khoá và đôi khi bao gồm cả miền dữ liệu (Domain).
		+ Các cột được liệt kê ngăn cách nhau bằng dấu phẩy, giống hệt như một tập hợp trong toán học (vì được xây dựng dựa trên lý thuyết tập hợp).
		+ Nhưng chỉ liên quan đến một bảng duy nhất, chưa biểu diễn sự liên quan (mối kết hợp) đến các bảng khác.
		+ Không chứa dữ liệu thật sự bên trong, vì dữ liệu có thể có rất nhiều và thường xuyên thay đổi theo thời gian.

		Ví dụ: Lược đồ của từng bảng khác nhau.

			KháchHàng(M̲ã̲K̲H̲, TênKH, EmailKH)
			SinhViên(M̲ã̲S̲V̲, TênSV, EmailSV)

	- Giống như việc nhìn một lớp của lập trình hướng đối tượng (OOP).

* Lược đồ cơ sở dữ liệu quan hệ (Relational Database Schema): Đảm nhận phần còn thiếu của RS khi giúp biểu diễn cấu trúc và mối quan hệ / kết nối giữa các bảng trong CSDL.
	- Gồm nhiều lược đồ quan hệ (RS) để tạo thành một CSDL.
	- Được sử dụng để thể hiện giàn khung (Skeleton) của CSDL, biểu diễn mối quan hệ giữa các bảng.
	- Cũng vì để biểu diễn mối quan hệ giữa các bảng, nên không được phép có bất kì bảng nào nằm riêng lẻ - không có liên kết với các bảng khác trong cùng CSDL.

		Ví dụ: Nhiều bảng liên quan.
			SinhViên(M̲ã̲S̲V̲, TênSV, EmailSV)
			MônHọc(M̲ã̲M̲H̲, TênMH, SốGiờHọc)

* Lược đồ cơ sở dữ liệu (Database Schema): Thường ám chỉ toàn bộ cấu trúc của một CSDL, không nhất thiết phải là một CSDL quan hệ.

	- Database Engine sẽ "nhìn" một CSDL dưới dạng rất nhiều thứ:

		1. Table (Bảng)
		2. View (Góc nhìn): Bên trong chứa sẵn câu truy vấn, được đặt tên và có thể xem đây như một bảng.
		3. Store Procedure
		4. Trigger

* Thể hiện của lược đồ quan hệ (Relation Instance / Populated Table): Cho biết tại một thời điểm, bảng đang chứa những dữ liệu gì - đang có những dòng dữ liệu gì (có thể thay đổi theo thời gian).

* Trạng thái của lược đồ quan hệ (Relation State): Bao gồm (nhiều) Relation Instance và cả những trạng thái trước hoặc sau khi có sự thay đổi trong dữ liệu.

----------------------------------------

Các thông tin lưu trữ trong CSDL sẽ được tổ chức dưới dạng bảng (Table), còn được gọi là quan hệ (Relation).

*  Quan hệ (Relation): Là đơn vị cơ bản của một CSDL.

	- Là một bảng (Table) - mảng hai chiều / ma trận hai chiều (2D Array) gồm các dòng (Row) và cột (Column), giúp lưu trữ thông tin của nhiều thực thể.
		+ Từng thuộc tính (Attribute) sẽ được liệt kê thành từng cột (Column).
		+ Bộ giá trị (Tuple) của các thuộc tính sẽ được gọi là dòng (Row).

	- Đưa dữ liệu vào một nơi có cùng cấu trúc mô tả hoặc đặc điểm mô tả, chứ không nhét một cách bừa bãi.

		Ví dụ: Trong một trường học, những thực thể khác nhau với chức vụ khác nhau sẽ thuộc về những bảng khác nhau.
			- Sinh viên.
			- Giảng viên.
			- Nhân viên.
			- Bảo vệ.
			- Lao công.
			- Câu lạc bộ.
			- ...

	- Nếu giữa các thực thể dính dáng đến nhau, thì được gọi là có mối quan hệ (Relationship).

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Bảng là nơi lưu trữ nhiều đối tượng với chung một cấu trúc	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

* Lưu ý: Quan hệ (Relation) là tên gọi/ cách gọi khác của bảng (Table), trong khi mối kết hợp (Relationship) là sự liên kết giữa hai bảng (Table / Relation).
	- Lý thuyết: Relation - liên qua đến toán học.
	- Thực hành: Table.

----------------------------------------

Các bảng (Table) trong CSDL quan hệ giống như lớp (Class) và những dòng dữ liệu (Row) giống như những thể hiện (Instance) trong lập trình hướng đối tượng (OOP).
	Class			≈ Table / Relation / File
	Instance / Object	≈ Row / Tuple / Record / Entity
	Property		≈ Column / Attribute / Field
	ObjectName.Property	≈ Cell / Value / Data item


* Table "Customers" ≈ Class "Customer"

				Degree (Tổng cột)
	-----------------------------------------------------------------
	|		|		|		|		|

		 Column / Attribute / Field - Data Type / Domain
		-------------------------------------------------
		|		|		|		|
	-----------------------------------------------------------------
	| PrimaryKey(PK)| Column 1	| Attribute 2	| Field 3	|
--------+---------------+---------------+---------------+---------------|
| 1	| Primary Key 1	| Cell 1	| Value 1	| Data item 1	| <-----| Row /
|-------+---------------+---------------+---------------+---------------|	| Tuple /
| 2	| Primary Key 2	| Cell 2	| Value 2	| Data item 2	| <-----| Record /
|-------+---------------+---------------+---------------+---------------|	| Entity /
| 3	| Primary Key 3	| Cell 3	| Value 3	| Data item 3	| <-----| Instance
--------------------------------|---------------|---------------|--------
   |				|		|		|
   -------------		---------------------------------
    Cardinality			    Cell / Value / Data item
    (Tổng dòng)

	|								|
	-----------------------------------------------------------------
			Table / Relation / Class

----------

// Định nghĩa nội dung (Practical):

	- Lược đồ quan hệ (Table Schema / Relation Schema): Cấu trúc các bảng ở mức ý niệm.
		+ Giàn khung (đặc điểm / thuộc tính / biến) chưa có dữ liệu.
		+ Được phác thảo dựa trên sơ đồ ERD.

	- Bảng (Table / Relation): Cấu trúc bảng + Dữ liệu (Đầy đủ thông tin).

	- Cơ sở dữ liệu (Database): Tập hợp gồm nhiều bảng có liên kết với nhau.

	- Từng cột thuộc tính (Column / Attribute / Field): Là những thuộc tính của một đối tượng / thực thể, có thể xem mỗi cột là một biến thuộc tính trong lập trình.

		+ Kiểu dữ liệu (Data Type): Dữ liệu được hiển thị ra bên ngoài dưới dạng như thế nào (thuộc tính có thể chứa loại dữ liệu gì).
			+ Là một dạng ràng buộc về giá trị, có thể là: số nguyên, số thực, chuỗi kí tự, thời gian,...
			+ Nhưng không bao gồm các kiểu dữ liệu phức tạp như: tập hợp (set), danh sách (list), mảng (array),...

		+ Miền giá trị (Domain): Gồm nhiều giá trị đơn (không thể chia nhỏ) thuộc về một kiểu dữ liệu, được phép gán cho một cột (giá trị mà thuộc tính có thể nhận được / có thể chứa).

		(Thuật ngữ "miền giá trị" đã bao gồm cả thuật ngữ "kiểu dữ liệu" bên trong.)

		+ Khoá (Key): Giá trị trong một cột giúp xác định một dòng dữ liệu.

	- Từng dòng dữ liệu (Row / Tuple / Record / Entity): Là khi giá trị được gán cho thuộc tính và tạo thành một dòng dữ liệu.
		+ Mỗi dòng đại diện cho một tập các dữ liệu có liên quan với nhau.
		+ Có thể xem mỗi dòng là một đối tượng trong lập trình.

	- Tổng cột (Degree): Tổng bậc - Số cột của một bảng.

	- Tổng dòng (Cardinality): Tổng lực lượng / bảng số - Số lượng dòng đang được lưu trữ, liên quan đến ĐSQH.

----------

// Định nghĩa hình thức (Formal) - Toán tập hợp:

	- Một lược đồ quan hệ (R) chứa bên trong một tập thuộc tính {A₁, A₂,..., Aₙ}, kí hiệu là: R (A₁, A₂,..., Aₙ).

	- Mỗi thuộc tính (Aᵢ) trong tập thuộc tính {A₁, A₂,..., Aₙ} sẽ có một miền giá trị (Dᵢ) tương ứng với (Aᵢ), kí hiệu là: dom(Aᵢ).
		+ Trong từng miền giá trị sẽ có nhiều giá trị khác nhau.
		+ Nhiều thuộc tính khác nhau (với những miền giá trị khác nhau), khi kết hợp theo tích Đềcác (Descartes), sẽ tạo nên một tập hợp vô cùng nhiều các bộ dữ liệu.

		* Tích Đềcác (Descartes) các miền giá trị của từng thuộc tính trong một bảng.
			- Là lần lượt lấy từng giá trị trong miền giá trị của thuộc tính này đem đi nhân với từng giá trị trong miền giá trị của những thuộc tính khác.
			- Kí hiệu là: D = D₁ × D₂ × ... × Dₙ.

	- Một bảng (r) trong lược đồ quan hệ (R) kí hiệu là: r(R).
		- Sẽ là tập con (subset) tích Đềcác của các miền giá trị, kí hiệu là: D (r ∈ D).
		- Từng dòng dữ liệu trong bảng (r) chỉ là một trong rất nhiều bộ dữ liệu được tạo ra nhờ tích Đềcác vào sau đó được gom vào trong bảng (r).

	- Mỗi bộ (t) của lược đồ quan hệ (R) sẽ có các giá trị aᵢ, kí hiệu là: t (a₁, a₂,..., aₙ).
		+ Với aᵢ ∈ dom(Aᵢ), nghĩa là từng giá trị aᵢ trong bộ (t) phải thuộc miền giá trị của Aᵢ trong R.
		+ Đồng thời, thứ tự khi chèn (nhập) dữ liệu aᵢ vào trong bộ (t) cũng phải tương đương với thứ tự được sắp xếp của Aᵢ trong R.

--------------------

* Các tính chất của bảng (Characteristics of Relations): Một cơ sở dữ liệu có thể tách dữ liệu ra và lưu trữ trong nhiều bảng, mỗi bảng gồm dòng và cột.

	- Tên của các bảng không được trùng nhau.

	- Mỗi dòng trong bảng đại diện cho một đối tượng cụ thể hoặc mối quan hệ giữa các đối tượng, nên sẽ không thể có hai dòng trùng nhau hoàn toàn (mỗi dòng phải là duy nhất).
		- Số lượng dòng và những dữ liệu bên trong một dòng có thể được thay đổi theo thời gian.
		- Những thay đổi phụ thuộc vào những thao tác thêm-sửa-xoá của người dùng.
		- Trong một bảng, dòng đầu tiên được gọi là dòng tiêu đề, chỉ chứa tên các thuộc tính (danh sách tên cột).

	- Mỗi cột trong bảng đại diện cho một thuộc tính của đối tượng.
		+ Tên của các cột trong bảng là cố định và cũng không được trùng nhau.
		+ Các giá trị trong cùng một cột phải cùng một loại (ví dụ: cột để chứa tên không thể chứa họ, dù cả hai đều là kiểu chuỗi) và phải nằm trong miền giá trị được quy ước trước (ví dụ: điểm chỉ được nằm trong 0..10).

	- Mỗi ô trong cột chỉ có thể chứa một giá trị (giá trị đơn) hoặc có thể trống.
		+ Nếu muốn chứa được nhiều giá trị (đa trị).
			1. Tạo thêm cột khác tên nhưng lưu cùng một loại giá trị.
			2. Sử dụng chuỗi để lưu trữ thông tin.
		+ Nếu muốn chứa giá trị phức, chia nhỏ và lưu trữ từng giá trị đơn của giá trị phức.
		+ Có thể chứa giá trị rỗng (NULL).

	- Trong một bảng có nhiều dòng và cột, nếu không quan tâm đến thứ tự của các dòng và cột, việc đổi thứ tự giữa cột với cột và dòng với dòng sẽ không làm ảnh hưởng đến dữ liệu (không kể thử tự - UnOrdered).

	- Vì bên trong bảng sẽ chứa dữ liệu, nên có thể sử dụng thêm các hàm, kiểu dữ liệu... để có thể truy xuất và chỉnh sửa dữ liệu.

----------

		[GIÁ TRỊ NULL]

Tất cả các giá trị trong cùng một cột phải đến từ một miền giá trị.

	- Mặc định, hầu hết các kiểu dữ liệu đều bao gồm một giá trị được biệt được gọi là giá trị NULL.

	- Đây là giá trị thứ ba, còn được gọi là UNKNOWN, bên cạnh hai giá trị TRUE và FALSE trong thuyết 3 giá trị luận lý (three-valued logic / three truth values).

Nếu giá trị trong một ô trả về NULL (có màu vàng), sẽ được hiểu theo nhiều cách khác nhau:

	1. Không xác định được (Unknown value): Không biết đến sự tồn tại hoặc biết có tồn tại nhưng không biết do không có ai cung cấp thông tin.

		Ví dụ:
			- Một mối quan hệ mập mờ, không rõ liệu một người có thích mình hay không (không biết có tồn tại tình cảm hay không).
			- Vừa thi xong, chắc chắn sẽ có điểm, nhưng giảng viên chưa chấm bài và chưa công bố điểm nên không biết điểm bao nhiêu.

	2. Bị che giấu/ Không khả dụng (Withheld/ Unavailable value): Chắc chắn có, nhưng không công bố vì một mục đích nào đó (cố ý che giấu).

		Ví dụ:
			- Một người chắc chắn có năm sinh, nhưng họ muốn che giấu thông tin này.
			- Một bệnh nhân không muốn tiết lộ thông tin về nhóm máu của mình.

	3. Vô nghĩa/ Không phù hợp để áp dụng (Inapplicable/ Not Applicable - N/A value): Không có ý nghĩa trong một ngữ cảnh nào đó.

		Ví dụ:
			- Thông tin về "Số lần mang thai" trong hồ sơ y tế của các bệnh nhân nam là vô nghĩa.
			- Thông tin về học vị: Cử nhân, Kỹ sư, Thạc sĩ, Tiến sĩ,... là vô nghĩa đối với một Tú tài đã dừng việc học.

	-> NULL đại diện cho một thứ chưa xác định được.

 Khi thiết kế, nên tránh những giá trị NULL vì nó sẽ gây ra mơ hồ.

	Ví dụ: Trong cột "Địa chỉ nhà" của bảng "Nhân viên", có hai ô cùng lưu giá trị NULL, ta không thể kết luận hai nhân viên này có cùng địa chỉ được.

Mỗi giá trị NULL được xem là một giá trị riêng biệt và khác với những giá trị NULL khác.
	- Không thể sử dụng các toán tử so sánh {>, <, =...}.
	- Thay vào đó, ta sẽ sử dụng các toán tử: IS NULL, IS NOT NULL, NOT (<Tên bảng> IS NULL) để kiểm tra và lọc ra những ô có giá trị là NULL.

------------------------------------------------------------

	[2. DƯỚI GÓC NHÌN CỦA RÀNG BUỘC DỮ LIỆU - CONSTRAINT]

Sẽ có trường hợp hai đối tượng / thực thể khác nhau hoàn toàn nhưng lại có cùng một mã số, gây khó khăn trong việc xác định duy nhất một đối tượng / thực thể.
	- Vì vậy, nếu các cột được áp dụng ràng buộc thì dữ liệu nhập vào sẽ theo đúng định dạng đã được quy định từ trước.
	- Nhưng cần tránh việc lạm dụng ràng buộc và gây khó chịu cho người cung cấp thông tin.

* Ràng buộc toàn vẹn (Integrity Constraint): Để đảm bảo tính nhất quán và an toàn, dữ liệu trong một bảng sẽ không thể được nhập một cách tuỳ tiện, mà phải thoả mãn một số ràng buộc và dữ liệu cũng phải có mối liên hệ với nhau.
	- Là những điều kiện bất biến, không được vi phạm trong một CSDL.
	- Được thực hiện trong quá trình thiết kế lược đề quan hệ, những ràng buộc về dữ liệu sẽ dần dần được gài vào.
	- Những ràng buộc này sẽ được kiểm tra trước khi thực hiện bất kỳ thao tác thêm-sửa-xoá nào về dữ liệu trong CSDL.

	-> Các ràng buộc giúp quy định dữ liệu nên và không nên như thế nào.

* Ràng buộc trong CSDL sẽ được chia làm 3 loại chính:

	1. Implicit Constraint (Default Constraint / Inherent Model-Based Constraint): Những ràng buộc vốn có của mô hình dữ liệu, tự động được HQTCSDL áp dụng cho dữ liệu mà không cần sự can thiệp từ con người.

		Ví dụ:
			- Tên của bảng không được trùng.
			- Tên của cột không được trùng.
			- Không thể có hai dòng trùng nhau.
			- Mỗi ô trong cột chỉ chứa giá trị đơn.
			- Không quan trọng thứ tự của các dòng và cột.

	2. Explicit Constraint (Schema-Based Constraint): Những ràng buộc được gài bằng những câu lệnh DDL (những câu lệnh tạo dựng dàn khung cho bảng) trong SQL hoặc thao tác trực tiếp trên giao diện của HQTCSDL.
	
	3. Semantic Constraint (Application-Based Constraint / Business Rule): Những ràng buộc nghiệp vụ được gài bằng những câu lệnh trong lập trình (ví dụ: if-else,...).
		Ví dụ:
			- Tiền lương chỉ có thể tăng.
			- Tiền lương của nhân viên không được cao hơn tiền lương của quản lý.
			- Nhân viên chỉ được làm tối đa 56g/tuần.

----------------------------------------

* Các loại ràng buộc tường minh (Explicit Constraint):

	1. Ràng buộc miền giá trị (Domain Constraint): Quy định những giá trị được phép nhận của một cột.
		- Để việc nhập giá trị cho cột được thành công, dữ liệu nhập vào phải:
			+ Là giá trị đơn.
			+ Nằm trong miền giá trị.
		- Giúp đảm bảo rằng dữ liệu được nhập vào cột đó phù hợp với ý nghĩa của cột.

		Ví dụ:
			- Điểm của sinh viên phải là các số nguyên: 0..10.
			- Giới tính chỉ có ba giá trị kiểu chuỗi: Nam, Nữ, Khác.

	2. Ràng buộc khoá (Key Constraint / Uniqueness Constraint): Là một hoặc nhiều cột, được sử dụng để đảm bảo mỗi dòng trong bảng là duy nhất.

		- Trong cuộc sống, luôn cần có cách để nhận diện đối tượng bằng một giá trị độc nhất, giúp dễ dàng hơn trong việc quản lý.
		
		- Vì vậy, thuộc tính khoá chính được sử dụng, mỗi khoá chính sẽ giúp xác định chính xác và duy nhất một dòng dữ liệu trong bảng.

			Ví dụ: cột "Mã đơn hàng", "Mã số sinh viên", "Mã thẻ căn cước công dân",...

		- Một hoặc nhiều cột có thể hợp lại để tạo thành khoá chính.
			+ Nếu chỉ có một cột, giá trị của cột này bắt buộc phải khác nhau giữa các thực thể.
			+ Nếu có nhiều cột hợp lại, chỉ cần các kết hợp không bị trùng là được.
				Ví dụ: [A1, B1], [A1, B2], [A2, B1], [A2, B2], [ ̶A̶2̶,̶ ̶B̶2̶].

		-> Cách để định vị một thông tin duy nhất giữa vô vàn thông tin.

		* Relation Key: Chìa khoá (cột) để mở một ổ khoá (dòng) - Giúp xác định duy nhất một ổ khoá.
			- Mỗi dòng phải có một giá trị khác nhau.
			- Không có dòng nào được phép mang giá trị NULL.

		* Phân loại khoá:

			- Siêu khoá (Super Key): Cũng là một hoặc nhiều cột giúp xác định duy nhất một dòng trong bảng.
				+ Có thể chỉ là một cột hoặc các cột sẽ kết hợp với nhau, thậm chí là tất cả các cột cùng kết hợp.
				+ Tạo thành một tập vô cùng lớn, dư thừa rất nhiều dữ liệu, chỉ để xác định được một dòng trong bảng.
				+ Nói cách khác, cứ là khoá - cứ giúp xác định một dòng trong bảng thì được gọi là siêu khoá.
				+ Đóng vai trò như "chợ đầu mối", chuyên "phân phối" khoá cho nơi khác.

				-> Một hoặc nhiều cột có tính chất duy nhất và không trùng lặp trong bảng.

				Ví dụ: Tất cả các cột đều có thể kết hợp để làm siêu khoá.

					PhòngThi (S̲B̲D̲, M̲ã̲S̲V̲, H̲ọ̲T̲ê̲n̲, N̲g̲à̲y̲S̲i̲n̲h̲)

			- Khoá tương đương / Khoá ứng viên (Candidate Key): Được trích xuất từ siêu khoá, nhưng chỉ chọn ra những tập bé nhất bằng cách loại bỏ đi những cột thừa.

				Ví dụ: Là tập bé nhất trong siêu khoá.

					PhòngThi (S̲B̲D̲, MãSV, HọTên, NgàySinh)

					PhòngThi (SBD, M̲ã̲S̲V̲, HọTên, NgàySinh)

			- Khoá chính (PRIMARY KEY - PK): Là khoá được chọn ra từ nhiều khoá ứng viên.
				+ Là một cột đặc biệt với giá trị bên trong bị cấm trùng trên mọi dòng (cấm trùng trên mọi ô cùng cột).
				+ Giá trị cấm trùng đó sẽ được sử dụng để làm đại diện cho cả một dòng, giúp xác định duy nhất một đối tượng / thực thể; từ đó mà các thao tác tìm kiếm, sắp xếp,... cũng trở nên dễ dàng hơn.
				+ Trong khoá chính đã bao gồm ràng buộc NOT NULL (NOT NULL Constraint).
				+ Nên chọn khoá chính là sự kết hợp của ít cột nhất (tốt nhất là chỉ có một cột) và không chứa đa trị.
					Ví dụ: Số điện thoại và email vẫn đủ để làm khoá chính, nhưng một người lại có thể có nhiều số điện thoại và email.
				+ Nên dựa vào quan hệ lập luận để chọn chứ không nên dựa vào giá trị của dữ liệu tại một thời điểm.
					Ví dụ: Tại một thời điểm, giá trị của các dữ liệu trong một cột có thể khác nhau, nhưng trong tương lai thì không chắc.
				+ Cũng không nên chọn những cột mà mình không có quyền kiểm soát (không nắm bắt được quy luật), nếu cần thiết thì sẽ phát sinh thêm cột.
					Ví dụ: Trong trường học có lưu cả số CMND/CCCD của sinh viên, nhưng lại quản lý theo mã sinh viên vì đây là mã số mà nhà trưởng nắm được quy luật và có thể kiểm soát được.

				* Tham chiếu (Reference): Từ nơi này trỏ đến nơi khác, từ nơi thuộc tính đang làm khoá ngoại "tham chiếu" đến nơi thuộc tính đang làm khoá chính.
					- Trong bảng có một cột, giá trị của cột này có được là nhờ tham chiếu (đi vạy mượn) từ một cột khoá chính trong bảng khác.
					- Bảng chứa khoá chính yêu cầu phải tồn tại trước (được lập liệu, có giá trị trước) thì nơi sử dụng làm khoá ngoại mới có thể tham chiếu đến.

			- Khoá ngoại (FOREIGN KEY - FK): Đang là khoá chính của một bảng, nhưng nay lại "xuất ngoại" / "vi hành" sang bảng khác.
				+ Đôi khi còn được gọi với một tên khác là ràng buộc tham chiếu (REFERENCE Constraint).
				+ Phát sinh khi các bảng có mối quan hệ với nhau và cần sử dụng dữ liệu của nhau.
				+ Thường được dùng để liên kết giữa các bảng, hạn chế sai sót trong quá trình lưu trữ dữ liệu.
				+ Khoá chính của một bảng (nơi cung cấp dịch vụ) sẽ nằm yên, đợi khoá ngoại của bảng khác (nơi sử dụng dịch vụ) tham chiếu đến để sử dụng.
				+ Khoá ngoại yêu cầu đi đến nơi khác và tiến hành JOIN để xem và lấy dữ liệu.
				+ Tuy không yêu cầu trùng tên cột giữa hai bảng, nhưng bắt buộc phải có cùng kiểu dữ liệu và trùng miền giá trị (có gì dùng nấy).
				+ Được phép nhận giá trị NULL, điều này nghĩa là giữa hai dòng trong bảng chưa hình thành bất kì mối quan hệ nào.

				Ví dụ: Khoá chính "xuất ngoại" / "vi hành" sang bảng khác.

								    Khoá ngoại ------
										    |
										    v
					NhânViên (M̲ã̲N̲V̲, HọTên, NgàySinh, QuêQuán, M̰ã̰P̰B̰)
										    |
						   ----------- Tham chiếu -----------
						   |
						   v
					PhòngBan (M̲ã̲P̲B̲, TênPB, ĐịaChỉ)
						   ^
						   |
						   ------ Khoá chính

			- Khoá phức (Composite key): Phải có tối thiểu từ hai cột trở lên cùng làm khoá chính.

	3. Ràng buộc NOT NULL (NOT NULL Constraint): Khá giống với ràng buộc về khoá chính khi ràng buộc NOT NULL cũng cấm giá trị trong một cột được phép là NULL.
		- Đồng nghĩa với việc, khi nhập dữ liệu hoặc chỉnh sửa dữ liệu cho một dòng, dòng đó không được phép chứa giá trị NULL tại cột được chỉ định NOT NULL.
		- Phải chỉ định rõ khi cần thiết, vì mặc định các kiểu dữ liệu cho phép NULL.
		- Trong thường hợp của khoá chính, ràng buộc NOT NULL là mặc định.

	4. Ràng buộc toàn vẹn thực thể (Entity Integrity Constraint): Khoá chính phải luôn luôn có giá trị, không được NULL (đã ngầm có NOT NULL).

	5. Ràng buộc toàn vẹn tham chiếu (Referential Integrity Constraint): Là ràng buộc giữa ít nhất hai bảng thông qua khoá ngoại.
		* Bên đi tham chiếu (Referencing Relation): Chủ động chứa cột của bảng khác.
		* Bên được tham chiếu (Referenced Relation): Nằm yên để người khác dùng cột của mình.

		- Khi cột thuộc tính khoá chính trong bảng của bên "được tham chiếu" chạy sang làm thuộc tính khoá ngoại trong bảng của bên "đi tham chiếu".
		- Cho gì dùng nấy, không được tài lanh sử dụng những giá trị mà chính nơi cho cũng không có.
		- Vì khoá ngoại được phép NULL nên thà để trống vẫn còn hơn là nhập giá trị tầm bậy.

	- NULL: Được quyền bỏ trống giá trị của thuộc tính. Mặc định sẽ là NULL.

	- NOT NULL: Giá trị trong một ô không được phép mang trạng thái NULL, mà bắt buộc phải có giá trị.

		+ Thường thấy dưới dạng dấu hoa thị màu đỏ (*) tại các biểu mẫu / đơn nhập dữ liệu.

		+ Nhưng không phải lúc nào cũng sử dụng NOT NULL, vì người dùng rất ngại trong việc bị sưu tầm thông tin.

	- UNIQUE:
		+ Không bắt buộc phải nhập dữ liệu, mặc định sẽ bằng NULL nếu không nhập.
		+ Nếu có nhập liệu, dữ liệu này sẽ là duy nhất.
		+ Vì mỗi bảng chỉ được phép có một khoá chính, nên có thể sử dụng hai ràng buộc là UNION và NOT NULL để cho biết đây là khoá tương đương / khoá ứng viên (Candidate Key).

	- CHECK

		- Miền giá trị (RANGE): Chỉ cho phép giá trị nhập vào nằm trong một khoảng nhất định.

	- DEFAULT: Đưa trước một giá trị nào đó vào để làm giá trị mặc định nếu trước đó thông tin được để trống.

--------------------

Các ràng buộc kể trên được gọi là State Constraint (Static Constraint) vì nó liên quan đến trạng thái hợp lệ (valid state) của CSDL.

Bên cạnh State Constraint (Static Constraint), còn một loại ràng buộc khác được gọi là Transition Constraint (Dynamic Constraint) vì nó liên quan đến việc thay đổi trạng thái (state change) của CSDL.

Ngoài ra, các ràng buộc dữ liệu cũng được phân loại theo số lượng bảng:

	* Một bảng:

		- Miền giá trị: Các giá trị mà một thuộc tính có thể nhận.

		- Giữa các dòng trong bảng: Không có việc trùng lặp dữ liệu giữa hai dòng.
			+ Tuy không quan tâm đến thứ tự sắp xếp giữa các dòng.
			+ Nhưng giữa các dòng không được trùng thông tin, dòng đến sau phải cẩn thận dòng đến trước.

			-> Khoá chính.

		- Giữa các cột trong bảng: Phải có tính hợp lý (ví dụ: trong một khoá học, ngày bắt đầu ≤ ngày kết thúc).

	* Nhiều bảng với nhau:

		- Tham chiếu: Bảng được tham chiếu phải tồn tại trước, để bảng đi tham chiếu có thể lấy giá trị.
			-> Khoá ngoại.

		- Các dòng giữa các bảng: Mỗi khi phát sinh một dòng trong bảng, sẽ có một dòng trong bảng khác được phát sinh theo (ví dụ: Mỗi dòng hoá đơn sẽ phát sinh một dòng Chi tiết hoá đơn).

		- Các cột giữa các bảng: Tuy dữ liệu được tách thành nhiều bảng khác nhau, nhưng vẫn phải giữa được tính liên kết (ví dụ: ngày sinh của trưởng phòng được lưu trong bảng NhânViên phải nhỏ hơn ngày nhận chức được lưu trong bảng LàmTrưởngĐơnVị.)

----------------------------------------

* Các cơ chế xử lý khi phát hiện những vi phạm RBTV: Được tự động áp dụng mỗi khi có tác động lên giá trị của khoá chính. RBTV

	- Là những cơ chế mà HQTCSDL cho phép cài đặt mỗi khi có phát sinh những ràng buộc khoá ngoại giữa các bảng.

	1. Cơ chế mặc định: Tự động từ chối mọi hành vi vi phạm RBTV, nếu sửa từ đúng thành sai thì sẽ chủ động giữ lại giá trị đúng.

	2. Cơ chế thay thế: Tự động cập nhật giá trị khoá ngoại khi giá trị khoá chính tương ứng bị thay đổi.

	3. Cơ chế sử dụng giá trị NULL: Mọi giá trị vi phạm RBTV sẽ tự động được thiết lập giá trị là NULL.

----------------------------------------

* Ràng buộc (Constraint): Ràng buộc là cách mà người thiết kế cơ sở dữ liệu ép dữ liệu khi đưa vào bảng phải tuân theo một dạng nào đó.

	Ví dụ 1: Đường Bá Hổ có ba việc không làm.
		- Không rót nước, bưng trà.
			&&
		- Không giặt giũ, lau nhà.
			&&
		- Không dọn giường, xếp ga.

	Ví dụ 2: Tối đi chơi, nhớ về nhà sớm.
		- Sớm được định nghĩa:
			+ Buổi tối trong cùng ngày && trước 22g đêm.

	- Mặc định, các hệ quản trị cơ sở dữ liệu cho phép một cột không cần thiết phải có ràng buộc.

	- Nhưng nếu không có ràng buộc thì dữ liệu nhận vào sẽ không được như ý muốn.

	- Vì sẽ có rất nhiều quy tắc (rule), nên mỗi ràng buộc trong cơ sở dữ liệu được quyền đặt cho một cái tên để dễ dàng gợi nhớ, kiểm soát và tránh nhầm lẫn.

		+ Mặc định, các Database Engine sẽ tự động đặt tên cho các ràng buộc tìm thấy (khi ta bắt đầu nhập những lệnh DDL - những câu lệnh tạo dựng dàn khung cho bảng).

		+ Ngoài việc tự động đặt tên, Database Engine còn cung cấp cơ chế cho phép ta tự động đặt tên cho từng ràng buộc.

			* Quy tắc đặt tên sẽ giống như quy tắc đặt tên cho hằng số trong lập trình: In hoa toàn bộ chữ cái và viết cách nhau bằng dấu gạch dưới _.

				Ví dụ: Gài ràng buộc khoá chính cho cột StudentID
					-- Sử dụng từ khoá CONSTRAINT để gài ràng buộc
					-- và đặt tên cho ràng buộc là PK_STUDENTV6
					CONSTRAINT PK_STUDENTV6
					PRIMARY KEY (StudentID)

	- Việc gài ràng buộc nên được thực hiện trước khi bảng có dữ liệu bên trong, vì nếu trước đó đã có dữ liệu không được nhập vào theo đúng theo định dạng, thì việc gài ràng buộc về sau này cũng không có nhiều ý nghĩa nếu dữ liệu bị nhập sai đó không được xoá đi.

	- Ngoài việc khai báo ràng buộc chung trong lúc tạo bảng bằng, ta cũng có thể tách việc tạo ràng buộc khoá chính và khoá ngoại ra hẳn thành một phần riêng bằng câu lệnh ALTER.
		-> Tạo bảng trước, sửa bảng sau.

		Ví dụ: Câu lệnh chuẩn để gài thêm ràng buộc khoá chính cho một bảng.
			ALTER TABLE StudentV7		-- Chỉnh sửa bảng
			ADD CONSTRAINT PK_STUDENTV7	-- Thêm ràng buộc
			PRIMARY KEY (StudentID)		-- Loại ràng buộc

	- Đã thêm được thì chắc chắn cũng sẽ xoá được, ta cũng có thể xoá ràng buộc bằng câu lệnh ALTER kết hợp với câu lệnh DROP. Ngoài việc xoá những khoá chính do ta tự tạo và đặt tên, những khoá chính do Database Engine tự đặt tên cũng sẽ có thể xoá được, miễn ta sao chép được chính xác tên tự động phát sinh.

		Ví dụ: Câu lệnh chuẩn để xoá ràng buộc khoá chính cho một bảng.
			ALTER TABLE StudentV7		-- Chỉnh sửa bảng
			DROP CONSTRAINT PK_STUDENTV7	-- Xoá ràng buộc

	-> Đặt ra quy tắc (rule) cho việc nhập dữ liệu.

------------------------------------------------------------

	[3. DƯỚI GÓC NHÌN CỦA THAO TÁC TRÊN DỮ LIỆU - OPERATION]

Sau khi đã tạo ra được cấu trúc để lưu trữ dữ liệu, không còn bàn về lý thuyết và thiết kế nữa, mà chỉ quan tâm đến những dữ liệu trong CSDL và những truy vấn trên đấy.

	- Cho phép khai thác "không xâm lấn": truy vấn (xem), sắp xếp,... dữ liệu trong bảng.
		+ Cho phép truy vấn, rút trích dữ liệu và đưa ra thông tin cần thiết.
		+ Giúp trả lời cho những câu hỏi liên quan đến thống kê, báo cáo và phân tích dữ liệu.
		+ Đây là chế độ "chỉ xem", sẽ không làm ảnh hưởng đến dữ liệu và cũng không gây ra các vi phạm về ràng buộc dữ liệu.

		-> Phép toán đại số quan hệ (Relational Algebra Operation).

	- Cho phép khai thác "có xâm lấn": thêm-sửa-xoá dữ liệu trong bảng.
		+ Cho phép tạo ra dữ liệu và quản lý sự thay đổi của dữ liệu theo thời gian.
		+ Giúp duy trì tính đúng đắn của dữ liệu trong bảng.
		+ Đây là chế độ "chỉnh sửa", sẽ làm ảnh hướng đến dữ liệu, có nguy cơ gây ra các vi phạm về ràng buộc dữ liệu và yêu cầu phải có cách để xử lý.

		-> Phép toán cập nhật (Update Operation / Modification Operation).

----------------------------------------

		[PHÉP TOÁN ĐẠI SỐ QUAN HỆ - RELATIONAL ALGEBRA OPERATION]

Trong đại số quan hệ:
	- Một tập hợp (set) các bộ dữ liệu (tuple) sẽ tạo thành một quan hệ (relation).
	- Mỗi quan hệ (bảng) được xem như một biến (toán hạng) và có thể tham gia vào một biểu thức.
	- Vì vậy, ta có thể áp dụng các phép toán lên các biến này để ra được một kết quả mới mà không làm ảnh hưởng đến các giá trị gốc.

* Phép toán đại số quan hệ (Relational Algebra Operation): Chỉ được sử dụng để khai thác "không xâm lấn" dữ liệu trong CSDL.
	- Là bộ một các phép toán và quy tắc, được áp dụng lên dữ liệu trong bảng.
	- Được xem là một ngôn ngữ thủ tục vì có chỉ định rõ cách thức và thứ tự thực hiện truy vấn.
	- Giúp khai thác (lấy) dữ liệu trong các bảng của một HQTCSDL.
	- Hiểu được ĐSQH là chìa khoá để hiểu cách xử lý và tối ưu hoá câu truy vấn.
	- Tạo ra một bảng mới để lưu kết quả chứ không hề làm thay đổi bảng ban đầu.
		+ Có thể nhận đầu vào là một hoặc nhiều bảng.
		+ Nhưng kết quả đầu ra chỉ là duy nhất một bảng mới.

		-> ĐSQH là ngôn ngữ có tính chất đóng (closure).

	-> Xác định cách truy vấn và thao tác dữ liệu.

* Bảng cơ sở / Bảng gốc (Base Relation): Là bảng thực sự chưa dữ liệu gốc, được lưu xuống ổ đĩa đưới dạng tập tin.

* Bảng mới (Composition of Relation): Là bảng mới, có thể xem là một bảng ảo/ khung nhìn - view (được lưu trong RAM), được tạo ra từ sự kết hợp (composition) của hai bảng và chứa thông tin từ cả hai bảng.

* Biểu thức đại số quan hệ (Relational Algebra Expression): Gồm các phép toán ĐSQH nối với nhau, sắp xếp theo một tứ tự, tạo thành một chuỗi (sequence) để mô tả câu truy vấn.

	Ví dụ: π Fname, Lname, Salary (σ Dno = 5 (EMPLOYEE))

Để xây dựng một biểu thức ĐSQH có thể rất dài và phức tạp, ta có thể.

	- Áp dụng quy tắc về thứ tự ưu tiên trong các phép toán trong ĐSQH:

		1. Các phép toán một ngôi:
			- Phép chọn (SELECT).
			- Phép chiếu (PROJECT).
			- Phép đổi Phép đổi tên (RENAME).

		2. Kết hợp các bảng:
			- Phép tích Đềcác (CARTESIAN PRODUCT).
			- Phép kết nối (JOIN).

		3.
			- Phép giao (INTERSECTION).
			- Phép chia (DIVISION).

		4.
			- Phép hội (UNION).
			- Phép trừ (SET DIFFERENCE).

	- Để viết một biểu thức phức tạp, ta có hai cách:

		1. Biểu diễn bằng một chuỗi / tầng (sequence / cascade) trên một dòng (in-line expression): Các phép toán được lồng vào nhau và có thể sử dụng dấu ngoặc để thay đổi độ ưu tiên.
			Ví dụ: π MaNV, MaDA (NHANVIEN_DUAN) ÷ π MaDA (σ MaPB = 1 (DUAN))

		2. Sử dụng phép gán (Assignment Operation): Cho phép đặt tên cho kết quả truy vấn để tái sử dụng giống như việc lưu giá trị vào trong biến.

			* Kí hiệu: R’ ← E.

			- Có thể được sử dụng để đặt tên tạm cho một bảng và các thuộc tính của bảng.
			- Có thể được dùng để lưu lại kết quả của một phép toán (kết quả là một bảng mới).
			- Giúp đơn giản hoá một chuỗi biểu thức ĐSQH bằng tên trung gian đã lưu lại.

			Ví dụ:
				// Đặt tên tạm cho bảng và thuộc tính của bảng
				BRIEF_EMPLOYEE_INFOS (First_name, Last_name, Salary) ← π Fname, Lname, Salary (EMPLOYEE)

				// Lưu lại kết quả của một phép toán
				DEP5_EMPS ← σ Dno = 5 (EMPLOYEE)
				RESULT ← π Fname, Lname, Salary (DEP5_EMPS)

				// Đơn giản hoá một chuỗi biểu thức ĐSQH
				// bằng tên đã lưu lại
				* Gốc:
					1. π MaHV, MaMH (KETQUATHI) ÷ π MaMH (MONHOC)
					2. π MaNV, MaDA (NHANVIEN_DUAN) ÷ π MaDA (σ MaPB = 1 (DUAN))

				* Sử dụng phép gán:

					1.
						R1 ← π MaHV, MaMH (KETQUATHI)
						R2 ← π MaMH (MONHOC)
						KQ ← R1 ÷ R2

					2.
						R1 ← π MaNV, MaDA (NHANVIEN_DUAN)
						R2 ← π MaDA (σ MaPB = 1 (DUAN))
						KQ ← R1 ÷ R2

--------------------

Trên thực tế, có rất nhiều cách để phân loại các phép toán của ĐSQH, một trong những cách đó (tạm gọi là cách 1) là:

----------

	* Phép toán trên một bảng (Unary Relational Operation): Rút trích ra một phần thông tin của bảng.

		1. Phép chọn (SELECT / RESTRICT / FILTER) | σ: Lựa dòng để hiển thị.

			* Công thức tổng quát: σ ϕ (R) = {t | t ∈ R AND ϕ(t)}

				- Điều kiện lọc là ϕ (phi - Φ / φ) của phép chọn σ (sigma) trên bảng R sẽ tương đương như các câu lệnh if trong lập trình.

				- Điều kiện lọc (vị từ - predicate) là một biểu thức luận lý - đúng/sai (Boolean Expression), gọi tắt là biểu thức điều kiện, được tạo thành từ một số mệnh đề (clause), gồm ba thành phần chính:

					1. Tên thuộc tính (Attribute Name): Tên các thuộc tính có trong bảng R.

					2. Các toán tử so sánh (Comparison Operator): =, ≠, <, ≤, >, ≥.

					3.1. Giá trị hằng (Constant Value): Giá trị nằm trong miền giá trị của thuộc tính.
						σ A ϴ B (R) = {t | t ∈ R, t(A) ϴ t(B)}
						
					3.2. Tên một thuộc tính khác (Another Attribute Name).
						σ A ϴ v (R) = {t | t ∈ R, t(A) ϴ v}

					Ví dụ: Các dạng phép chọn khác nhau.
						- σ A ϴ v (R): σ Salary > 30000 (EMPLOYEE)
						- σ A ϴ B (R): σ Age = Weight (PERSON)

				- Giữa các mệnh đề (clause) có thể kết nối với nhau bằng các toán tử luận lý (Boolean Operator): NOT (¬), AND (∧), OR (∨).
					+ Độ ưu tiên khi thực hiện các phép toán luận lý:
						1. NOT
						2. AND
						3. OR
					+ Để thay đổi độ ưu tiên này, bắt buộc phải sử dụng cặp dấu ngoặc đơn.

					Ví dụ: σ (Dno = 4 AND Salary > 30000) (EMPLOYEE)

				- Sau khi chọn lọc.
					+ Kết quả sẽ tạo ra một bảng mới, chỉ chứa những dòng thoả điều kiện trong R.
					+ Số cột trong bảng mới sẽ bằng so với với số cột trong R.
					+ Số dòng trong bảng mới có thể ít hơn hoặc bằng (dòng nào cũng thoả điều kiện) so với số dòng trong R; thậm chí là bảng rỗng (không có dòng nào, chỉ có đầy đủ cột) nếu không có dòng nào thoả điều kiện lọc.

				- Phép chọn có tính giao hoán (commutative):
					σ <dk₁> (σ <dk₂> (R))
				     =
					σ <dk₂> (σ <dk₁> (R))

				- Các điều kiện của phép chọn có thể được lồng nhau hoặc kết hợp với nhau bằng toán tử AND.
					σ <dk₁> (σ <dk₂> (... (σ <dkₙ> (R)) ...))
				     =
					σ <dk₁> AND <dk₂> AND ... AND <dkₙ> (R)

				- Nhưng trong thực tế, để tối ưu hiệu xuất thực thi...
					+ Nên sử dụng kiểu lồng nhau, vì số lượng kết quả sẽ giảm đi sau mỗi phép chọn.
						| σ <dk₁> (σ <dk₂> (R))
					+ Nếu kết hợp với nhau bằng toán tử AND, mặc dù sẽ dễ đọc hơn và chỉ thực hiện lọc một lần duy nhất, nhưng số lần kiểm tra điều kiện sẽ nhiều hơn.
						| σ <dk₁> AND <dk₂> (R)

			* Trong SQL, điều kiện chọn chính là mệnh đề WHERE.

				Ví dụ: Phép chọn trong SQL.

					- Phép chọn: σ Dno = 4 AND Salary > 25000 (EMPLOYEE)

					- Mệnh đề WHERE:
						SELECT *
						FROM EMPLOYEE
						WHERE Dno = 4 AND Salary > 25000;

			* Các toán tử có thể sử dụng:

				- Các toán tử so sánh: =, ≠, <, ≤, >, ≥.
					+ Chỉ áp dụng cho các thuộc tính với miền giá trị có thứ tự (ví dụ: số, chuỗi, ngày-tháng-năm,...).
					+ Các thuộc tính với miền giá trị không có thứ tự sẽ chỉ có thể sử dụng hai toán tử so sánh '=' và '≠' (ví dụ: màu sắc,...).

				- Các toán tử luận lý: NOT (¬), AND (∧), OR (∨).
					+ AND: Chỉ đúng khi tất cả cùng đúng.
					+ OR: Chỉ sai khi tất cả cùng sai (chỉ cần 1 trong nhiều cái đúng là sẽ đúng).
					+ NOT: 

			Ví dụ: Chọn ra tất cả nhân viên làm việc ở phòng 4 và có lương hơn 25.000tr/năm hoặc làm việc ở phòng 5 và có lương trên 30.000tr/năm.

				σ (Dno = 4 AND Salary > 25000) OR (Dno = 5 AND Salary > 30000) (EMPLOYEE)


		2. Phép chiếu (PROJECT) | π: Lựa cột để hiển thị.

			* Công thức: π <cột₁, cột₂, ..., cộtₙ> (R) = {t[A₁, A₂, ..., Aₙ] | t ∈ R}

				- Điều kiện để lọc của phép chiếu π (pi) chính là tên của các cột (tiêu đề của bảng - header) cần hiển thị ra.

				- Sau khi chọn lọc.
					+ Tạo ra một bảng mới, chứa danh sách các cột cần chiếu trong R.
					+ Thứ tự của các cột sẽ tương đương với thứ tự được liệt kê trong phép chiếu (có thể dùng phép chiếu để thay đổi thứ tự hiển thị của cột).
					+ Số cột trong bảng mới có thể ít hơn, bằng hoặc thậm chí nhiều hơn (tạo thêm cột mới để chứa dữ liệu) so với số cột trong R; cũng có thể là bảng rỗng (không có cột nào, nên cũng không có dòng nào) nếu không có cột nào thoả điều kiện lọc.

				- Vì kết quả là một tập hợp (set), nên bảng mới sẽ loại bỏ đi các dòng bị trùng (duplicate elimination) sau khi chiếu.
					+ Trước khi chiếu, một số dòng không bị trùng thông tin vì có một giá trị nào đó trong dòng khác với các dòng còn lại.
					+ Sau khi chiếu, nếu không bao gồm các cột khoá chính, số lượng thông tin được sử dụng để phân biệt các dòng có thể bị ít đi, dễ dẫn đến việc bị trùng thông tin giữa các dòng.

					-> Giảm số cột.

				- Các phép chiếu cũng có thể được lồng vào nhau để tạo thành một chuỗi phép toán.
					+ Nhưng phép chiếu bên trong phải có nhiều cột hơn số cột của phép chiếu bên ngoài.
					+ Phép chiếu bên ngoài chỉ có thể chiếu các cột mà phép chiếu bên trong đang có, nếu không sẽ tạo ra một biểu thức lỗi.
					+ Vì vậy, phép chiếu không có tính giao hoán.

					π <list1> (π <list2> (R))
				     =
					π <list1> (R)

			* Trong SQL, danh sách cột được liệt kê trong mệnh đề SELECT.
				- Nhưng trong phép chiếu, kết quả trả về mặc định sẽ là một tập  hợp (set) với các dòng không trùng nhau.
				- Còn kết quả mặc định của mệnh đề SELECT trong SQL lại trả về một tập hợp đa phần tử (multiset / bag) với các dòng có thể trùng nhau.
				- Vì các dòng bị trùng trong SQL sẽ không được tự động xoá (eliminated) giống như trong phép chiếu, nên yêu cầu phải có thêm từ khoá DISTINCT ở phía sau mệnh đề SELECT để loại bỏ đi các dòng bị trùng.

				Ví dụ: Phép chiếu cấm trùng dòng trong SQL.

					- Phép chiếu: π Gender, Salary (EMPLOYEE)

					- Mệnh đề SELECT và từ khoá DISTINCT:
						SELECT DISTINCT Gender, Salary
						FROM EMPLOYEE

			* Phép chiếu tổng quát (Generalized Projection):

				- Ngoài việc sử dụng phép chiếu để giảm số cột.
					+ Giúp hai bảng dễ dàng thoả điều kiện sử dụng các phép toán tập hợp: hợp, giao và trừ.
					+ Ta cũng có thể sử dụng phép chiếu để thay đổi thông tin hiển thị hoặc phát sinh ra cột (ví dụ: thuộc tính dẫn xuất trong ERD).

				- Có thể sử dụng các phép toán số học lên các cột.
					+ Phép toán sẽ thay đổi một cột nào đấy.
					+ Thậm chí là phát sinh cột mới từ những cột có sẵn.

					-> Tăng số cột.

				Ví dụ:
					// Thay đổi một cột trong bảng
					π A * 2, B (R)

					// Phát sinh cột mới
					π (A + B) -> C, A, B (R)

						- A và B là hai cột khác nhau, sử dụng các phép toán để phát sinh ra bảng C.
						- Sau đó hiển thị cả ba bảng: C, A và B.


		3. Phép đổi tên (RENAME) | ρ: Đổi tên của bảng và cột.

			* Công thức
				1. Đổi tên bảng: ρ <tên-bảng-mới> (R)
				2. Đổi tên cột: ρ <tên-cột-mới₁, ..., cột-cột-mớiₙ> (R)
				3. Đổi tên bảng và tên cột: ρ <tên bảng mới> <tên-cột-mới₁, ..., cột-cột-mớiₙ> (R)

				- Đằng sau kí hiệu ρ (rô - rho) có thể là tên mới của bảng, tên mới của cột hoặc cả hai.

				- Khi đổi tên nhiều cột, những cột nào không muốn đổi tên thì cứ giữ nguyên tên cũ.

				Ví dụ: Xét bảng R(B, C, D).
					- Đổi tên bảng R -> S: ρ S (R)
					- Đổi tên chỉ một cột (B, C, D) -> (X, C, D): ρ X, C, D (R)
					- Đổi cả tên bảng và tên cột: ρ S (X, C, D) (R)

			* Trong SQL, ta có thể đặt bí danh (alias) cho bảng và cột bằng mệnh đề AS.
				- Đây là bí danh (tên tạm), chỉ tồn tại trong thời gian thực hiện truy vấn, nên sẽ không làm thay đổi cấu trúc bảng.
				- Mệnh đề WHERE sẽ được thực thi trước mệnh đề SELECT, nên không thể sử dụng bí danh của cột trong WHERE.

				Ví dụ: Đặt bí danh cho bảng và thuộc tính của bảng NHANVIEN.

					SELECT NHANVIEN.Fname AS TenNV, NHANVIEN.Lname AS HoNV
					FROM EMPLOYEE AS NV
					WHERE NV.Dno = 5 AND NV.Lname = 'Nguyen'

----------

	* Phép toán trên hai bảng (Binary Relational Operation): Tương tác giữa các bảng.

		1. Phép toán tập hợp (Set Operation):

			- Nếu chỉ tính riêng từng bảng, ta sẽ không thể áp dụng được các phép toán tập hợp, nhưng sau khi đã thực hiện từng phép toán trên một bảng và nhận về kết quả, ta có thể áp dụng các phép toán tập hợp để liên kết các kết quả này lại với nhau.
				+ Cần ít nhất hai bảng để có thể thực hiện phép toán.
				+ Tuy không thể trực tiếp sử dụng trên một bảng, nhưng vẫn có thể được dùng để kết hợp giữa hai bảng với nhau.

				-> Chỉ sử dụng khi có từ hai bảng trở lên.

			- Chỉ những bảng có cùng lược đồ mới áp dụng được phép toán tập hợp (không áp dụng cho phép tích Đềcác vì không được xem là một phần của các phép toán tập hợp).
				+ Có cùng số cột (tên cột không cần phải trùng nhau) và vị trí tương ứng.
				+ Có cùng miền giá trị trong mỗi cột.

				-> Chỉ áp dụng được khi giữa các bảng có tính khả hợp/ tương thích (Union Compatibility / Type Compatibility).

			- Kết quả là một bảng mới có cùng tên thuộc tính với bảng thứ nhất và tự động loại bỏ những dòng bị trùng.

			1.1. Phép hợp / Phép hội (UNION) | ∪: Gom toàn bộ các dòng trong hai bảng lại với nhau và loại bỏ những dòng bị trùng lặp.

				* Công thức: R ∪ S = {t ∣ t ∈ R OR t ∈ S}

					Ví dụ: Liệt kê những sinh viên có đăng ký học một trong hai môn.

					SVHocLapTrinhMang	SVHocKhaiPhaDuLieu
					---------------------	---------------------
					| MaSV | HoTenSV    |	| MaSV | HoTenSV    |
					|------|------------|	|------|------------|
					| NV01 | Nguyễn An  |	| NV03 | Lê Minh    |
					| NV02 | Trần Dũng  |	| NV04 | Hoàng Linh |
					| NV03 | Lê Minh    |	| NV07 | Hứa Cường  |
					| NV04 | Hoàng Linh |	| NV08 | Đinh Lực   |
					---------------------	| NV09 | Châu Trì   |
								---------------------

					SVHocLapTrinhMang ∪ SVHocKhaiPhaDuLieu

						---------------------
						| MaSV | HoTenSV    |
						|------|------------|
						| NV01 | Nguyễn An  |
						| NV02 | Trần Dũng  |
						| NV03 | Lê Minh    |
						| NV04 | Hoàng Linh |
						| NV07 | Hứa Cường  |
						| NV08 | Đinh Lực   |
						| NV09 | Châu Trì   |
						---------------------
			

			1.2. Phép giao (INTERSECTION) | ∩: Chỉ lấy những dòng chung của hai bảng.

				* Công thức: R ∩ S = {t ∣ t ∈ R AND t ∈ S}

					Ví dụ: Tìm ra những sinh viên có đăng ký học cả hai môn.

					SVHocLapTrinhMang	SVHocKhaiPhaDuLieu
					---------------------	---------------------
					| MaSV | HoTenSV    |	| MaSV | HoTenSV    |
					|------|------------|	|------|------------|
					| NV01 | Nguyễn An  |	| NV03 | Lê Minh    |
					| NV02 | Trần Dũng  |	| NV04 | Hoàng Linh |
					| NV03 | Lê Minh    |	| NV07 | Hứa Cường  |
					| NV04 | Hoàng Linh |	| NV08 | Đinh Lực   |
					---------------------	| NV09 | Châu Trì   |
								---------------------

					SVHocLapTrinhMang ∩ SVHocKhaiPhaDuLieu

						---------------------
						| MaSV | HoTenSV    |
						|------|------------|
						| NV03 | Lê Minh    |
						| NV04 | Hoàng Linh |
						---------------------
			
			* Lưu ý: Riêng phép hội và phép giao sẽ có thêm hai tính chất.

				* Giao hoán:
					R ∪ S = S ∪ R
					R ∩ S = S ∩ R

				* Kết hợp:
					R ∪ (S ∪ T) = (R ∪ S) ∪ T
					R ∩ (S ∩ T) = (R ∩ S) ∩ T


			1.3. Phép trừ / Phép hiệu (SET DIFFERENCE / EXCEPT / MINUS) | '−': Chỉ bao gồm những dòng riêng của một bảng.

				* Công thức: R − S = {t ∣ t ∈ R AND t ∉ S}

					Ví dụ: Tìm ra những nhân viên chưa từng tham gia dự án.

					NhanVien		NhanVien_DuAn
					---------------------	---------------
					| MaNV | HoTenNV    |	| MaDA | MaNV |
					|------|------------|	|------|------|
					| NV01 | Nguyễn An  |	| DA01 | NV01 |
					| NV02 | Trần Dũng  |	| DA02 | NV03 |
					| NV03 | Lê Minh    |	| DA03 | NV01 |
					| NV04 | Hoàng Linh |	| DA04 | NV04 |
					| NV05 | Đỗ Đạt     |	| DA05 | NV05 |
					| NV06 | Võ Quân    |	| DA06 | NV01 |
					---------------------	---------------

					π MaNV (NhanVien) − π MaNV (NhanVien_DuAn)
					--------		--------
					| MaNV |		| MaNV |
					|------|		|------|
					| NV01 |		| NV01 |
					| NV02 |		| NV03 |
					| NV03 |		| NV04 |
					| NV04 |		| NV05 |
					| NV05 |		--------
					| NV06 |
					--------

						KetQua (những dòng riêng của NhanVien)
							--------
							| MaNV |
							|------|
							| NV02 |
							| NV06 |
							--------


					- Phép trừ không có tính giao hoán:
						R − S ≠ S − R

					- Ngoài ra, ta có thể biểu diễn phép giao bằng phép trừ: R ∩ S = R − (R − S).
			
			* Trong SQL cũng có các mệnh đề UNION, INTERSECT và EXCEPT tương ứng với các phép toán tập hợp.
				- Các phép toán này trên SQL cũng sẽ tự động loại bỏ đi những dòng trùng (không giống như phép chiếu của SQL).
				- Vì vậy, SQL có bổ sung thêm các từ khoá UNION ALL, INTERSECT ALL và EXCEPT ALL để bỏ qua việc tự động loại bỏ đi kết quả trùng.

				Ví dụ: Các phép toán tập hợp trong SQL.

					SinhVien (7 dòng)	GiangVien (5 dòng)
					----------------	----------------
					| Ho   | Ten   |	| HoGV | TenGV |
					|------|-------|	|------|-------|
					| Hoang| Linh  |	| Ngo  | Van   |
					| Do   | Dinh  |	| Bui  | Chau  |
					| Dinh | Dat   |	| Hoang| Linh  |
					| Vo   | Xuan  |	| Pham | Huong |
					| Bach | Khang |	| Do   | Dinh  |
					| Cao  | Vinh  |	----------------
					| Tran | An    |
					----------------


					- Phép hội: SinhVien ∪ GiangVien (10 dòng)

					- Mệnh đề UNION:
						SELECT Ho, Ten FROM SinhVien
						UNION
						SELECT HoGV, TenGV FROM GiangVien

						----------------
						| Ho   | Ten   |
						|------|-------|
						| Hoang| Linh  |
						| Do   | Dinh  |
						| Dinh | Dat   |
						| Vo   | Xuan  |
						| Bach | Khang |
						| Cao  | Vinh  |
						| Tran | An    |
						| Ngo  | Van   |
						| Bui  | Chau  |
						| Pham | Huong |
						----------------


					- Phép giao: SinhVien ∩ GiangVien (2 dòng)

					- Mệnh đề INTERSECTION:
						SELECT Ho, Ten FROM SinhVien
						INTERSECTION
						SELECT HoGV, TenGV FROM GiangVien

						----------------
						| Ho   | Ten   |
						|------|-------|
						| Hoang| Linh  |
						| Do   | Dinh  |
						----------------


					- Phép trừ:
						SinhVien − GiangVien (5 dòng)
						GiangVien − SinhVien (3 dòng)

					- Mệnh đề INTERSECTION:
						SELECT Ho, Ten FROM SinhVien
						EXCEPT
						SELECT HoGV, TenGV FROM GiangVien

						----------------
						| Ho   | Ten   |
						|------|-------|
						| Dinh | Dat   |
						| Vo   | Xuan  |
						| Bach | Khang |
						| Cao  | Vinh  |
						| Tran | An    |
						----------------
						
						SELECT HoGV, TenGV FROM GiangVien
						EXCEPT
						SELECT Ho, Ten FROM SinhVien

						----------------
						| HoGV | TenGV |
						|------|-------|
						| Ngo  | Van   |
						| Bui  | Chau  |
						| Pham | Huong |
						----------------


			1.4. Phép tích Đềcác (CARTESIAN PRODUCT) | ×: Từng dòng của bảng thứ nhất sẽ đi kết hợp với từng dòng của bảng thứ hai.

				- Còn được gọi là phép kết chéo (CROSS PRODUCT / CROSS JOIN), là một trong ba loại phép kết (JOIN).
				- Không được chính thức xem là một phần của các phép toán tập hợp.
				- Nhưng vẫn liên quan đến tập hợp vì nó tạo ra một tập hợp mới từ hai tập hợp đã cho.
				-> Xếp chung dù không phải là một phép toán tập hợp.

				* Công thức: R × S = {(t, q) ∣ t ∈ R và q ∈ S}

					- Tạo ra một bảng mới.
						+ Số cột sẽ là tổng (+) các cột của hai bảng.
						+ Số dòng sẽ là tích (×) các dòng của hai bảng.

					- Khi cộng các cột.
						+ Vì các cột đến từ các bảng khác nhau, nên tên cột của hai bảng có thể bị trùng nhau và tạo nên sự mơ hồ (ambiguous).
						+ Để phân biệt giữa các cột, ta có thể lấy tên bảng chấm '.' với tên cột của bảng tương ứng (ví dụ: Employee.employeeID và Department.employeeID).

					- Khi nhân các dòng.
						+ Mỗi dòng của bảng đầu tiên sẽ kết hợp với mỗi dòng của bảng thứ hai.
						+ Cứ kết hợp liên tục cho đến khi nào bảng đầu tiên hết dòng thì dừng.
						+ Lấy cả một dòng để kết nối, không phải lấy từng giá trị trong một dòng.

					- Gây nên sự bùng nổ số dòng.
						+ Có thể tạo ra một lượng lớn dữ liệu và làm chậm truy vấn.
						+ Trong số rất nhiều dữ liệu kết hợp được, không phải dòng nào cũng có ý nghĩa và có thể sử dụng được.

					Ví dụ: Tìm ra tên phòng ban đang quản lý dự án.

					PhongBan		DuAn
					----------------	-----------------------
					| MaPB | TenPB |	| MaDA | TenDA | MaPB |
					|------|-------|	|------|-------|------|
					| PB01 | NS    |	| DA01 | A     | PB01 |
					| PB02 | KT    |	| DA02 | B     | PB03 |
					| PB03 | KD    |	-----------------------
					----------------

					(PhongBan × DuAn)
					--------------------------------------------
					| PB.MaPB | TenPB | MaDA | TenDA | DA.MaPB |
					|---------|-------|------|-------|---------|
					| PB01    | NS    | DA01 | A     | PB01    | 🗸
					| PB01    | NS    | DA02 | B     | PB03    |
					| PB02    | KT    | DA01 | A     | PB01    |
					| PB02    | KT    | DA02 | B     | PB03    |
					| PB03    | KD    | DA01 | A     | PB01    |
					| PB03    | KD    | DA02 | B     | PB03    | 🗸
					--------------------------------------------

				* Trong SQL, đây chính là CROSS JOIN.
					- Được dùng để kết nối hai bảng mà...
						+ Không cần thiết lập điều kiện kết nối.
						+ Không cần khả hợp/ tương thích.
						+ Không cần cột chung.
						+ ...
					- Thường được thay thế bằng các phép JOIN khác.

					Ví dụ:
						- Phép tích Đềcác: SinhVien × GiangVien

						- Mệnh đề CROSS JOIN:

							* Cách 1 - Tường minh: Có từ khoá CROSS JOIN.
								SELECT *
								FROM NhanVien CROSS JOIN PhongBan

							* Cách 2 - Ngầm định: Liệt kê bằng dấu phẩy trong FROM (không chỉ định điều kiện kết nối trong mệnh đề WHERE).
								SELECT *
								FROM NhanVien, PhongBan


		* Lưu ý: Các phép toán tập hợp chỉ được áp dụng trên các tập hợp (bảng), không thể áp dụng vào các biểu thức điều kiện.

			Ví dụ:
				- Sai: σ (TenMH = 'NMLT' ∪ TenMH = 'CSDL') (MonHoc)
				- Đúng: (σ TenMH = 'NMLT' (MonHoc)) ∪ (σ TenMH = 'CSDL' (MonHoc))


		2. Các phép toán phi tập hợp: Các phép toán dành riêng cho CSDL quan hệ.

			2.1. Phép kết nối (JOIN) | ⋈:

				- Bản chất của JOIN vẫn chỉ là phép tích Đềcác (Phép kết chéo - Cross join).
					- Nhân từng dòng (cả một dòng) của bảng thứ nhất với từng dòng của bảng thứ hai.
					- Nhưng có bổ sung thêm các điều kiện so sánh chọn để loại bỏ đi những dòng không hợp lệ và những dòng không mong muốn sau khi nhân.
					- Trong kết quả sẽ không bao gồm các giá trị NULL, vì NULL không thể dùng các phép toán so sánh thông thường để so sánh.

						-> Tương đương với phép tích Đềcác, nhưng có thêm phép chọn.

					=> Phép kết nội (Inner join): Loại kết nối sẽ tự động loại bỏ những dòng không cần thiết.

				- Có ba loại phép kết nối (JOIN):

					1. Phép kết chéo (CROSS JOIN).
					
					2. Phép kết nội (INNER JOIN).
						2.1. Phép kết theta (Theta join).
						2.2. Phép kết bằng (Equi join).
						2.3. Phép kết tự nhiên (Natural join).

					3. Phép kết ngoại (OUTER JOIN).
						3.1. Phép kết ngoại bên trái (Left outer join)
						3.2. Phép kết ngoại bên phải (Right outer join)
						3.3. Phép kết ngoại đủ (Full outer join).

				- Một số khái niệm có liên quan:

					* Cột kết nối/ Cột chung (Join Attribute/ Common Column): Là cột gồm những dòng chứa bên trong những giá trị tương quan (hợp cạ / hợp rơ) nhau giữa hai bảng.
						- Có thể là cột chung (cùng miền giá trị) giữa hai bảng.
						- Cũng có thể là hai cột riêng biệt, nhưng lúc này, kết quả có thể không như mong đợi hoặc không hợp lý.
						- Không quan trọng tên cột, chỉ quan tâm dữ liệu bên trong có sự tương đồng để có thể tiến hành ghép.

						-> Cột được sử dụng để kết nối.

					* Điều kiện kết nối/ Tiêu chuẩn ghép (Join Condition): Là một mệnh đề mô tả cách thức kết nối giữa các cột bằng toán tử so sánh.
						- Có thể bao gồm cả toán tử luận lý AND và OR.
						- Điều kiện kết nối sẽ trả về giá trị luận lý (TRUE, FALSE, hoặc NULL).
						- Chỉ những kết quả thoả điều kiện (là TRUE) thì mới được chọn, những kết quả không thoả (có thể là FALSE hoặc đang mang giá trị NULL) sẽ không được chọn.

						-> Điều kiện của cột để ghép nối.

						Ví dụ:
							NhanVien ⋈ (NhanVien.MaPB = PhongBan.MaPB AND TenPB = 'CNTT') PhongBan

							- Cột kết nối: NhanVien.MaPB và PhongBan.MaPB
							- Điều kiện kết nối: NhanVien.MaNV = PhongBan.MaNV AND TenPB = 'CNTT'

					* Tỷ lệ chọn lọc kết nối (Join Selectivity - JS):
						- Được tính bằng công thức: Số dòng trả về / số dòng của phép kết tự nhiên.
						- Thường được dùng để đánh giá hiệu suất của việc truy xuất.

				* Phép kết theta (Theta/General join): R ⋈ ϴ S = σ ϕ (R × S)

					- Sau khi nhân hai bảng, bắt đầu kiểm tra thêm điều kiện lọc (ϴ).
					- Điều kiện lọc áp dụng các phép toán so sánh: =, ≠, <, ≤, >, ≥.
						+ Nếu chỉ sử dụng dấu '=' để so sánh giữa các cột sẽ được gọi là phép kết tương đương (Equi join).
						+ Những phép so sánh còn lại sẽ được gọi là phép kết không tương đương (Non-equi join).
					- Cột điều kiện có thể:
						+ Là cột chung giữa hai bảng, được so sánh với nhau bằng các phép toán so sánh {=, ≠, <, ≤, >, ≥}.
						+ Cũng có thể bao gồm hai hay nhiều cột trong cùng một bảng.
							Ví dụ: (ThoiGianNghiLam - ThoiGianVaoLam) > 2 năm.

					Ví dụ: Tìm ra tên phòng ban đang quản lý dự án.

					NhanVien	   LamViec
					----------------   --------------------------
					| MaNV | TenNV |   | MaNV | NgVL   | NgNL   |
					|------|-------|   |------|--------|--------|
					| NV01 | An    |   | NV01 | 1/2/20 | 3/4/23 |
					| NV02 | Bình  |   | NV03 | 5/6/22 | 7/8/23 |
					| NV03 | Cường |   --------------------------
					----------------

					NhanVien ⋈ (NhanVien.MaNV = LamViec.MaNV AND (year(NgNL) - year(NgVL)) > 2) LamViec
					-----------------------------------------------
					| NV.MaNV | TenPB | LV.MaNV | NgVL   | NgNL   |
					|---------|-------|---------|--------|--------|
					| NV01    | An    | NV01    | 1/2/20 | 3/4/23 |
					-----------------------------------------------


				* Phép kết tương đương / kết bằng (Equi join): R ⋈ (A = B / A = v) S

					- Là một trường hợp đặc biệt của phép kết theta.
					- Khi mọi điều kiện so sánh đều là phép so sánh: =.
					- Từng điều kiện riêng lẻ được so sánh bằng sẽ được gọi là phép kết tương đương khi:
						+ Đảm bảo chỉ có phép so sánh bằng.
						+ Không quan tâm các điều kiện riêng lẻ này có kết hợp với nhau bằng toán tử AND, OR,... hay không.
					- Vì là so sánh bằng giữa hai cột, nên chắc chắn sẽ có hai cột trùng nhau hoàn toàn về giá trị.

					Ví dụ: Tìm ra tên phòng ban đang quản lý dự án.

					PhongBan		DuAn
					----------------	-----------------------
					| MaPB | TenPB |	| MaDA | TenDA | MaPB |
					|------|-------|	|------|-------|------|
					| PB01 | NS    |	| DA01 | A     | PB01 |
					| PB02 | KT    |	| DA02 | B     | PB03 |
					| PB03 | KD    |	-----------------------
					----------------

					PhongBan ⋈ (PhongBan.MaPB = DuAn.MaPB) DuAn
					--------------------------------------------
					| PB.MaPB | TenPB | MaDA | TenDA | DA.MaPB |
					|---------|-------|------|-------|---------|
					| PB01    | NS    | DA01 | A     | PB01    |
					| PB03    | KD    | DA02 | B     | PB03    |
					--------------------------------------------


				* Phép kết tự nhiên (Natural join): R * S

					- Sử dụng kí hiệu là '*' thay vì '⋈'.
					- Là một trường hợp đặc biệt của phép kết tương đương, nhưng tự động bỏ đi cột bị trùng.
					- Không cần chỉ định điều kiện kết nối (tên cột), nên chỉ kết nối khi hai cột có cùng tên và có cùng kiểu dữ liệu (ngầm định tìm thuộc tính tương đương của hai bên để so sánh bằng).
						+ Nếu khác tên, cần thực hiện phép đổi tên trước khi thực hiện phép kết.
						+ Nếu khác kiểu, chỉ kết nối được khi kiểu dữ liệu này có thể ép kiểu được.

					Ví dụ: Tìm ra tên phòng ban đang quản lý dự án.

					PhongBan		DuAn
					----------------	-----------------------
					| MaPB | TenPB |	| MaDA | TenDA | MaPB |
					|------|-------|	|------|-------|------|
					| PB01 | NS    |	| DA01 | A     | PB01 |
					| PB02 | KT    |	| DA02 | B     | PB03 |
					| PB03 | KD    |	-----------------------
					----------------

					PhongBan * DuAn
					-------------------------------
					| MaPB | TenPB | MaDA | TenDA |
					|------|-------|------|-------|
					| PB01 | NS    | DA01 | A     |
					| PB03 | KD    | DA02 | B     |
					-------------------------------

				* Phép nửa kết (Semi join): Jack.

				* Trong SQL, các bảng cần kết nối sẽ liệt kê trong mệnh đề FROM:

					1. Điều kiện kết nối (so sánh) sẽ được viết chung trong mệnh đề FROM.
						+ Được thêm vào trong SQL2.
						+ Giúp phân biệt rõ ràng giữa các điều kiện JOIN với các điều kiện lựa chọn trong mệnh đề WHERE.
						+ Dễ dàng chuyển đổi cú pháp từ INNER JOIN thành OUTER JOIN.

						Ví dụ:
							SELECT *
							FROM DonDatHang
								JOIN KhachHang
								ON DonDatHang.MaKH = KhachHang.MaKH

					2.1. Điều kiện kết nối (so sánh) sẽ được viết trong mệnh đề WHERE.

						Ví dụ:
							SELECT *
							FROM PhongBan, DuAn
							WHERE PhongBan.MaPB = DuAn.MaPB

					2.2. Tạo ra một bảng tạm, được lồng (nested) bên trong một bảng khác bằng mệnh đề WHERE.

						Ví dụ:
						SELECT *
						FROM NhanVien
						WHERE MaPB IN (
								SELECT MaPB
								FROM Departments
								WHERE TenPB = 'CNTT'
							      )


			2.2. Phép chia (DIVISION) | ÷: Tìm các dòng trong bảng thứ nhất có liên quan đến tất cả các dòng trong bảng thứ hai.

				* Công thức: R ÷ S = {t | ∀ u ∈ S : (t, u) ∈ R}

					- Được dùng để trích các dòng trong bảng R (nhiều thông tin) có liên quan đến tất cả các dòng trong bảng S (ít thông tin).
						- Vì có liên quan nên cần đảm bảo S có bao nhiêu cột thì R cũng phải có từ bấy nhiêu trở lên (cùng số cột và miền giá trị).
						- Nếu S có những cột mà R không có thì phải sử dụng phép chiếu để bỏ bớt cột khác nhau, giúp kết quả chia được chính xác hơn.

					- Sẽ tạo ra một bảng mới.
						+ Số cột sẽ là R − S (chỉ lấy cột của R và bỏ đi cột trùng).
						+ Số dòng sẽ chỉ gồm những dòng chung của cả hai bảng, nhưng với một số điều kiện:
							1. Dữ liệu trong các cột chung giữa R và S phải khớp nhau hoàn toàn.
							2. Dữ liệu trong các cột còn lại của R, dòng nào cũng phải giống hệt nhau.

							Ví dụ:
							
							BangA		    BangB
							----------------    -----------
							|Cot1|Cot2|Cot3|    |Cot2|Cot3|
							|----|----|----|    |----|----|
							| 7  | A1 | B2 |    | A1 | B2 |
							| 9  | A1 | B4 |    | A1 | B4 |
							| 1  | A1 | B2 |    -----------
							| 1  | A8 | B4 |
							| 3  | A1 | B2 |
							| 7  | A1 | B4 |
							---------------- 

							BangA ÷ BangB
								------
								|Cot1|
								|----|
								| 7  |
								| 7  |
								------


					Ví dụ: Tìm ra mã sinh viên theo điều kiện.

					MonHoc			KetQua
					-----------------------	----------------------
					| MaMH | TenMH | SoTC |	| MaSV | MaMH | Diem |
					|------|-------|------|	|------|------|------|
					| MH01 | TH    | 2    |	| SV01 | MH01 | 5    |
					| MH02 | LT    | 3    |	| SV01 | MH02 | 7    |
					| MH03 | DL    | 2    |	| SV01 | MH03 | 6    |
					| MH04 | KT    | 4    |	| SV02 | MH01 | 8    |
					-----------------------	| SV02 | MH03 | 7    |
								| SV03 | MH01 | 8    |
								| SV03 | MH02 | 9    |
								| SV03 | MH03 | 7    |
								| SV03 | MH04 | 6    |
								| SV04 | MH02 | 5    |
								----------------------

					- Sinh viên đã thi môn TH và LT trong MonHoc:
					R1 ← π MaMH (σ TenMH = 'TH' (MonHoc) ∪ σ TenMH = 'LT' (MonHoc))
					KetQua ÷ R1

					- Sinh viên thi những môn có số tín chỉ = 2:
					R1 ← π MaMH (σ SoTC = 2 (MonHoc))
					KetQua ÷ R1

				* Trong SQL, không có các từ khoá tương ứng với phép chia trong ĐSQH.

--------------------

	[TỔNG KẾT: CÁC PHÉP TOÁN TRONG ĐẠI SỐ QUAN HỆ]

	- Phép chọn (SELECT): Lựa dòng để hiển thị.
		| σ <điều kiện lọc> (R)

	- Phép chiếu (PROJECT): Lựa cột để hiển thị và xoá dòng trùng.
		| π <cột₁, cột₂, ..., cộtₙ> (R)

	- Phép đổi tên (RENAME): Đổi tên của bảng, cột hoặc cả hai.
		| ρ <tên-bảng-mới> (R)
		| ρ <danh-sách-tên-cột-mới> (R)
		| ρ <tên bảng mới> <danh-sách-tên-cột-mới> (R)

	- Phép hợp (UNION): Gom toàn bộ dòng trong hai bảng lại và bỏ dòng trùng.
		| R ∪ S

	- Phép giao (INTERSECTION): Chỉ lấy những dòng chung của hai bảng.
		| R ∩ S

	- Phép trừ (SET DIFFERENCE): Chỉ bao gồm những dòng riêng của một bảng.
		| R − S

	- Phép chia (DIVISION): Tìm các dòng trong bảng này có liên quan (cùng số cột và miền giá trị) với tất cả các dòng trong bảng khác.
		| R ÷ S

	- Phép tích Đềcác (CARTESIAN PRODUCT): Cộng hai cột, từng dòng của bảng này sẽ đi kết hợp với từng dòng (đến hết tất cả dòng) của bảng khác.
		| R × S

	- Phép kết nối (JOIN): Có lọc thêm điều kiện sau khi thực hiện phép tích Đềcác.
		+ Theta join: Điều kiện là các phép toán {=, ≠, <, ≤, >, ≥} trên thuộc tính.
			| R ⋈ ϴ S
		+ Equi join: Điều kiện chỉ toàn chứa phép toán bằng '=', sẽ dẫn đến có hai cột trùng tên và giá trị hoàn toàn.
			| R ⋈ <A = B / A = v> S
		+ Natural join: Kết nối mà không cần chỉ định điều kiện, tự động loại bỏ cột trùng tên.
			| R * ϴ S

--------------------

* Lưu ý 1: Ngoài cách phân loại ở bên trên (cách 1), còn có một số cách khác nhau để phân loại các toán tử của đại số quan hệ, có thể kể đến.

	* Cách 2: 

		- Có 5 toán tử là toán tử cơ bản (complete set) trong ĐSQH.

			+ Bao gồm:
				1. Phép hội (UNION)
				2. Phép trừ (SET DIFFERENCE)
				3. Phép tích Đềcác (CARTESIAN PRODUCT)
				4. Phép chọn (SELECT)
				5. Phép chiếu (PROJECT)

			+ Chỉ cần 5 toán tử này là đủ để thực hiện các thao tác truy xuất dữ liệu.

			+ Cũng có thể dùng 5 toán tử này để biểu diễn thay thế cho những toán tử khác, chỉ là không gọn và thuận tiện bằng.

				Ví dụ:
					R ∩ S = R − (R − S).
					R ∩ S = ((R ∪ S) − (R − S)) − (S − R)
					R ∩ S = (R ∪ S) – ((R – S) ∪ (S – R))
					R ⋈ ϴ S = σ ϕ (R × S)

					T1 ← π y (R)
					T2 ← π y ((S × T1) – R)
					T ← T1 – T2

		- Có 3 toán tử mở rộng.

			+ Bao gồm:
				1. Phép giao (INTERSECTION)
				2. Phép kết (JOIN)
				3. Phép chia (DIVISION)
				4. Phép đổi tên (RENAME)

			+ Được thêm vào vì tính tiện dụng chứ không phải cần thiết.
			
			+ 3 toán tử này lại thường được sử dụng hơn để thay thế cho 5 toán tử cơ bản, giúp đơn giản hoá các câu lệnh truy vấn.


	* Cách 3:

		- Các phép toán trên tập hợp:
			1. Phép hội (UNION)
			2. Phép giao (INTERSECTION)
			3. Phép trừ (SET DIFFERENCE)

		- Rút trích một phần của bảng:
			1. Phép chọn (SELECT)
			2. Phép chiếu (PROJECT)

		- Kết hợp các bảng:
			1. Phép tích Đềcác (CARTESIAN PRODUCT)
			2. Phép kết (JOIN)

		- Đổi tên:
			1. Phép đổi tên (RENAME)

		(Cách này không phân loại cho Phép chia (DIVISION).)


	* Cách 4: 

		- Các phép toán tập hợp:
			1. Phép hội (UNION)
			2. Phép giao (INTERSECTION)
			3. Phép trừ (SET DIFFERENCE)
			4. Phép tích Đềcác (CARTESIAN PRODUCT)

		- Các phép toán dành riêng cho CSDL quan hệ:

			+ Các phép toán một ngôi:
				1. Phép chọn (SELECT)
				2. Phép chiếu (PROJECT)
				3. Phép đổi tên (RENAME)

			+ Các phép toán hai ngôi:
				1. Phép kết (JOIN)
				2. Phép chia (DIVISION)

* Lưu ý 2: Nên ưu tiên thực hiện phép chọn (SELECT) trước để loại bớt số dòng dữ liệu dư thừa, sau đó mới thực hiện các phép khác sau.
	- Nếu vẫn quyết định thực hiện phép chiếu (PROJECT) trước phép chọn (SELECT), cần đảm bảo chừa lại đủ các cột mà phép chọn (SELECT) cần để thực hiện lọc dữ liệu.

* Lưu ý 3: Các phép toán tập hợp: hội, giao,... sẽ được sử dụng khi giữa các mệnh đề không thể sử dụng các toán tử luận lý: AND, OR,... được.

--------------------

* Bài tập:

	Phép hợp (UNION): R ∪ S
	Phép giao (INTERSECTION): R ∩ S
	Phép trừ (SET DIFFERENCE): R − S
	Phép tích Đềcác (CARTESIAN PRODUCT): R × S

	Phép chọn (SELECT): σ <điều kiện lọc> (R)
	Phép chiếu (PROJECT): π <cột₁, cột₂, ..., cộtₙ> (R)

	Phép đổi tên (RENAME): ρ <tên bảng hoặc cột mới> (R)
	Phép kết nối theta (THETA JOIN): R ⋈ ϴ S
	Phép chia (DIVISION): R ÷ S

	Phép gán  (Assignment Operation): R’ ← E

	- Các toán tử so sánh: =, ≠, <, ≤, >, ≥.
	- Các toán tử luận lý: NOT (¬), AND (∧), OR (∨).

	1. Một CSDL gồm 5 bảng:

		Product (P̲r̲o̲d̲u̲c̲t̲C̲o̲d̲e̲, ProductName, PurchasePrice, SellPrice, Type, #SupplierCode)

		Supplier (S̲u̲p̲p̲l̲i̲e̲r̲C̲o̲d̲e̲, SupplierName, Address)

		Employee (E̲m̲p̲l̲o̲y̲e̲e̲I̲D̲, FullName, Gender, BirthDay, Address)

		Invoice (I̲n̲v̲o̲i̲c̲e̲I̲D̲, SellDate, #EmployeeID)

		InvoiceLine (#̲P̲r̲o̲d̲u̲c̲t̲C̲o̲d̲e̲,̲ ̲#̲I̲n̲v̲o̲i̲c̲e̲I̲D̲, Quantity)

		* BT1:

			1. Lấy ra mã và tên của bảng Product.
				π ProductCode, ProductName (Product)

			2. Lấy ra những sản phẩm có giá trị > 100.000.
				σ SellPrice > 100000 (Product)

			3. Lấy ra những nhân viên từng bán sản phẩm.
				R1 ← Invoice ⋈ Employee
				R2 ← π EmployeeID, FullName, Gender, BirthDate, Address (R1)

			4. Lấy ra những sản phẩm được bán vào tháng 8.
				R1 ← InvoiceLine ⋈ Invoice
				R2 ← R1 ⋈ Product
				R3 ← σ month(SellDate) = 8 (R2)
				R4 ← π ProductCode, ProductName, PurchasePrice, SellPrice, Type, SupplierCode (R3)

		* BT2:

			1. Lấy ra tên và giá bán của những sản phẩm TV được cung cấp bởi SONY.
				R1 ← Product ⋈ Supplier
				R2 ← σ Type = "TV" AND SupplierName = "SONY" (R1)
				R3 ← π ProductName, SellPrice (R2)

			2.1. Lấy ra tên và địa chỉ của các nhà cung cấp sản phẩm TV.
				R1 ← Product ⋈ Supplier
				R2 ← σ Type = "TV" (R1)
				R3 ← π SupplierName, Address (R2)

			2.2.* Lấy ra tên và địa chỉ của các nhà cung cấp sản phẩm TV hoặc ĐT.
				R1 ← Product ⋈ Supplier
				R2 ← σ Type = "TV"(R1)
				R3 ← σ Type = "Mobile" (R1)
				R4 ← R3 ∪ R2
				R5 ← π SupplierName, Address (R4)

			3. Lấy ra tên của tất cả các nhân viên sinh năm 2000.
				R1 ← σ year(BirthDay) = 2000 (Employee)
				R2 ← π FullName (R1)

			4. Lấy ra tên và loại của tất cả sản phẩm được bán vào ngày 23/05/2020.
				R1 ← InvoiceLine ⋈ Invoice
				R2 ← σ SellDate = "23/05/2020" (R1)
				R3 ← R2 ⋈ Product
				R4 ← π ProductName, Type (R3)

			5.1. Lấy ra tên của những nhân viên nữ đã từng bán TV.
				R1 ← InvoiceLine ⋈ Invoice
				R2 ← R1 ⋈ Employee
				R3 ← R2 ⋈ Product
				R4 ← σ Gender = "Female" AND Type = "TV" (R3)
				R5 ← π FullName (R4)

			5.2.* Lấy ra tên của những nhân viên nữ đã từng bán TV hoặc ĐT.
				R1 ← InvoiceLine ⋈ Invoice
				R2 ← R1 ⋈ Employee
				R3 ← R2 ⋈ Product
				R4 ← σ Gender = "Female" (R3)
				R5 ← σ Type = "TV" (R4)
				R6 ← σ Type = "Mobile" (R4)
				R7 ← R4 ∪ R5
				R8 ← π FullName (R5)

			6.1. Lấy ra tên và địa chỉ của các nhà cung cấp có cung cấp TV và ĐT.
				R1 ← Supplier ⋈ Product
				R2 ← σ Type = "TV" (R1)
				R3 ← σ Type = "Mobile" (R1)
				R4 ← R2 ∩ R3
				R5 ← π SupplierName, Address (R4)

			6.2.* Lấy ra tên và địa chỉ của các nhà cung cấp chỉ cung cấp TV hoặc chỉ cung cấp ĐT.
				R1 ← Supplier ⋈ Product
				R2 ← σ Type = "TV" (R1)
				R3 ← σ Type = "Mobile" (R1)
				R4 ← R2 ∩ R3
				R5 ← R2 − R4
				R6 ← R3 − R4
				R7 ← R3 ∪ R5
				R8 ← π SupplierName, Address (R7)

			7. Lấy ra tên và giá của tất cả sản phẩm được bán bởi nhân viên "Nguyễn Văn An" trong tháng 04/2020.
				R1 ← InvoiceLine ⋈ Invoice
				R2 ← R1 ⋈ Employee
				R3 ← R2 ⋈ Product
				R4 ← σ FullName = "Nguyễn Văn An" AND month(SellDate) = "04" AND year(SellDate) = "2000" (R3)
				R5 ← π ProductName, SellPrice (R4)

			8. Lấy ra tên và giá của tất cả sản phẩm ĐT của LG trong tháng 04/2020.
				R1 ← InvoiceLine ⋈ Invoice
				R2 ← R1 ⋈ Product
				R3 ← R2 ⋈ Supplier
				R4 ← σ Type = "Mobile" AND SupplierName = "LG" (R1)
				R5 ← σ month(SellDate) = "04" AND year(SellDate) = "2000" (R4)
				R6 ← π ProductName, SellPrice (R5)

			9. Lấy ra sản phẩm có giá bán cao nhất.
				σ SellPrice = max(SellPrice) (Product) (Product)

			10. Lấy ra tổng tiền (Quantity * SellPrice) của mỗi chi tiết hoá đơn với ngày bán là 30/04/2020.
				R1 ← InvoiceLine ⋈ Invoice
				R2 ← R1 ⋈ Product
				R3 ← σ SellDate = "30/04/2020" (R2)
				R4 ← π (Quantity * SellPrice) -> TotalPrice (R3)


	2. Cho lược đồ CSDL dùng để quản lý hồ sơ sinh viên gồm các bảng:

		SinhVien (MaSV, HoTenSV, GioiTinh, NgaySinh, MaLop, HocBong)
		Lop (MaLop, TenLop, SiSo, MaKhoa)
		Khoa (MaKhoa, TenKhoa, SoLuongGiangVien)
		MonHoc (MaMH, TenMH, SoTietHoc)
		KetQua (MaSV, MaMH, DiemThi)

		Hãy thực hiện các câu hỏi sau bằng ngôn ngữ ĐSQH:

			1. Lập danh sách sinh viên gồm MaSV, HoTenSV, HocBong
				π (MaSV, HoTenSV, HocBong) (SinhVien)

			2. Lập phiếu điểm gồm các thông tin MaSV, HoTenSV, TenMH, DiemThi cho sinh viên có MaSV = "0001"

				* Phức tạp:
				SV001	← σ (MaSV = "0001") (SinhVien)
				TTSV	← π (MaSV, HoTenSV) (SV)
				MaMon	← π (MaMH, TenMH) (MonHoc)
				KQMaSV	← KetQua * (KetQua.MaSV = TTSV.MaSV) TTSV
				KQVaMM	← KQMaSV * (KQMaSV.MaMH = MaMon.MaMH) MaMon
				π (MaSV, HoTenSV, TenMH, DiemThi) (KQVaMM)

				* Đơn giản:
				R1 ← σ (MaSV = "0001") (SinhVien * KetQua)
				R2 ← π (MaSV, HoTenSV, TenMH, DiemThi) (R1)
				π (MaSV, HoTenSV, TenMH, DiemThi) (R2 * MonHoc)

			3. Lập danh sách gồm các thông tin MaSV, HoTenSV, HocBong cho các sinh viên nữ của khoa có mã là "CNTT"

				* Phức tạp:
				ChonMaKhoa	← σ (MaKhoa = "CNTT") (Lop)
				ChieuTTMaLop	← π MaLop (Lop)
				SinhVienNu	← σ (GioiTinh = "Nu") (SinhVien)
				DSNuSVCNTT	← SinhVienNu * (SinhVienNu.MaLop = ChieuTTMaLop.MaLop) ChieuTTMaLop
				π (MaSV, HoTenSV, HocBong) (DSNuSVCNTT)

				* Đơn giản:
				R1 ← π MaLop (σ (MaKhoa = "CNTT") (Lop))
				π (MaSV, HoTenSV, HocBong) (σ (GioiTinh = "Nu") (R1 * SinhVien))

			4. Lập bảng điểm gồm các thông tin MaSV, HoTenSV, TenMH, DiemThi cho tất cả sinh viên khoa (tên) Công nghệ thông tin".

				* Phức tạp:
				KhoaCNTT	← σ (TenKhoa = "CNTT") (Khoa)
				MaKhoaCNTT	← π (MaKhoa) (KhoaCNTT)
				ChieuTTMaLop	← π (MaLop, MaKhoa) (Lop)
				ChonMaLop	← ChieuTTMaLop * (ChieuTTMaLop.MaKhoa = MaKhoaCNTT.MaKhoa) MaKhoaCNTT
				SinhVienCNTT	← SinhVien * (SinhVien.MaLop = ChonMaLop.MaLop) ChonMaLop
				ChieuTTSVCNTT	← π (MaSV, HoTenSV) (SinhVienCNTT)
				KetQuaSVCNTT	← ChieuTTSVCNTT * (ChieuTTSVCNTT.MaSV = KetQua.MaSV) KetQua
				ChieuTTMonHoc	←  π (MaMH, TenMH) (MonHoc)
				KetQuaKemMaMH	← KetQuaSVCNTT * (KetQuaSVCNTT.MaMH = ChieuTTMonHoc.MaMH) ChieuTTMonHoc
				π (MaSV, HoTenSV, TenMH, DiemThi) (KetQuaKemMaMH)

				* Đơn giản:
				R1 ← π (MaKhoa) (σ (TenKhoa = "CNTT") (Khoa))
				R2 ← π MaLop (R1 * Lop)
				R3 ← π (MaSV, HoTenSV) (R2 * SinhVien)
				R4 ← (R3 * KetQua)
				π (MaSV, HoTenSV, TenMH, DiemThi) (R4 * MonHoc)

			5. Lập danh sách sinh viên của lớp có mã là "CS01" và có điểm thi môn "CSDL" ≥ 8
				SinhVienLopAT10	← σ (MaLop = "CS01") (SinhVien)
				TTMonCSDL	← σ (TenMH = "CSDL") (MonHoc)
				MaMonCSDL	← π MaMH (TTMonCSDL)
				MonHocVaKetQua	← MaMonCSDL * (MaMonCSDL.MaMH = KetQua.MaMH) KetQua
				KQDiemThiTren8	← σ (DiemThi ≥ 8) (MonHocVaKetQua)
				SVCS01CSDLTren8	← SinhVienLopAT10 * (SVCS01CSDLTren8.MaSV = KQDiemThiTren8.MaSV) KQDiemThiTren8

			6. Lập danh sách gồm các thông tin MaSV, HoTenSV cho các sinh viên đã thi hết tất cả các môn học.

				* Phức tạp:
				ChieuMaMH	← π MaMH (MonHoc)
				ChieuKetQua	← π (MaSV, MaMH) (KetQua)
				MaSVThiHetCacMH	← ChieuKetQua ÷ ChieuMaMH
				LayTTSVDaThiHet	← MaSVThiHetCacMH * (MaSVThiHetCacMH.MaSV = SinhVien.MaSV) SinhVien
				π (MaSV, HoTenSV) (LayTTSVDaThiHet)

				* Đơn giản:
				R1 ← π MaMH (MonHoc)
				R2 ← π (MaSV, MaMH) (KetQua)
				π (MaSV, HoTenSV) ((R2 ÷ R1) * SinhVien)

			7. Lập danh sách sinh viên của lớp IM01 thi lại môn CSDL.

			8. Lập danh sách gồm các thông tin MaSV, HoTenSV, TenMonThi (TenMH) của các sinh viên còn thiếu ít nhất một môn học chưa thi.

				* Phức tạp:
				ChieuMaMH	← π MaMH (MonHoc)
				ChieuKetQua	← π (MaSV, MaMH) (KetQua)
				MaSVThiHetCacMH	← ChieuKetQua ÷ ChieuMaMH
				MaSVCuaTatCaSV	← π MaMH (SinhVien)
				SVCoMonChuaThi	← MaSVCuaTatCaSV - MaSVThiHetCacMH
				LayLaiTTSV	← SVCoMonChuaThi * SinhVien
				LayMaVaTenSV	← π (MaSV, HoTenSV) (SinhVien)
				LayTenMH	← ChieuKetQua * (ChieuKetQua.MaMH = MonHoc.MaMH) MonHoc
				KQSVMonChuaThi	← LayMaVaTenSV * (LayMaVaTenSV.MaSV = LayTenMH.MaSV) LayTenMH
				π (MaSV, HoTenSV, TenMH) (KQSVMonChuaThi)

				* Đơn giản:
				R1 ← π MaMH (MonHoc)
				R2 ← π (MaSV, MaMH) (KetQua)
				R3 ← π (MaSV, HoTenSV) ((R2 ÷ R1) * SinhVien)
				R4 ← π (MaSV, HoTenSV) (SinhVien)
				R5 ← R4 − R3
				R6 ← π (MaSV, TenMH) (R2 * MonHoc)
				π (MaSV, HoTenSV, TenMH) (R5 * R6)
				

--------------------

Các phép toán ĐSQH cơ bản sẽ không đủ để thực hiện được một số thao tác phổ biến như: thống kê, báo cáo, tổng hợp, tóm tắt dữ liệu từ các bảng,...

* Các phép toán quan hệ bổ sung (Additional Relational Operations):
	- Phép chiếu tổng quát (Generalized Projection).
	- Hàm tập hợp/ kết hợp (Aggregate Function).
	- Phép gom nhóm các dòng (Grouping).
	- Phép kết mở rộng (OUTER JOIN).
	- Phép hội mở rộng (OUTER UNION).

----------

	1. Phép chiếu tổng quát (Generalized Projection): Bổ sung thêm các hàm (tính toán) vào các cột.

		* Công thức: π <hàm₁, hàm₂, ..., hàmₙ> (R)

			- Ngoài việc chiếu để lựa ra các cột, ta còn có thể thực hiện các phép toán trên các cột đã chiếu.

			- Các biểu thức hoặc phép toán được áp dụng lên các thuộc tính có thể bao gồm: các toán tử số học, các giá trị hằng,...

			- Ngoài việc thay đổi trực tiếp lên cột đã chiếu, ta còn có thể sử dụng các cột sẵn có để tạo ra một cột mới.
				+ Kết quả sẽ là các thuộc tính mới và không hề có tên.
				+ Vì vậy, có thể sử dụng thêm phép đôi tên để đặt tên cho các thuộc tính mới này.

			Ví dụ: Tính lương và thời gian làm việc của một nhân viên có lược đồ NhanVien (MaNV, TenNV, LuongCoBan, PhuCap, Thue, NgayVaoLam).

				LuongNV ← π (MaNV, TenNV, (LuongCoBan + PhuCap + (YEAR(GETDATE()) - YEAR(NgayVaoLam)) * 1,000,000)) (NhanVien)

				ρ (MaNV, TenNV, LuongThang) (LuongNV)

				- Công thức để tính lương tháng là: Lương cơ bản + phụ cấp + thưởng theo số năm làm viêc (số năm * 1,000,000).

				- Tạo ra một cột mới để tính lương tháng, sau khi tính toán xong thì có thể dùng phép đổi tên.

	2.1. Hàm tập hợp/ kết hợp (Aggregate Function): Thường được dùng trong các truy vấn thống kê, tóm tắt thông tin từ các dòng trong bảng.

		- Nhận vào một tập các giá trị - tập hợp dữ liệu (collection), nhưng chỉ trả về một giá trị duy nhất.
			+ Giá trị nhận vào có thể là một cột hoặc một biểu thức gồm nhiều cột.
			+ Những giá trị trùng nhau vẫn sẽ được tính, nhưng không tính những giá trị NULL.
			+ Vì hàm có trả về giá trị nên ta hoàn toàn có thể đem đi sử dụng và lồng bên trong những câu lệnh khác.

		- Gồm các hàm để tương tác với các tập dữ liệu là kiểu số:
			+ SUM(): Tính tổng các giá trị trong tập hợp.
			+ AVG(): Tính giá trị trung bình của các giá trị trong tập hợp.
			+ MAX(): Tìm giá trị lớn nhất trong tập hợp.
			+ MIN(): Tìm giá trị nhỏ nhất trong tập hợp.

		- Hàm để đếm số dòng của một bảng hoặc số giá trị của một cột:
			+ COUNT()

	2.2. Phép gom nhóm các dòng (Grouping): Thường được dùng để chia một bảng thành nhiều nhóm dựa trên điều kiện.

		* Công thức: <danh-sách-cột> ℑ <danh-sách-hàm> (R)

			(Chưa có kí hiệu thống nhất cho hàm tập hợp, nên đôi khi còn được kí hiệu là: γ,...)

			- Phân chia và gom những dòng giống nhau trong cùng một cột thành một nhóm, sau đó áp dụng các hàm tập hợp riêng biệt lên từng nhóm.
				-> Gom nhóm các dòng giống nhau ở 1 hay nhiều cột.

			- Nếu không có cột nào được liệt kê trong danh sách cột, nghĩa là không chia nhóm (chỉ có 1 nhóm lớn).

			Ví dụ 1: Cho lược đồ quan hệ NhanVien (MaNV, TenNV, NgaySinh, Luong, GioiTinh, MaPB).

				- Tính tổng số nhân viên và mức lương trung bình của tất cả các nhân viên trong công ty.
				
					ℑ (COUNT(MaNV), AVG(Luong)) (NhanVien)

				- Với mỗi phòng ban, cho biết mã phòng ban, tổng số nhân viên và mức lương trung bình của phòng đó.

					// Phân nhóm nhân viên theo phòng ban
					NV ← MaPB ℑ (COUNT(MaNV), AVG(Luong)) (NhanVien)
					ρ (MaPB, SoNV, LuongTB) (NV)

			Ví dụ 2:
				- Tìm điểm thi cao nhất và thấp nhất, tính điểm trung bình của môn CSDL.
					ℑ (MAX(Diem), MIN(Diem), AVG(Diem)) σ (MaMH = 'CSDL') (KetQuaThi)

				- Tìm điểm thi cao nhất và thấp nhất, tính điểm trung bình của từng môn.
					MaMH ℑ (MAX(Diem), MIN(Diem), AVG(Diem)) (KetQuaThi)

	3. Phép kết ngoại (Outer join): Sau khi chỉ lấy những dòng chung, vẫn muốn giữ lại những dòng riêng của các bên.
		- So sánh bằng giống phép kết tương đương (và vẫn giữ lại những dòng trùng nhau, ví dụ: hai dòng mà tất cả giá trị đều là NULL).
		- Giúp tránh việc mất mát dữ liệu, không thể vì một bên không có dữ liệu mà bên còn lại cũng bị mất dữ liệu theo.
		- Dòng dữ liệu của bên có dữ liệu vẫn giữ nguyên, tự động điền (padding) giá trị NULL cho các dòng không có dữ liệu.

		-> Vẫn giữ lại những dòng "cô đơn" (không thoả điều kiện để ghép cặp) thay vì bị tự động loại bỏ.

		3.1. Phép kết ngoại bên trái (Left outer join / Left join): Trả về tất cả dòng từ bảng bên trái và các dòng tương ứng từ bảng bên phải (hoặc NULL nếu không có kết hợp).
		
			* Công thức: R ⟕ <điều-kiện-kết-nối> S

				- Lấy bảng bên trái để làm mốc / làm chuẩn.
					+ Chung của cả hai.
					+ Riêng của bên trái.
					+ Bên phải mặc định là NULL.

				- Trong SQL:
					SELECT *
					FROM table1
					LEFT OUTER JOIN table2
					ON table1.column = table2.column

				Ví dụ:

					NhanVien		PhongBan
					-------------------	-------------------
					| TenNV    | MaPB |	| MaPB | TenPB    |
					|----------+------|	|------+----------|
					| An	   | PB34 |	| PB31 | Ban hang |
					| Son	   | PB33 |	| PB33 | CNTT     |
					| Thuy	   | PB34 |	| PB34 | Nhan su  |
					| Mai	   | NULL |	| PB35 | Tiep thi |
					| Long	   | PB33 |	-------------------
					| Dung	   | PB31 |
					-------------------

					- ĐSQH: NhanVien ⟕ (NhanVien.MaPB = PhongBan.MaPB) PhongBan
					- SQL:
						SELECT *
						FROM NhanVien 
						LEFT OUTER JOIN PhongBan
						ON NhanVien.MaPB = PhongBan.MaPB
					------------------------------------------
					| TenNV    | NV.MaPB | PB.MaPB| TenPB    |
					|----------+---------+--------+----------|
					| An	   | PB34    | PB34   | Nhan su  |
					| Son	   | PB33    | PB33   | CNTT     |
					| Thuy	   | PB34    | PB34   | Nhan su  |
					| Mai	   | NULL    | NULL   | NULL     |
					| Long	   | PB33    | PB33   | CNTT     |
					| Dung	   | PB31    | PB31   | Ban hang |
					------------------------------------------

		3.2. Phép kết ngoại bên phải (Right outer join / Right join): Trả về tất cả các dòng từ bảng bên phải và các dòng tương ứng từ bảng bên trái (hoặc NULL nếu không có kết hợp).
		
			* Công thức: R ⟖ <điều-kiện-kết-nối> S

				- Lấy bảng bên phải để làm mốc / làm chuẩn.
					+ Chung của cả hai.
					+ Riêng của bên phải.
					+ Bên trái mặc định là NULL.

				- Trong SQL:
					SELECT *
					FROM table1
					RIGHT OUTER JOIN table2
					ON table1.column = table2.column

				Ví dụ:

					NhanVien		PhongBan
					-------------------	-------------------
					| TenNV    | MaPB |	| MaPB | TenPB    |
					|----------+------|	|------+----------|
					| An	   | PB34 |	| PB31 | Ban hang |
					| Son	   | PB33 |	| PB33 | CNTT     |
					| Thuy	   | PB34 |	| PB34 | Nhan su  |
					| Mai	   | NULL |	| PB35 | Tiep thi |
					| Long	   | PB33 |	-------------------
					| Dung	   | PB31 |
					-------------------

					- ĐSQH: NhanVien ⟖ (NhanVien.MaPB = PhongBan.MaPB) PhongBan
					- SQL:
						SELECT *
						FROM NhanVien 
						RIGHT OUTER JOIN PhongBan
						ON NhanVien.MaPB = PhongBan.MaPBe
					------------------------------------------
					| TenNV    | NV.MaPB | PB.MaPB| TenPB    |
					|----------+---------+--------+----------|
					| An	   | PB34    | PB34   | Nhan su  |
					| Son	   | PB33    | PB33   | CNTT     |
					| Thuy	   | PB34    | PB34   | Nhan su  |
					| Long	   | PB33    | PB33   | CNTT     |
					| Dung	   | PB31    | PB31   | Ban hang |
					| NULL	   | NULL    | PB35   | Tiep thi |
					------------------------------------------

		3.3. Phép kết ngoại đủ (Full outer join / FULL JOIN): Trả về tất cả các dòng từ cả hai bảng, bảng bên trái và bảng bên phải (hoặc NULL nếu không có kết hợp).
		
			* Công thức: R ⟗ <điều-kiện-kết-nối> S

				- Đây không phải là phép tích Đềcác (nhân tất cả các dòng).
					+ Vẫn so sánh bằng giống phép kết tương đương.
					+ Có thêm hai phép kết ngoại bên trái và phải.

				- Không còn quan trọng bên nào làm mốc / làm chuẩn.
					+ Chung của cả hai.
					+ Riêng của mỗi bên.

				- Trong SQL:
					SELECT *
					FROM table1
					FULL OUTER JOIN table2
					ON table1.column = table2.column

				- Trong một số HQTCSDL, nếu phép kết ngoại đủ không được hỗ trợ, ta có thể sử dụng phép hội để nối hai bảng riêng biệt mà trước đó đã áp dụng hai phép kết ngoại bên trái và phải.

				Ví dụ:

					NhanVien		PhongBan
					-------------------	-------------------
					| TenNV    | MaPB |	| MaPB | TenPB    |
					|----------+------|	|------+----------|
					| An	   | PB34 |	| PB31 | Ban hang |
					| Son	   | PB33 |	| PB33 | CNTT     |
					| Thuy	   | PB34 |	| PB34 | Nhan su  |
					| Mai	   | NULL |	| PB35 | Tiep thi |
					| Long	   | PB33 |	-------------------
					| Dung	   | PB31 |
					-------------------

					- ĐSQH: NhanVien ⟗ (NhanVien.MaPB = PhongBan.MaPB) PhongBan
					- SQL:
						SELECT *
						FROM NhanVien 
						FULL OUTER JOIN PhongBan
						ON NhanVien.MaPB = PhongBan.MaPB
					------------------------------------------
					| TenNV    | NV.MaPB | PB.MaPB| TenPB    |
					|----------+---------+--------+----------|
					| An	   | PB34    | PB34   | Nhan su  |
					| Son	   | PB33    | PB33   | CNTT     |
					| Thuy	   | PB34    | PB34   | Nhan su  |
					| Mai	   | NULL    | NULL   | NULL     |
					| Long	   | PB33    | PB33   | CNTT     |
					| Dung	   | PB31    | PB31   | Ban hang |
					| NULL	   | NULL    | PB35   | Tiep thi |
					------------------------------------------

----------------------------------------

		[PHÉP TOÁN CẬP NHẬT - UPDATE OPERATION / MODIFICATION OPERATION]

* Phép toán cập nhật (Update Operation / Modification Operation): Được sử dụng để khai thác "có xâm lấn" dữ liệu trong CSDL.

--------------------

	1. Phép bổ sung / chèn (Insert): Thêm một dòng dữ liệu (t) vào bảng (r), kí hiệu là: rₙ = rₒ ∪ t.

		* Kí hiệu:
					       Tên bảng		Giá trị trong miền giá trị
					       ---------       ---------------------------
						       |       |
						       v       v
			- Cách 1 - Tường minh: INSERT (r; A₁ = d₁, A₂ = d₂, ..., Aₙ = dₙ)
							  ^
							  |
							  ---------------
							   Tên thuộc tính

			- Cách 2 - Ngầm định: INSERT (r; d₁, d₂, ..., dₙ)

		Ví dụ 1: Thêm một dòng phòng ban t = (IT01, CNTT, HoangNT2) vào bảng PhongBan (M̲a̲P̲B̲, TenPB, MaTrPh).

			- Cách 1: INSERT (PhongBan; M̲a̲P̲B̲ = IT01, TenPB = CNTT, MaTrPh = HoangNT2)

			- Cách 2: INSERT (PhongBan; IT01, CNTT, HoangNT2)

		Ví dụ 2: KetQua (#̲M̲S̲S̲V̲,̲ ̲#̲M̲M̲H̲, DiemSoMH), t = (SV001, CSDL, 7)

			- Cách 1: INSERT (KetQua; #̲M̲S̲S̲V̲ = SV001, #̲M̲M̲H̲ = CSDL, DiemSoMH = 7)

			- Cách 2: INSERT (KetQua; SV001, CSDL, 7)

--------------------

	2. Phép loại bỏ (Delete): Xoá một dòng dữ liệu (t) khỏi bảng (r), kí hiệu là: rₙ = rₒ - t.

		* Kí hiệu:

			- Cách 1 - Tường minh: DEL (r; A₁ = d₁, A₂ = d₂, ..., Aₙ = dₙ)

			- Cách 2 - Ngầm định: DEL (r; d₁, d₂, ..., dₙ)

					   Thuộc tính khoá
					   ----------------
							  |
							  v
			- Cách 3 - Xoá bằng khoá: DEL (r; B̲₁̲ = e₁, B̲₂̲ = e₂, ..., B̲ₘ̲ = eₘ)
							       ^
							       |
							       ----------------------------
							        Giá trị của thuộc tính khoá

		Ví dụ 1: Xoá một dòng phòng ban t = (IT01, CNTT, HoangNT2) khỏi bảng PhongBan (M̲a̲P̲B̲, TenPB, MaTrPh).

			- Cách 1: DEL (PhongBan; M̲a̲P̲B̲ = IT01, TenPB = CNTT, MaTrPh = HoangNT2)

			- Cách 2: DEL (PhongBan; IT01, CNTT, HoangNT2)

			- Cách 3: DEL (PhongBan; M̲a̲P̲B̲ = IT01)

		Ví dụ 2: KetQua (#̲M̲S̲S̲V̲,̲ ̲#̲M̲M̲H̲, DiemSoMH), t = (SV001, CSDL, 7)

			- Cách 1: DEL (KetQua; #̲M̲S̲S̲V̲ = SV001, #̲M̲M̲H̲ = CSDL, DiemSoMH = 7)

			- Cách 2: DEL (KetQua; SV001, CSDL, 7)

			- Cách 3: DEL (PhongBan; #̲M̲S̲S̲V̲ = SV001, #̲M̲M̲H̲ = CSDL)

--------------------

	3. Phép Thay đổi (Update / Change): Thay đổi một hoặc nhiều giá trị (không phải toàn bộ giá trị) của một dòng dữ liệu (t) trong bảng (r), kí hiệu là: rₙ = (rₒ \ t) ∪ tʼ.

		* Kí hiệu:

				     Giá trị gốc trong bộ t
				     -----------------------
							   |
							   v
			- Cách 1 - Tường minh: CH (r; A₁ = d₁, A₂ = d₂, ..., Aₙ = dₙ;
						      C₁ = e₁, C₂ = e₂, ..., Cₚ = eₚ)
							   ^
							   |
							   ------------------------
							    Giá trị mới trong bộ tʼ

					    Thuộc tính khoá gốc	     Giá trị của khoá gốc
					    --------------------    ---------------------
							       |    |
							       v    v
			- Cách 2 - Ngầm định bằng khoá: CH (r; B̲₁̲ = d₁, B̲₂̲ = d₂, ..., B̲ₘ̲ = dₘ;
							       C₁ = e₁, C₂ = e₂, ..., Cₚ = eₚ)
							       ^    ^
							       |    |
					------------------------    ---------------------
					Thuộc tính cần thay đổi	     Giá trị cần thay đổi

		Ví dụ 1: Thay đổi một thuộc tính t = (IT01, CNTT, DungCT)
					  bằng tʼ = (IT01, CNTT, HoangNT2)
		       trong bảng PhongBan (M̲a̲P̲B̲, TenPB, MaTrPh).

			- Cách 1: CH (PhongBan; M̲a̲P̲B̲ = IT01, TenPB = CNTT, MaTrPh = DungCT; M̲a̲P̲B̲ = IT01, TenPB = CNTT, MaTrPh = HoangNT2)

			- Cách 2: CH (PhongBan; M̲a̲P̲B̲ = IT01; MaTrPh = HoangNT2)

		Ví dụ 2: KetQua (#̲M̲S̲S̲V̲,̲ ̲#̲M̲M̲H̲, DiemSoMH),
			 t = (SV001, CSDL, 7) và tʼ = (SV001, CSDL, 8)

			- Cách 1: CH (KetQua; #̲M̲S̲S̲V̲ = SV001, #̲M̲M̲H̲ = CSDL, DiemSoMH = 7; #̲M̲S̲S̲V̲ = SV001, #̲M̲M̲H̲ = CSDL, DiemSoMH = 8)

			- Cách 2: CH (PhongBan; #̲M̲S̲S̲V̲ = SV001, #̲M̲M̲H̲ = CSDL; DiemSoMH = 8)

----------------------------------------

	[PHÉP TÍNH QUAN HỆ - RELATIONAL CALCULUS]

* Phép tính quan hệ (Relational Calculus):

	- Được xem là ngôn ngữ phi thủ tục vì chỉ cần viết biểu thức khai báo (declarative expression) để đưa ra yêu cầu.
		+ Tập trung vào mô tả điều kiện logic mà dữ liệu phải thỏa mãn.
		+ Không cần mô tả cách thức hoặc thứ tự thực hiện các truy vấn.
		+ Cũng có thể được viết theo nhiều cách khác nhau, nhưng thứ tự viết sẽ không ảnh hưởng đến hiệu xuất của truy vấn.

	- Sử dụng các phép toán vị từ (predicate).
		+ Là 1 hàm đối số nằm ở phía sau để diễn đạt điều người dùng muốn.
		+ Chỉ trả về hai kết quả đúng hoặc sai.

		* Có hai loại phép toán vị từ trên CSDL:
			1. Phép tính trên dòng (Tuple Relational Calculus).
			2. Phép tính trên cột (Domain Relational Calculus).

	

--------------------

	1. Phép tính trên dòng (Tuple Relational Calculus):

		- Tìm ra các dòng giúp vị từ có giá trị đúng.

		- Sử dụng các biến trên bộ để tìm.
			+ Là biến nhận giá trị là 1 dòng của bảng.

		Ví dụ:
			Lập danh sách các nhân viên có lương trên 10tr.
				- Đại số quan hệ: σ (salary > 10,000,000) (Staff)
				- Phép tính quan hệ trên dòng: {S | Staff(S) ∧ S.salary > 10,000,000}

			Lập danh sách các nhân viên có lương trên 10tr, nhưng chỉ bao gồm 1 cột lương trong danh sách.
				- Đại số quan hệ: π salary (σ (salary > 10,000,000) (Staff))
				- Phép tính quan hệ trên dòng: {S.salary | Staff(S) ∧ S.salary > 10,000,000}

			Lập danh sách các nhân viên có tên là Mark, nhưng chỉ bao gồm tên, ngày sinh và địa chỉ của nhân viên.
				- Đại số quan hệ: π name, birthDate, homeAddress (σ (name = 'Mark') (Staff))
				- Phép tính quan hệ trên dòng: {S.name, S.birthDate, S.homeAddress | Staff(S) ∧ S.name = 'Mark'}

		- Có thể sử dụng thêm các lượng từ (quatifier) để cho biết vị từ sẽ được áp dụng trên bao nhiêu dòng.
			+ Tồn tại (∃): Đảm bảo trong công thức có ít nhất 1 giá trị đúng.
			+ Với mọi (∀): Đảm bảo trong công thức, tất cả giá trị đều đúng.

			Ví dụ:
				Student (Id, Name, BirthDate)
				Professor (Id, Name, Qualification)
				Teaching (ProfId, CrsCode, Semester)
				Course (CrsCode, Name)
				Transcript (StudId, CrsCode, Semester, Year, Grade)

				- Liệt kê tất cả môn học mà mọi sinh viên đều học.
				{C | Course(C) ∧ (∀S) Student(S) ∧ (∃T) Transcript(T) ∧ Id = StudId ∧ C.CrsCode = T.CrsCode}

				- Liệt kê tên tất cả giảng viên đã dạy môn MGT123
				{P.Name | Professor(P) ∧ (∃T) (Teaching(T) ∧ (P.Id = T.ProfId ∧ T.CrsCode = 'MGT123'))}

--------------------

	2. Phép tính trên cột (Domain Relational Calculus): .

--------------------------------------------------------------------------------

[PHƯƠNG PHÁP & NGUYÊN TẮC CHUYỂN ĐỔI TỪ ERD SANG RS
 (CHUYỂN ĐỔI TỪ PHÂN TÍCH SANG THIẾT KẾ, TỪ Ý NIỆM SANG LUẬN LÝ)]

Từ mô hình ERD đã thiết kế sau khi thu thập và phân tích yêu cầu phần mềm (về dữ liệu).

Kết quả của quá trình chuyển Data Model Mapping.


	(* Lưu ý: Để tránh những chồng chéo trong việc ghi chú kí hiệu, kí hiệu nét đứt để biểu diễn cột khoá ngoại sẽ được thay thế bằng cách thêm một kí tự '#' vào trước tên thuộc tính.)

------------------------------------------------------------

Bước 1: Chuyển đổi thực thể (Entity) và thuộc tính (Attribute).

	* Thực thể -> Bảng riêng

	* Thuộc tính:
		- Thuộc tính đơn (nguyên tử), đơn trị và lưu trữ -> Cột

		- Thuộc tính phức -> Mỗi thuộc tính đơn trong thuộc tính phức là một cột
			+ Bỏ qua thuộc tính phức.
			+ Từng thuộc tính đơn trong thuộc tính phức sẽ tương đương một cột.

		- Thuộc tính đa trị -> Tách thành bảng riêng.
			+ Trong một bảng, với sự cản trở của khoá chính mà mỗi đối tượng trong bảng chỉ được xuất hiện một lần (chỉ có duy nhất một dòng dữ liệu).
			+ Nhưng để lưu được nhiều giá trị của thuộc tính đa trị thì lại cần nhiều dòng dữ liệu của cùng một đối tượng.
			+ Bắt buộc phải tạo thành một bảng mới và bảng này phải có cách để lưu được nhiều giá trị của thuộc tính đa trị, mà vẫn biết những giá trị đó thuộc về đối tượng nào.
			+ Bảng mới sẽ có tên được ghép là TENTHUOCTINH_TENBANG.

				1. Nếu giữa thực thể và thuộc tính có quan hệ nhiều-nhiều:
					- Khoá chính là sự kết hợp giữa khoá chính của thực thể + thuộc tính đa trị.
					- Vẫn có khoá ngoại, chính là khoá chính của thực thể.
					Ví dụ:
						- Mỗi NhânViên có nhiều KỹNăng.
						- Mỗi KỹNăng có thể nhiều NhânViên có.
						-> Khoá chính: M̲ã̲N̲V̲,̲ ̲K̲ỹ̲N̲ă̲n̲g̲

				2. Nếu giữa thực thể và thuộc tính có quan hệ một-nhiều:
					- Chỉ riêng thuộc tính đa trị làm khoá chính là đủ.
					- Vẫn có khoá ngoại, chính là khoá chính của thực thể.
					Ví dụ:
						- Mỗi NhânViên có nhiều SĐT.
						- Mỗi SĐT chỉ thuộc về một NhânViên.
						-> Khoá chính: S̲Đ̲T̲

		- Thuộc tính dẫn xuất -> Tuỳ chọn, có thể biểu diễn hoặc không

	* Khoá định danh -> Khoá chính

	Ví dụ: Chuyển thực thể NhânViên thành bảng NhanVien.

		  (Họ)―――――( (HọTên) )―――――(Tên)
				|
				|
		(M̲ã̲N̲V̲)―――――| NhânViên |―――――((SĐT))
				|
				|
			    (GiớiTính)


		NhanVien (M̲a̲N̲V̲, Ho, Ten, GioiTinh)
			   ^
			   |
			   ------------
			   	      |
		SDT_NhanVien (S̲D̲T̲, #MaNV)

------------------------------------------------------------

Bước 2: Chuyển đổi thực thể yếu (Weak Entity).

	* Thực thể yếu -> Bảng riêng

	* Thuộc tính riêng của mối kết hợp -> Cột trong bảng của thực thể yếu
	
	* Khoá:
		- Nếu thuộc tính yếu có khoá định danh riêng:
			+ Khoá chính: Thuộc tính định danh riêng + Khoá chính của thực thể mạnh (giống với thuộc tính đa trị).
			+ Khoá ngoại: Thuộc tính định danh của thực thể mạnh trở thành khoá ngoại.

		- Nếu thuộc tính yếu không có khoá định danh riêng: Thuộc tính định danh của thực thể mạnh vừa là khoá chính, vừa là khoá ngoại.

	Ví dụ: Chuyển thực thể NhânViên thành bảng NhanVien.

		  (HọTên)			(MốiQuanHệ)
		     |				     |
		| NhânViên |―――――<< Có >>―――――|| NgườiThân ||―――――(NgàySinh)
		     |				     |
		  (M̲ã̲N̲V̲)			      (T̰ḛ̂n̰N̰T̰)


		NhanVien (M̲a̲N̲V̲, HoTen)
			    ^
			    |
			    |
		NguoiThan (#M̲a̲N̲V̲,̲ ̲T̲e̲n̲N̲T̲, HoTen, NgaySinh)

------------------------------------------------------------

Bước 3: Chuyển mối kết hợp (Relationship).

	(* Lưu ý: Dấu mũi tên của khoá ngoại sẽ xuất phát từ bên đi tham chiếu (Referencing) sang bên được tham chiếu (Referenced).		
		- Bên đi tham chiếu (Referencing): Chủ động chứa cột của bảng khác.
		- Bên được tham chiếu (Referenced): Nằm yên để người khác dùng cột của mình.)

	* Một ngôi:

		- 1-n: Khoá ngoại đệ quy, tham chiếu đến chính khoá chính trong bảng.
			+ Thuộc tính định danh của riêng mối kết hợp (hoặc phải tự tạo thêm) sẽ trở thành khoá ngoại.
			+ Vì chỉ có một bảng duy nhất, nên khoá ngoại sẽ tham chiếu đến chính khoá định danh của thực thể.

			Ví dụ: NhânViên quản lý / chịu sự quản lý (của) nhân viên khác.

				(M̲ã̲N̲V̲)―――――| NhânViên |―――――(HọTên)
					    |	     |
					1   |	     |    n
				     (1, 1) |	     | (0, n)
					    |	     |
					    ――<Q.Lý>――


				NhanVien (M̲a̲N̲V̲, HoTen, #MaNgQLy)
					   ^		  |
					   |		  |
					   ----------------


		- n-n: Tạo ra một bảng mới cho mối kết hợp.
			+ Vì chỉ có một ngôi, nên khoá chính sẽ phân thân ra thành hai cột khi sang bảng mới.
			+ Bảng mới sẽ có hai cột khoá chính của bảng gốc cùng làm khoá chính, đồng thời cũng là khoá ngoại.

			Ví dụ: Trước khi học một MônHọc, yêu cầu phải học qua một MônHọc khác.

				――――――| MônHọc |―――――――
				|		      |
			    n   |		      |    n
			 (0, n) |		      | (0, n)
				|		      |
				―――――< Điều kiện >―――――


				MonHoc (M̲a̲M̲H̲, TenMH, SoTinChi)
					 ^
					 |
					 ----------------
					    |		|
				DieuKien (#̲M̲a̲M̲H̲,̲ ̲#̲M̲a̲M̲H̲T̲i̲e̲n̲Q̲u̲y̲e̲t̲)


	* Hai ngôi:

		- 1-1: Lấy khoá chính của một bên "xuất ngoại" sang bên còn lại.
			+ Nếu có phân biệt bằng trọng số tối thiểu, khoá chính ở phía bắt buộc (1) sẽ làm khoá ngoại ở phía tuỳ chọn (0).
			+ Nếu hai trọng số bằng nhau thì đặt khoá ngoại tuỳ ý.
			+ Nhưng dù trong trường hợp nào thì những thuộc tính riêng (nếu có) của mối kết hợp đều sẽ đi chung với khoá ngoại.
			+ Phải có thêm ràng buộc, yêu cầu cấm trùng (UNIQUE) trên cột khoá ngoại, nếu không sẽ trở thành trường hợp 1-n.

			Ví dụ: Mối kết hợp giữa BácSĩ và TrạmYTế.

				 (HọTên)				       (TênTYT)
				    |	      1				1	  |
				| BácSĩ |――(1, 1)―――< Làm trưởng >―――(0, 1)――| TrạmYTế |
				    |			  |			  |
				 (M̲ã̲B̲S̲)		(NgàyNhậmChức)		   (M̲ã̲T̲Y̲T̲)
				

				BacSi (M̲a̲B̲S̲, HoTen)
					^
					|
					-------------------
							  |
				TramYTe (M̲a̲T̲Y̲T̲, TenTYT, #MaBS, NgayNhamChuc)


		- 1-n: Lấy khoá chính của bên ít "xuất ngoại" sang bên nhiều.
			+ Những thuộc tính riêng (nếu có) của mối kết hợp cũng sẽ thuộc về bên nhiều.

			Ví dụ: Mối kết hợp giữa KháchHàng và ĐơnHàng.

				  (HọTên)					(NgàyĐặt)
				     |		   1			 n	    |
				| KháchHàng |―――(1, 1)―――――< Có >―――――(0, n)―――| ĐơnHàng |
				     |						    |
				  (M̲ã̲K̲H̲)					     (M̲ã̲Đ̲H̲)
				

				KhachHang (M̲a̲K̲H̲, HoTen)
					    ^
					    |
					    ---------------
							  |
				DonHang (M̲a̲D̲H̲, NgayDat, #MaKH)


		- n-n: Mối kết hợp được chuyển thành một bảng trung gian.
			+ Tên của bảng có thể là tên của mối kết hợp hoặc tên ghép của hai bảng.
			+ Khoá định danh của từng thực thể sẽ hợp lại (khoá đôi/cặp), cùng làm khoá chính cho bảng mới và cũng đồng thời làm khoá ngoại.
			+ Nhưng thuộc tính riêng (nếu có) của mối kết hợp sẽ trở thành cột trong bảng mới.

			Ví dụ: Mối kết hợp giữa SinhViên và MônHọc.

				  (HọTên)					(TênMH)
				     |		  n			 n	   |
				| SinhViên |―――(0, n)―――――< Học >―――――(0, n)―――| MônHọc |
				     |						   |
				  (M̲ã̲S̲V̲)					     (M̲ã̲M̲H̲)
				

				SinhVien (M̲a̲S̲V̲, HoTen)
					    ^
					    |
				       ------
				       |
				Hoc (#M̲a̲S̲V̲,̲ ̲#M̲a̲M̲H̲)
					      |
					 ------
					 |
					 v
				MonHoc (M̲a̲M̲H̲, TenMH)


	* Ba ngôi:

		* Mối kết hợp -> Bảng riêng
			- Không còn quan tâm đến trọng số của từng mối kết hợp.
			- Tất cả thuộc tính định danh của các thực thể có liên quan sẽ cùng hợp lại để làm khoá chính cho bảng mới, đồng thời cũng là khoá ngoại.
			- Sẽ dễ gây thiếu nhất quán trong dữ liệu khi có những sự kết hợp không hợp lệ giữa các thực thể.
				1. Tách các mối kết hợp ba ngôi thành hai ngôi.
				2. Đính kèm danh sách các ràng buộc toàn vẹn cho công đoạn thiết kế mô hình vật lý.

		Ví dụ: Mối kết hợp giữa NhàCungỨng, MặtHàng và CửaHàng.

					   (HìnhThứcVC)	  (GiáThành)
						    |	    |
						    |	    |
			| NhàCungỨng |―――(1, n)――――< CungCấp >――――(1, n)―――| CửaHàng |
							│
							│
						      (1, n)
							│
						    | MặtHàng |


			NhaCungUng (M̲a̲N̲C̲U̲)
					^
					|
					-----------
						  |
			Cua Hang (M̲a̲C̲H̲)	      |
				    ^		  |
				    |		  |
				    -------	  |
					  |	  |
			MatHang (M̲a̲M̲H̲)    |	      |
				   ^	  |	  |
				   |	  |	  |
				   |	  |	  |
			CungCap (#M̲a̲M̲H̲,̲ ̲#M̲a̲C̲H̲,̲ ̲#M̲a̲N̲C̲U̲, HinhThucVC, GiaThanh)

------------------------------------------------------------

Bước 4: Chuyển thực thể kết hợp (Associative Entity).

	* Thực thể kết hợp -> Bảng riêng

	* Khoá
		- Nếu thực thể kết hợp không có sẵn khoá định danh thì lấy khoá định danh của từng thực thể hợp lại, cùng làm khoá chính cho bảng mới và cũng đồng thời làm khoá ngoại.
		- Nếu thực thể kết hợp đã có sẵn khoá định danh thì chuyển thành khoá chính và lấy 2 khoá định danh của hai thực thể thông thường làm khoá ngoại.

	Ví dụ: Thực thể kết hợp ChứngChỉ.

		  (HọTên)					  (TênKH)
		     |		     n		      n		     |
		| NhânViên |――――――――――| < ChứngChỉ > |――――――――――| KhoáHọc |
		     |			 |	  |		     |			
		  (M̲ã̲N̲V̲)	    (M̲ã̲C̲h̲ứ̲n̲g̲C̲h̲ỉ̲)    (NgàyHoànThành)	(M̲ã̲K̲H̲)


		NhanVien (M̲a̲N̲V̲, HoTen)
			   ^
			   |
			   ------------------------------
							|
		ChungChi (M̲a̲C̲h̲u̲n̲g̲C̲h̲i̲, NgayHoanThanh, #MaNV, #MaKH)
								|
			  ---------------------------------------
			  |
			  v
		KhoaHoc (M̲a̲K̲H̲, HoTen)

------------------------------------------------------------

Bước 5: Chuyển thực thể Cha-Con.

	- Bao gồm 3 phong cách khác nhau:

		1. Cha-Con tách biệt:

			* Thực thể Cha -> Bảng Cha
				* Thuộc tính chung của Cha -> Cột của Cha

			* Thực thể Con -> Bảng Con
				* Thuộc tính riêng của Con -> Cột Con
				* Khoá định danh Cha -> Khoá chính + Khoá ngoại Con

		2. Chỉ Con tồn tại:
			- Loại bỏ thực thể Cha, chuyển tất cả các thực thể Con thành các bảng.
			- Mỗi Con sẽ có đầy đủ thuộc tính như Cha + thuộc tính riêng của mình.

		3. Chỉ Cha tồn tại:
			- Loại bỏ thực thể Con, chuyển thực thể Con thành một bảng.
			- Các thuộc tính của Cha sẽ bao gồm cả các thuộc tính riêng của Con + thuộc tính bổ sung để xác định Con nào đang được đề cập.

		Ví dụ: Các chức danh công việc trong một công ty CNTT (bằng phong cách 1).
		
			| LậpTrìnhViên |―――――――――――――――――――∈―――――\
			| ChuyênViênPhânTíchNghiệpVụ |―――――∈―――――〇―――――| NhânViên |
			| KiểmThửViên |――――――――――――――――――――∈―――――/


			NhanVien (M̲a̲N̲V̲, HoTen)

			LapTrinhVien(#M̲a̲N̲V̲, SoTinhNangVietDuoc)

			ChuyenVienPhanTichNghiepVu(#M̲a̲N̲V̲, SoSoDoHeThongDaVe)

			KiemThuVien(#M̲a̲N̲V̲, SoLoiTimDuoc)

--------------------------------------------------------------------------------

Có thể dữ liệu sẽ nằm rải rác trong bảng (Table) để phục vụ cho những triết lý thiết kế. Vì vậy, ta phải sử dụng thêm nhiều kỹ thuật khác nhau để lắp ráp lại thành đúng dữ liệu cần dùng bằng câu lệnh JOIN.

* Tính bất thường của dữ liệu (Anomaly): Thông tin bị lặp lại quá nhiều khi gộp thành một bảng duy nhất và bị phân mảnh khi được tách thành nhiều bảng khác nhau.

	- Giúp dữ liệu tránh bị lặp lại nhiều đến mức không cần thiết. Nhưng trước khi đi, vẫn để lại một "mảnh hồi ức" để sau này có thay đổi ở nơi khác thì nơi này vẫn được thay đổi theo, giúp tăng tính nhất quản của dữ liệu và tránh việc phải nhập lại quá nhiều thông tin.

		Ví dụ: Dữ liệu về sinh viên có thể được tách ra thành nhiều bảng
			- Bảng: Thông tin sinh viên
			- Bảng: Thông tin chuyên ngành học
			- Bảng: Thông tin CLB tham gia
			- ...
			-> Nếu một thông tin trong bảng bị thay đổi thì những bảng có liên quan sẽ thay đổi theo.

	- Một số cột thường sẽ được tách ra làm nhiều cột nhỏ để phục vụ cho việc lưu trữ và sắp xếp.

		Ví dụ: họ và tên sẽ được tách làm hai cột với mục đích.
			- Phù hợp với việc lưu trữ tên của người Việt và người nước ngoài.
			- In ra theo phong cách / quy ước riêng của mỗi quốc gia.

	- Khi dữ liệu được tách ra thành nhiều bảng khác nhau, giữa các bảng sẽ liên kết với nhau bằng khái niệm "Mối quan hệ (Relationship)" hay "Tham chiếu (Reference)".

	* Insertion Anomaly in Referencing Relation: Thêm vào bên nhận (Referencing) những dữ liệu mà bên cho (Referenced) không hề có.

	* Deletion/ Updation Anomaly in Referenced Relation: Không thể xoá hoặc chỉnh sửa những dữ liệu ở bên cho (Referenced), nếu bên nhận (Referencing) đang sử dụng nó, nhưng nếu bên nhận (Referencing) đang không sử dụng thì có thể xoá hoặc cập nhật bình thường.
		- On Delete Cascade:
		- On Update Cascade:


Việc đặt toàn bộ dữ liệu trong cùng một bảng duy trong CSDL sẽ gây nên nhiều hệ luỵ.

Nghệ thuật thiết kế CSDL.
	1. Tìm ra số bảng cần phải tạo (tách bảng).
	2. Tìm ra mối quan hệ / liên kết giữa các bảng.
	-> Đích đến cuối cùng: Có được CSDL để bắt đầu khai thác dữ liệu.

	-> Chuẩn hoá CSDL (Normalization): Kỹ thuật tách bảng làm sao cho thật khéo.

--------------------------------------------------------------------------------

Có thể thấy, bảng sẽ là nơi lưu trữ những dữ liệu có cùng cấu trúc, giúp tạo nên sự nhất quán.

Nhưng với sự phong phú của dữ liệu, NoSQL ra đời.

	- Là một mô hình không dựa trên khái niệm bảng.

	- Là dạng cơ sở dữ liệu mà các dữ liệu bên trong không nhất thiết phải có cùng cấu trúc, số cột có thể thay đổi.

==========================================================================================

[THIẾT KẾ - MỨC VẬT LÝ]

* Những khái niệm tương đương khi chuyển từ mô hình luận lý sang vật lý:

	- Bảng ở mức ý niệm (Schema): Là những ngăn tủ rỗng, chưa có bất kì món đồ nào bên trong.
		- Giống như một bản phác thảo để cho biết hình dáng thật sự của chiếc tủ sẽ ra sao.
		- Được phác thảo thiết kế sơ khởi bằng ERD, sau đó tiếp tục được chuyển thành RS để gần hơn với mức vật lý.

	- Bảng đầy đủ (Table / Relation): Tủ đựng đồ với nhiều ngăn chứa và đồ đạc (dữ liệu) bên trong.

	- Cơ sở dữ liệu (Database): Căn phòng lớn để chứa bên trong nhiều tủ đựng đồ.

	- Dòng (Row): Những món đồ, phụ kiện, quần áo... sau khi mua về sẽ được lập tức cất vào trong tủ.

==========================================================================================
==========================================================================================
==========================================================================================

[THAO TÁC TRUY VẤN DỮ LIỆU VỚI NGÔN NGỮ SQL TRÊN SQL SERVER]

Câu lệnh của SQL là sự kết hợp giữa các từ khoá và các từ do người dùng tự định nghĩa.

	- Bao gồm các từ:
		1. Từ khoá (Reserved): Là các từ khoá do SQL quy định sẵn (ví dụ: SELECT, FROM, WHERE,...).
		2. Từ do người dùng định nghĩa (User-defined): Là tên do người dùng tự đặt và không bị trùng với từ khoá (ví dụ: tên bảng, tên cột, tên view...).

	- Vì mục đích của cơ sở dữ liệu là để lưu trữ và cho phép tìm được càng nhiều dữ liệu càng tốt, nên đối với collation mặc định, SQL Server sẽ không phân biệt hoa/ thường.
		+ Việc phân biệt hoa thường sẽ gây cản trở trong việc tìm kiếm.
		+ Tuy nhiên, khuyến khích viết theo dạng chuẩn Backus–Naur (Backus–Naur form/ Backus normal form - BNF):
			1. Các từ khoá của ngôn ngữ nên được viết in hoa.
			2. Các từ do người dùng tự định nghĩa sẽ được viết theo cú pháp UpperCamelCase/ PascalCase.
			3. Các dữ liệu là chuỗi hoặc ngày-tháng-năm phải được đặt trong dấu nháy đơn (ví dụ: 'TP.HCM', '01/01/1900',...).
			4. Các cụm câu lệnh có liên quan đến nhau (ví dụ: JOIN-ON, GROUP BY-HAVING,...), vế sau nên được viết tab vào bên trong.

Trong SQL Server:

	- Phím tắt để thực thi câu lệnh trong SQL Server là [F5].

	- Mặc định, các câu lệnh sẽ chạy theo thứ tự từ trên xuống dưới. Vì vậy, để chỉ định một câu lệnh hoặc một nhóm câu lệnh cần thực thi, ta có thể quét chọn (bôi đen) câu lệnh hoặc một nhóm câu lệnh đó.

	- Với phiên bản SQL Server 2014, ta có thể định dạng lại các câu lệnh bằng tổ hợp phím: [Crtl] + [K], [Ctrl] + [Y].

* Lưu ý:

	- Câu lệnh (Statement) thường ám chỉ một câu lệnh SQL hoàn chỉnh, thực hiện một nhu cầu cụ thể và được thực thi bởi HQTCSDL.
		-> Câu lệnh hoàn chỉnh.

	- Mệnh đề (Clause) là từng từ khoá riêng lẻ (ví dụ: WHERE, FROM, SELECT, ORDER BY, GROUP BY,...) kết hợp với nhau theo nhiều cách để tạo thành một câu lệnh.
		-> Một phần của câu lệnh.

		Ví dụ: Câu lệnh hoàn chỉnh với ba mệnh đề cơ bản: SELECT, FROM, WHERE.

			SELECT Bdate, Address
			FROM EMPLOYEE
			WHERE Fname = 'John' AND Minit = 'B' AND Lname = 'Smith'

==========================================================================================

[CÂU LỆNH ĐỂ LẤY DỮ LIỆU RA: SELECT - SELECT STATEMENT]

Quy trình xây dựng câu truy vấn:
	1. Xác định các thông tin cần thiết.
	2. Xác định các bảng chứa các thông tin cần lấy.
	3. Xác định các điều kiện.
	4. Xác định các thông tin trả về.

--------------------------------------------------------------------------------

Có rất nhiều câu lệnh để tương tác với CSDL.

Một trong những câu lệnh đầu tiên là SELECT.

	- Có các công dụng:

		1. Lấy dữ liệu lên, tính toán và in ra màn hình (giống như những câu lệnh in ra màn hình của các ngôn ngữ lập trình: printf(), cin, System.out.println(), echo...).

		2. In ra dữ liệu đang có trong bảng (dưới dạng hàng và cột).

		-> Luôn hiển thị dữ liệu ra dưới dạng bảng (gồm hàng và cột).

	- Tương đương với phép chiếu (Projection) trong ĐSQH khi cho phép liệt kê các cột (sử dụng đèn pin để rọi).

------------------------------------------------------------

* Cú pháp chuẩn: Một bảng và tất cả cột.

	SELECT *
	FROM <Tên bảng>

		- Gồm hai thành phần bắt buộc phải có trong các truy vấn SQL: SELECT và FROM.
			+ Mệnh đề FROM cho phép liệt kê bảng chứa dữ liệu cần lấy.
			+ Mệnh đề SELECT chọn ra các cột từ bảng được liệt kê trong FROM.

		- Khi viết truy vấn, có thể nhập tên bảng trong FROM trước để nhận được gợi ý khi liệt kê tên cột trong SELECT.

		-> In toàn bộ dữ liệu trong một bảng.

		Ví dụ: Lấy tất cả các cột trong bảng nhân viên

			-- Sử dụng dấu hoa thị/ dấu sao '*'
			-- để đại diện cho tất cả các cột trong bảng
			SELECT *
			FROM Employees

----------------------------------------

* Cú pháp mở rộng: Liệt kê cột trong SELECT.

	SELECT <Danh sách cột>
	FROM <Tên bảng>

		- Liệt kê danh sách các cột cần lấy từ một bảng, những cột không sử dụng đến sẽ được ẩn đi.

		- Mỗi cột được liệt kê cách nhau bằng dấu phẩy ','.

		-> In một vài cột trong bảng.
	
		Ví dụ: Chỉ lấy một số cột trong bảng nhân viên.

			SELECT EmployeeID, LastName, FirstName, Title, BirthDate
			FROM Employees

----------------------------------------

* Cú pháp mở rộng: Tính toán trên cột trong SELECT.

	SELECT <Biểu thức tính toán trên cột>
	FROM <Tên bảng>

		- Ngoài việc cho phép liệt kê tên các cột có trong bảng, mệnh đề SELECT còn cho phép sử dụng thêm hàm và phép toán để xử lý các cột.

		- Kết quả trả về một cột mới (không có tên).

		Ví dụ: Xử lý các cột trong bảng nhân viên.

			-- Sử dụng phép toán cộng
			-- để ghép cột họ và tên thành cột tên đầy đủ
			SELECT EmployeeID,
			       LastName + ' ' + FirstName,
			       2 * Salary
			FROM Employees
	
			-- Sử dụng hàm
			-- để tính toán tuổi dựa theo cột ngày sinh
			SELECT YEAR(GETDATE()) - YEAR(BirthDate)
			FROM Employees

----------------------------------------

* Cú pháp mở rộng: Liệt kê bảng trong FROM.

	SELECT <Danh sách cột/ biểu thức>
	FROM <Danh sách bảng>

		- Nếu dữ liệu cần lấy nằm ở các bảng khác nhau, ta có thể chỉ định các bảng chứ dữ liệu trong FROM.

		- Nếu có từ hai bảng trở lên và không có mệnh đề WHERE thì kết quả sẽ là tích Đềcác của các bảng.

		Ví dụ: Tích Đềcác của hai bảng nhân viên và phòng ban.

			SELECT *
			FROM Employees, Department

----------------------------------------

* Cú pháp mở rộng: Đặt bí danh (Alias) bằng AS.
		
	SELECT <Danh sách cột/ biểu thức> AS 'Tên mới của cột'
	FROM <Danh sách bảng> AS [Tên tắt của bảng]

		- Trong SQL, mỗi cột trong một bảng không được phép trùng tên.
			+ Cả hai cột chỉ được phép trùng tên nếu khác bảng.
			+ Nếu có nhu cầu cùng sử dụng cả hai cột trùng tên này, cần phải có cách để tránh bị mơ hồ (ambiguous).

		- Để phân biệt giữa các cột trong trường hợp trùng tên:
			1. Sử dụng tên bảng và dấu chấm '.' để chỉ định cột trong bảng.
			2. Sử dụng tên giả/ tên tắt/ biệt hiệu/ bí danh (alias).

		- Không chỉ được sử dụng để đặt tên tạm cho cột, từ khoá AS còn được sử dụng để đặt tên tạm cho biểu thức tính toán và tên bảng.
			+ Có thể tường minh sử dụng từ khoá AS hoặc không (ngầm định)
			+ Nếu tên mới của cột có khoảng trắng hoặc dấu tiếng Việt, cần bổ sung thêm dấu nháy đơn hoặc dấu ngoặc vuông.

		- Tên tạm chỉ có phạm vi sử dụng trong một câu truy vấn.

		Ví dụ 1: Sử dụng tên bảng để phân biệt cột.

			-- Cả bảng Employees và Department
			-- đều có cột Name, vì vậy,
			-- cần chỉ định rõ cột nào muốn sử dụng
			-- bằng cách thêm tiền tố tên bảng trước tên cột
			SELECT Fname, Employees.Name, Address
			FROM Employees, Department

		Ví dụ 2: Đặt tên cột và tên tạm cho bảng nhân viên.

			-- Sử dụng tên tạm của bảng để gọi tên cột
			-- và sau đó đặt tên tạm cho các cột trong bảng
			SELECT E.EmployeeID AS 'Mã nhân viên',
			       E.LastName + ' ' + E.FirstName AS [Họ và tên nhân viên],
			       2 * E.Salary Luong,
			       YEAR(GETDATE()) - YEAR(E.BirthDate) Tuoi,
			       D.*

			-- Đặt tên tạm cho bảng
			-- để có thể sử dụng trong các mệnh đề khác
			-- mà không tốn công viết đầy đủ tên gốc của bảng nhiều lần
			FROM Employees E, Department D

--------------------

* Lưu ý 1: Vì SQL không phân biệt kí tự hoa/ thường, nên dù có đặt tên in hoa toàn bộ thì vẫn có thể sử dụng tên in thường.

* Lưu ý 2: Mệnh đề WHERE sẽ được thực thi trước mệnh đề SELECT, nên không thể sử dụng bí danh của cột SELECT trong WHERE.

	Ví dụ: Đặt bí danh cho bảng và thuộc tính của bảng NHANVIEN.

		-- Sử dụng bí danh không phân biệt hoa/ thường
		SELECT nv.LastName AS lt, nv.FirstName AS fn
		FROM Employees AS NV

		-- Không thể lấy bí danh đã đặt trong SELECT
		-- sử dụng cho các điều kiện trong WHERE
		WHERE fn = 'Nguyen' -- Báo lỗi: "Invalid column name"

----------------------------------------

* Cú pháp mở rộng: Thay đổi giá trị của kết quả bằng CASE.

	-- Cú pháp so sánh bằng
	CASE <Tên cột>
		WHEN <Giá trị trong cột> THEN N'Giá trị hiển thị ra'
		ELSE N'Giá trị thay thế'
	END [AS] 'Tên cột mới'

	-- Cú pháp so sánh không bằng
	CASE
		WHEN <Điều kiện đầu tiên> THEN N'Giá trị hiển thị ra'
		ELSE N'Giá trị thay thế, tương đương với điều kiện thứ hai'
	END [AS] 'Tên cột mới'

		- Bên cạnh việc thay đổi tên cột được hiển thị ra, ta còn có thể thay đổi giá trị trả về được hiển thị ra ở bên trong các cột.

		- Dựa trên việc so sánh để quyết định xem thông tin nào sẽ được hiển thị ra.
			+ Nếu là so sánh bằng, tên cột được phép nằm phía sau từ khoá CASE.
			+ Nếu là so sánh với các phép toán: >, <,..., tên cột được viết ở phía sau từ khoá WHEN (được lồng trong CASE).

		Ví dụ: Thay đổi giá trị hiển thị ra trong cột của bảng nhân viên và đặt tên cho cột có giá trị bị thay đổi.

			SELECT Name,
				CASE
					WHEN Salary >= 30,000,000 THEN N'Lương cao'
					ELSE N'Lương thấp'
				END AS 'Tình trạng lương',

				CASE Gender
					WHEN 'Male' THEN 'Nam'
					ELSE N'Nữ'
				END 'Giới tính'

			FROM Employees

----------------------------------------

* Cú pháp mở rộng: Loại bỏ những dữ liệu bị trùng bằng từ khoá DISTINCT.

	SELECT DISTINCT <Danh sách cột/ biểu thức>
	FROM <Danh sách bảng>

		- Dữ liệu từ cột trong bảng có nguy cơ bị trùng lặp (trùng 100%).
			+ Đây hoàn toàn không phải là sai sót trong việc nhập liệu hay thiết kế, mà chỉ đơn giản là vì có quá nhiều thông tin / đặc điểm trùng nhau và ta lại đang tập trung vào dữ liệu đó.
			+ Khi sử dụng mệnh đề SELECT, càng ít cột được chọn thì càng ít thông tin để phân biệt, càng tăng nguy cơ bị trùng dữ liệu.

		- Kết quả trả về là một tập hợp đa phần tử (multiset / bag) với các dòng có thể trùng nhau trong cùng một bảng.
			+ Đây là xử lý mặc định của từ khoá ALL trong câu lệnh SELECT.
			+ Các dòng trùng nhau sẽ không được tự động loại trừ vì phải sắp xếp theo thứ tự rồi mới loại bỏ được, và đôi khi việc bị trùng vẫn có giá trị sử dụng.
			+ Vì vậy, để chủ động loại bỏ những kết quả truy vấn bị trùng, cần sử dụng thêm từ khoá DISTINCT phía sau câu lệnh SELECT.

		Ví dụ 1: Hơn 100tr người dân Việt Nam sẽ được phân biệt với nhau theo nhiều cách, tối ưu nhất là phân biệt theo mã số CCCD.
			- Trong rất nhiều thông tin, nếu chỉ tập trung vào một thông tin duy nhất là tỉnh-thành phố thì việc trùng lặp chắc chắn sẽ diễn ra.
			- Toàn bộ người dân Việt Nam đều sẽ thuộc 63 Tỉnh và Thành phố.
			- Vì vậy, mặc dù có hơn 100tr dòng dữ liệu, nhưng cuối cùng chỉ có 63 giá trị là khác nhau.

		Ví dụ 2: Loại bỏ dữ liệu bị trùng trong bảng nhân viên.
		
			-- Sử dụng từ khoá DISTINCT
			-- để loại bỏ những giá trị trùng nhau trong cột tên quốc gia
			SELECT DISTINCT Country
			FROM Customers

--------------------

* Lưu ý 1: Nếu từ khoá DISTINCT đi kèm với khoá chính thì sẽ trở nên vô nghĩa, vì khoá chính đã mặc định cấm trùng nhau.

* Lưu ý 2: Không thể sử dụng DISTINCT trên những cột có kiểu dữ liệu nhị phân (Binary text) - Hexa, vì việc so sánh giữa hai tập tin nhị phân là vô nghĩa.

----------------------------------------

* Cú pháp mở rộng: Sắp xếp dữ liệu bằng ORDER BY.

	SELECT <Danh sách cột>
	FROM <Danh sách bảng>
	ORDER BY <Tên cột muốn sắp xếp> [Kiểu sắp xếp: tăng hoặc giảm dần]

		- Sắp xếp dữ liệu theo cách thức / tiêu chí:
			1. Tăng dần (Ascending - ASC).
			2. Giảm dần (Descending - DESC).
			(Mặc định sẽ sắp xếp tăng dần)

		- Ngoài ra, ta cũng có thể sắp xếp trên nhiều cột khác nhau.
			+ Ban đầu sẽ sắp xếp theo thứ tự của cột đầu tiên, nếu cột đầu tiên không chứa các giá trị trùng nhau thì các cột khác được liệt kê sẽ không bao giờ được sử dụng đến.
			+ Nếu có trùng nhau trong cột đầu tiên, các cột tiếp theo mới được sử dụng để sắp xếp, khi cột đầu tiên hết trùng sẽ trở lại thứ tự của cột đầu tiên.

		- Ngoài việc chỉ định trực tiếp tên cột, ta còn có thế sử dụng số thứ tự được liệt kê trong mệnh đề SELECT để ám chỉ cho tên cột.

		Ví dụ: Sắp xếp tên người tăng dần giảm dần (theo bảng chữ cái) và năm sinh giảm dần.

			-----------------------------------------
			| FirstName | LastName    | YearOfBirth |
			|-----------+-------------+-------------|
			| Thomas    | Alva Edison |	1847	|
			| Benjamin  | Franklin    |	1706	|
			| Thomas    | More        |	1478	|
			| Thomas    | Jefferson   |	1826	|
			-----------------------------------------

			SELECT *
			FROM People
			ORDER BY FirstName ASC, YearOfBirth DESC

			-----------------------------------------
			| FirstName | LastName    | YearOfBirth |
			|-----------+-------------+-------------|
			| Benjamin  | Franklin    |	1706	|
			| Thomas    | Alva Edison |	1847	|
			| Thomas    | Jefferson   |	1826	|
			| Thomas    | More        |	1478	|
			-----------------------------------------

----------------------------------------

* Cú pháp mở rộng: Liệt kê điều kiện chọn trong WHERE.

	SELECT <Danh sách cột>
	FROM <Danh sách bảng>
	WHERE <Danh sách điều kiện lọc các dòng>
		1. Tên cột
		2. Giá trị của cột
		3. Toán tử so sánh
		4. Toán tử luận lý

		- Là dạng cơ bản của câu lệnh SELECT, đôi khi còn được gọi là khối SELECT-FROM-WHERE (SELECT-FROM-WHERE block).

		- Mệnh đề WHERE được sử dụng để làm bộ lọc (filter).

			+ Dữ liệu cần lọc có thể là cột trong bảng hoặc điều kiện để kết nối (JOIN) giữa các bảng.

			+ Sử dụng các toán tử so sánh {=, <>, >, >=, <, <=} để kiểm tra một biểu thức và sử dụng các toán tử luận lý {AND, OR, NOT} để kết nối các biểu thức.

			+ Giúp lựa ra dữ liệu theo một tiêu chí nào đó (càng nhiều bộ lọc thì sẽ càng có ít dữ liệu được hiển thị ra).

			-> Lọc dữ liệu theo điều kiện.
			
		- Chỉ biết tên của cột chứa giá trị, không biết giá trị cần tìm nằm ở ô nào trong cột đó.
		
			+ Hoạt động như một vòng lặp khi phải liên tục kiểm tra từng ô trong cột chứa giá trị cần lọc, xem giá trị trong ô đó có thoả với điều kiện lọc hay không (so sánh giá trị trong ô).
			
			+ Kết quả trả về là một biểu thức điều kiện dạng luận lý (Boolean) - trả về các dòng thoả điều kiện.
			
			+ Sau đó tiếp tục chiếu (project) các dòng theo các cột được liệt kê trong mệnh đề SELECT (nếu có).

		Ví dụ 1:
			- Lọc ra toàn bộ những sinh viên có quê quán ở TP.HCM.
			- Lọc ra toàn bộ những sinh viên có quê quán ở TP.HCM và điểm trung bình >= 8.

		Ví dụ 2:
			-- Mệnh đề WHERE kết hợp với toán tử luận lý
			SELECT *
			FROM Customers
			WHERE Country = 'Italy' OR Country = 'USA'
			
			-- Mệnh đề WHERE kết hợp với toán tử luận lý và toán tử so sánh
			SELECT *
			FROM Students
			WHERE City = N'Hồ Chí Minh' AND GPA >= 8
			
			-- Mệnh đề WHERE kết hợp với hàm để tính toán
			SELECT *
			FROM Employees
			WHERE YEAR(BirthDate) >= 2010 OR YEAR(BirthDate) >= 2020

--------------------

* Lưu ý 1: Vì bộ lọc liên quan đến giá trị được chứa bên trong một ô, nên ta phải quan tâm đến kiểu dữ liệu.
	- Số (Numeric): số nguyên và thực, chỉ cần ghi con số (ví dụ: 1, 2, 3.14, 9.8,...).
	- Kí tự / Chuỗi (String): 'A', 'Ahihi',...
	- Ngày / Giờ (Date/Time): '2002-01-10',...
	
* Lưu ý 2: Nếu có sử dụng thêm mệnh đề ORDER BY thì phải để sau WHERE và mặc định sẽ được sắp xếp tăng dần (ASC).

----------------------------------------

* Cú pháp mở rộng: Lấy dữ liệu trong khoảng với BETWEEN-AND và trong tập hợp với IN.

	WHERE <Tên cột> BETWEEN (Giá trị 1) AND (Giá trị 2)

		- Để lọc dữ liệu trong một đoạn / khoảng / tập giá trị cho trước, thay vì sử dụng mệnh đề WHERE kết hợp với các toán tử ">= ... AND <= ...", ta có thể sử dụng toán tử BETWEEN và AND (giá trị nằm trong khoảng giữa hai giá trị).

		- Có thể lọc ra một khoảng giá trị số thưc, tuy nhiên, có thể xảy ra sai số do độ chính xác của số thực không phải lúc nào cũng hoàn hảo.
			+ Có thể sử dụng hàm ROUND() để giới hạn số chữ số thập phân.
			+ Có thể so sánh chênh lệch giữa hai giá trị với một giá trị epsilon nhỏ (ví dụ: 0.001) - mức độ chênh lệch chấp nhận được.

		Ví dụ: Chỉ lấy những nhân viên có mức lương trong khoảng 10tr đến 20tr.

			SELECT *
			FROM Employees

			-- Sử dụng điều kiện so sánh truyền thống
			WHERE Salary >= 10,000,000 AND Salary <= 20,000,000

			-- Sử dụng toán tử BETWEEN và AND
			WHERE Salary BETWEEN 10,000,000 AND 20,000,000

	WHERE <Tên cột> IN (Danh sách các giá trị)

		- Khi có một tập hợp các giá trị / mệnh đề đơn lẻ, rời rạc và được kết nối với nhau bằng toán tử OR, ta có thể thay thế bằng toán tử IN (giá trị rơi vào một trong những giá trị đã được liệt kê).

		- Sử dụng so sánh bằng để kiểm tra giá trị có tồn tại trong tập hợp hay không.

		* Lưu ý: Chỉ sử dụng được toán tử IN khi có thể liệt kê được tập giá trị.
			- So sánh bằng chính xác một giá trị nào đó, còn những khoảng số thực sẽ không thể liệt kê được vì giữa hai số thực sẽ có vô vàn những số thực khác.
			- Mặc dù đối với BETWEEN và AND thì vẫn có thể sử dụng khoảng số thực bình thường.

		Ví dụ: Chỉ lấy những đơn hàng được giao đến 1 trong 3 quốc gia được liệt kê.

			SELECT *
			FROM Orders
			WHERE ShipCountry IN ('UK', 'France', 'USA')
			ORDER BY ShipCountry

----------------------------------------

* Cú pháp mở rộng: Kiểu dữ liệu và trạng thái NULL.

	WHERE <Tên bảng> IS NULL
	WHERE <Tên bảng> IS NOT NULL
	WHERE NOT <<Tên bảng> IS NULL>

		- Trong thực tế, sẽ có những lúc mà ta không thể xác định được giá trị / thông tin của dữ liệu.
			+ Có thể là do không biết, bị giấu hoặc trở nên vô nghĩa trong ngữ cảnh sử dụng, nên ta không thể sử dụng toán tử so sánh thông thường được.
			+ Vì vậy, ta có một số phép toán so sánh bằng "đặc biệt".

		* Lưu ý: NULL ở đây là một trạng thái (với ô được tô màu vàng), không phải là một chuỗi 'NULL'.

		Ví dụ: Lọc ra những nhân viên có quốc gia khác NULL.
			SELECT *
			FROM Employees
			WHERE Region IS NOT NULL
			
			SELECT *
			FROM Employees
			WHERE NOT (Region IS NULL)

----------------------------------------

* Cú pháp mở rộng: So sánh gần đúng bằng LIKE.

	WHERE <Tên cột> LIKE N'_Chuỗi-cần-so-sánh%'

		- Đôi lúc, ta sẽ chỉ muốn lọc / tìm kiếm dữ liệu ở mức tương đối (kiểu chuỗi), nhưng lại không thể sử dụng toán tử so sánh bằng '=', vì dấu bằng là so sánh tuyệt đối (trùng 100%).

		- Vì vây, để so sánh gần đúng, ta sử dụng được toán tử LIKE:
			1. Dấu _: Đại diện cho chỉ một kí tự.
			2. Dấu %: Đại diện cho 0..n kí tự.

		Ví dụ:
			-- Bất kì ai có tên bắt đầu bằng chữ 'A',
			-- phần còn lại (một kí tự hoặc một chuỗi) không quan tâm
			SELECT *
			FROM Employees
			WHERE FirstName LIKE N'A%'	-- ≈ An, Anh,...

			-- Bất kì ai trong tên chỉ có hai chữ cái
			-- và bắt đầu bằng chữ 'A'
			SELECT *
			FROM Employees
			WHERE FirstName LIKE N'A_'	-- ≈ An, Ân, Ái,...

			-- Miễn trong tên quốc gia có chứa kí tự 'U',
			-- còn 'U' nằm ở đầu, giữa hoặc cuối thì tuỳ
			SELECT Country
			FROM Employees E
			WHERE E.Country LIKE '%U%'	-- ≈ UK, USA, Australia,...

----------------------------------------

* Cú pháp tạm đầy đủ của SELECT:

Một câu truy vấn trong SQL có thể có tối đa sáu mệnh đề, nhưng chỉ có hai mệnh đề SELECT và FROM là bắt buộc phải có.

	* Quy ước trong cú pháp:
		- Dấu | chỉ sự cho phép lựa chọn (hoặc).
		- Dấu ngoặc vuông [] chỉ thành phần không bắt buộc (tuỳ chọn).
		- Dấu ba chấm '...' chỉ sự lặp lại (0 hoặc nhiều lần).


	* Cú pháp:

		SELECT
			<* | Tên cột [AS TênMớiCủaCột] [,...]>
			<Biểu thức [AS ĐặtTênChoBiểuThức] [,...]>
			<DISTINCT | ALL | CASE ... END>
			<Hàm() AS ĐặtTênChoHàm>
			<Nested Query / Sub-Query: Câu truy vấn lồng nhau>

		FROM
			<Tên bảng [AS TênGọiTắt] [,...]>
			<Nested Query / Sub-Query: Câu truy vấn lồng nhau>

		[WHERE
			<Điều kiện lọc các dòng>			
			<Nested Query / Sub-Query: Câu truy vấn lồng nhau>
			<LIKE | IN | SOME/ ANY | BETWEEN ... AND ...>]

		[GROUP BY <Danh sách cột cần gom nhóm>]

			[HAVING <Điều kiện lọc cho các nhóm đã tạo>]

		[ORDER BY <Danh sách cột muốn sắp xếp> [Kiểu sắp xếp: tăng hoặc giảm dần]]

------------------------------------------------------------

Dù sử dụng cho mục đích nào thì kết quả hiển thị ra luôn dưới dạng bảng (gồm hàng và cột).

	Ví dụ 1: Công dụng 1 - Lấy dữ liệu lên, tính toán và in ra màn hình

		-- Hàm lấy ngày-giờ hiện tại của hệ thống (theo đồng hồ của máy tính cục bộ)
		-- sẽ luôn trả về thông tin dưới dạng bảng dù chỉ trả về một kết quả duy nhất
		SELECT GETDATE()

		-- Nhưng kết quả trả về dưới dạng bảng sẽ không có tên cột
		-- Vì vậy, ta có thể đặt tên giả cho bảng bằng câu lệnh AS
		SELECT GETDATE() AS [Hôm nay là ngày] -- Có khoảng trắng

		SELECT GETDATE() AS HômNayLàNgày -- Không có khoảng trắng


		-- Vì hàm có trả về giá trị nên ta hoàn toàn có thể
		-- đem giá trị sang một nơi khác để tiếp tục sử dụng
		-- (Hàm gọi hàm / Hàm lồng trong hàm)
		SELECT MONTH(GETDATE()) AS [Bây giờ tháng mấy?]

	Ví dụ 2: Công dụng 1 - Lấy dữ liệu lên, tính toán và in ra màn hình

		-- Sử dụng hàm lấy giá trị tuyệt đối của một số
		SELECT ABS(-5) AS [Trị tuyệt đối của (-5) là]

		-- Tính toán một phép tính và in ra kết quả
		SELECT 5 + 5 [Kết quả của 5 + 5 là]

		-- Hàm gọi hàm để tính toán
		SELECT YEAR(GETDATE()) - 2000 AS [My age is]

	Ví dụ 3: Công dụng 1 - Lấy dữ liệu lên, tính toán và in ra màn hình

		-- In ra một chuỗi, nhưng sẽ không hiểu được Unicode
		-- Vì vậy, phải sử dụng thêm N để in ra tiếng Việt có dấu
		SELECT N'Cơ sở dữ liệu'

		-- Nhưng để in ra thành công,
		-- toàn bộ các câu lệnh phải có cùng một kiểu dữ liệu
		SELECT N'Nguyễn Hoàng Thuận - ' + CONVERT(varchar, YEAR(GETDATE()) - 2000) + ' years old'
		AS [My full info is]

----------------------------------------

	Ví dụ 1: Công dụng 2 - In ra dữ liệu đang có trong bảng (dưới dạng hàng và cột)

--------------------------------------------------------------------------------

* Lưu ý: mặc dù có xử lý và tính toán, nhưng câu lệnh SELECT sẽ không làm ảnh hướng / thay đổi dữ liệu gốc trong cơ sở dữ liệu, mà chỉ đơn giản là hiển thị ra kết quả xử lý, cho dù có thực hiện bao nhiêu lần đi chăng nữa. Chỉ những câu lệnh như INSERT, UPDATE hoặc DELETE mới thay đổi dữ liệu gốc.

==========================================================================================

[TRUY VẤN LỒNG - NESTED QUERY]

	* Tập hợp (Set): Không được phép trùng.
	* Danh sách (List): Được phép trùng.

Thay vì được sử dụng độc lập để trả về kết quả. Giờ đây, kết quả của câu truy vấn có thể được sử dụng để lồng vào bên trong một câu truy vấn khác thông qua các toán tử so sánh.
	- Truy vấn Con/ Truy vấn phụ (Subquery/ Inner query/ Inner select): Được nhúng vào một truy vấn khác, kết quả truy vấn sẽ được chính nơi đó sử dụng.
	- Truy vấn Cha/ Truy vấn ngoài (Parent query/ Outer query/ Outer select): Chứa bên trong một truy vấn phụ và cần truy vấn phụ này trả về kết quả để có thể xử lý tiếp.

Trong một câu SQL có chứa/ lồng bên trong một câu SQL khác.
	- Câu truy vấn phụ có thể được lồng trong mệnh đề SELECT, FROM, WHERE hoặc bất cứ nơi nào cần thiết.
	- Kỹ thuật này được gọi là "Đặt câu hỏi gián tiếp" hoặc "So sánh tương quan".
	- Nếu kết quả trả về là một giá trị duy nhất (1 dòng và 1 cột), giá trị này sẽ được gọi là giá trị vô hướng (scalar value).

	-> Kỹ thuật viết truy vấn theo kiểu hỏi gián tiếp.

Có rất nhiều cách khác nhau, và đây là một trong những cách đơn giản nhất.

Trong mệnh đề WHERE của câu lệnh SELECT, "bộ lọc" có thể là:

	1. WHERE <Tên cột> (Toán-tử-so-sánh: =, >, <...) <Giá-trị>
		-> Có thể thay thế phần "Giá-trị" bằng một câu SQL khác, miễn vẫn trả về duy nhất một ô chứa duy nhất giá trị.

	2. WHERE <Tên cột> LIKE '_ % _'
	3. WHERE <Tên cột> BETWEEN ... AND ...

	4. WHERE <Tên cột> IN <Một tập hợp các giá trị được liệt kê>
		-> Có thể thay thế phần "(Một tập hợp các giá trị được liệt kê)" bằng một câu SQL khác, miễn vẫn trả về một tập hợp gồm nhiều giá trị cùng kiểu của cùng một cột.

	5. WHERE <Tên cột> (Toán-tử-so-sánh: =, >, <...)
				ALL (Câu truy vấn lồng trả về một cột nhiều giá trị)
				ANY (Câu truy vấn lồng trả về một cột nhiều giá trị)

--------------------------------------------------------------------------------

Câu truy vấn phụ ở bên trong phải được thực thi thành công và trả về giá trị, thì câu truy vấn bên ngoài mới có thể thực thi tiếp được.

Câu truy vấn bên ngoài có thể đón giá trị trả về từ câu truy vấn phụ bằng các toán tử so sánh (=, >, <, IN, ALL,...), miễn là có cùng kiểu dữ liệu trả về-nhận vào.

* Tuỳ vào cách viết mà một câu lệnh SELECT có thể:

------------------------------------------------------------

	1. Nhận vào một giá trị:

		- Một giá trị duy nhất, nằm trong một ô duy nhất, thuộc một cột duy nhất (không phải cả một dòng với nhiều cột).

			Ví dụ: Sử dụng bộ lọc lên cột làm khoá chính và chỉ in ra duy nhất một giá trị trong cột.
				SELECT FirstName
				FROM Employees
				WHERE EmployeeID = 1

		- Vì kết quả cuối cùng là trả về duy nhất một giá trị (được chứa trong một ô), nên câu truy vấn này lại có thể tiếp tục tham gia / được lồng vào trong một câu truy vấn khác.

		- Có thể thoải mái sử dụng các phép toán so sánh: =, <>, >, <,...

			Ví dụ: Liệt kê những ai cùng quê với King Robert.
			
				---- * Câu hỏi trực tiếp: Quê quán của King Robert
				
				-- Lấy được ra chính xác King Robert
				SELECT *
				FROM Employees
				WHERE FirstName = 'Robert'
				
				-- Trả về duy nhất một ô chứa giá trị
				-- là thành phố - nơi King Robert đang sống
				SELECT City
				FROM Employees
				WHERE FirstName = 'Robert'
				
				---- * Câu hỏi gián tiếp: Những nhân viên cùng quê với King Robert
				SELECT *
				FROM Employees

				-- Lấy câu truy vấn trả về giá trị là một ô chứa thành phố
				-- gán vào nơi nhận giá trị đầu vào là một thành phố
				-- ≈ WHERE City = 'London'
				WHERE City = (
						SELECT City FROM Employees
						WHERE FirstName = 'Robert'
					     )

				-- Loại King Robert ra khỏi kết quả tìm kiếm,
				-- vì đang chỉ cần tìm người có cùng quê quán với King Robert			 
				AND FirstName != 'Robert'

------------------------------------------------------------

	2. Nhận vào một tập hợp các giá trị:

		- Tập hợp các kết quả đồng nhất (các giá trị khác nhau của cùng một cột).

			Ví dụ: In ra một tập hợp các giá trị cùng kiểu của cùng một cột.
				SELECT FirstName
				FROM Employees

		- Được gọi là tập hợp vì các giá trị (dòng) bên trong đều có cùng một kiểu và thuộc cùng một cột.

		- Có ba kiểu để so sánh một giá trị với một tập hợp các giá trị được trả về từ câu truy vấn phụ:

			IN: Chỉ được so sánh bằng, kiểm tra giá trị có tồn tại trong tập hợp hay không.
				- Khi viết:
					+ Phía trước không cần toán tử so sánh bằng.
					+ Phía sau phải là một câu truy vấn lồng hoặc một tập hợp (trùng hoặc không trùng) các giá trị được liệt kê cách nhau bởi dấu phẩy.
				- Nếu tập hợp chỉ bao gồm 1 giá trị, có thể trực tiếp sử dụng dấu bằng để so sánh thay vì từ khoá IN.
				- Điều kiện so sánh sẽ trả về TRUE nếu giá trị là một phần tử của tập hợp.
				- Chỉ cần thoả mãn một trong những giá trị được liệt kê trong IN là được, không cần phải thoả mãn tất cả.
				- Được dùng để thay thế cho cách viết điều kiện OR liên tiếp nhau.

			ANY/ SOME: Được sử dụng tất cả các toán tử so sánh (không chỉ riêng mỗi dấu bằng giống như từ khoá IN), kiểm tra giá trị có thoả mãn điều kiện với các giá trị trong câu truy vấn lồng hay không.
				- Khi viết:
					+ Phía trước phải chỉ rõ toán tử so sánh cần sử dụng.
					+ Phía sau phải là một câu truy vấn lồng.
				- Điều kiện so sánh sẽ trả về TRUE nếu giá trị là một phần tử của tập hợp.
				- Nếu câu truy vấn phụ là rỗng, không có giá trị nào để so sánh, điều kiện so sánh với ANY/ SOME sẽ mặc định là FALSE.
				- Nghĩa là nếu đem một giá trị đi so sánh với tập hợp các giá trị trong câu truy vấn phụ (và câu truy vấn phụ trả về kết quả rỗng) thì giá trị đó KHÔNG {=, >, <,...} so với với bất kì giá trị nào trong truy vấn phụ.

			ALL: Được sử dụng tất cả các toán tử so sánh, kiểm tra giá trị có thoả mãn điều kiện với tất cả các giá trị trong câu truy vấn lồng hay không.
				- Khi viết:
					+ Phía trước phải chỉ rõ toán tử so sánh cần sử dụng.
					+ Phía sau phải là một câu truy vấn lồng.
				- Điều kiện so sánh sẽ trả về TRUE nếu tất cả các giá trị trong tập hợp đều thỏa mãn điều kiện so sánh.
				- Nếu câu truy vấn phụ là rỗng, không có giá trị nào để so sánh, điều kiện so sánh với ALL sẽ mặc định là TRUE.
				- Nghĩa là nếu đem một giá trị đi so sánh với tập hợp các giá trị trong câu truy vấn phụ (và câu truy vấn phụ trả về kết quả rỗng) thì giá trị đó {=, >, <,...} so với với tất cả giá trị trong truy vấn phụ.

			Ví dụ: Liệt kê những đơn hàng do những nhân viên có quê ở Luân Đôn phụ trách.
			
				---- * Câu hỏi trực tiếp: Danh sách các nhân viên có quê ở Luân Đôn
				
				-- Lấy được ra danh sách những nhân viên có quê ở Luân Đôn
				SELECT *
				FROM Employees
				WHERE City = 'London'
				
				-- Trả về danh sách những giá trị của cùng một cột
				-- là mã nhân viên của những nhân viên có quê là Luân Đôn
				SELECT EmployeeID
				FROM Employees
				WHERE City = 'London'
				
				---- * Câu hỏi gián tiếp: Những đơn hàng do những nhân viên quê ở Luân Đôn phụ trách
				SELECT *
				FROM Orders

				-- Lấy câu truy vấn trả về giá trị là danh sách mã nhân viên
				-- gán vào nơi nhận giá trị đầu vào là một tập hợp mã nhân viên
				-- ≈ WHERE EmployeeID IN (5, 6, 7, 9)
				WHERE EmployeeID IN (
							SELECT EmployeeID FROM Employees
							WHERE City = 'London'
						    )

----------------------------------------

ALL và ANY/ SOME

* ALL: Kiểm tra từng dòng và đảm bảo phải thoả mãn hết tất cả các giá trị trong tập hợp.

Tìm số lớn/ bé nhất trong một tập hợp:
	- Lớn/ Bé hơn tất cả các số còn lại và bằng chính mình.
	- Thường sẽ chỉ trả về một kết quả, nhưng nếu có nhiều giá trị cùng lớn/ bé thì sẽ có nhiều kết quả cùng được trả về.

	-> Lớn/ Bé hơn tất cả, ngoại trừ chính mình.

	Ví dụ: Tìm số lớn nhất bằng toán tử ALL.

		-- Tập hợp các số nguyên tố
		SELECT *
		FROM Num

		-- Tìm số lớn nhất trong tập hợp
		-- bằng cách lấy từng dòng giá trị ra và đi so sánh
		-- để tìm ra xem giá trị nào
		-- lớn hơn tất cả và bằng chính mình.
			    -- Danh sách dãy số nguyên tố
		SELECT *
		FROM Num
		WHERE Numbr >= ALL (
					SELECT *
					FROM Num
				   )

* ANY/ SOME:

	Ví dụ: Tìm tất cả sản phẩm có giá cao hơn bất kì sản phẩm điện tử nào.

		SELECT *
		FROM Products
		WHERE Price > ANY (
					SELECT DISTINCT Price
					FROM Products
					WHERE Category = 'Electronics'
				  )

--------------------

Ngoài việc sử dụng một giá trị đơn để so sánh với một tập hợp các giá trị đơn khác, ta cũng có thể so sánh tổ hợp nhiều cột cùng một lúc.

	Ví dụ: Liệt kê mã nhân viên là đồng nghiệp (làm việc cùng dự án) và trùng số giờ làm với nhân viên có mã là '123456789'.

		SELECT DISTINCT EmployeeID
		FROM WorksOn
		WHERE (Pno, Hours) IN (
					SELECT Pno, Hours
					FROM WorksOn
					WHERE EmployeeID = '123456789'
				      )

Trong một số trường hợp, nếu câu truy vấn lồng có sử dụng toán tử so sánh bằng (=) hoặc IN, ta có thể thay thế câu truy vấn lồng bằng một câu truy vấn đơn (với mệnh đề JOIN).

	Ví dụ: Liệt kê danh sách nhân viên có người phụ thuộc cùng giới tính với mình.

		-- Câu truy vấn lồng
		SELECT E.FirstName, E.LastName
		FROM Employee AS E
		WHERE E.EmployeeID IN (
					SELECT D.DependentID
					FROM Dependent AS D
					WHERE E.Gender = D.Gender
				      )

		-- Câu truy vấn đơn
		SELECT E.FirstName, E.LastName
		FROM Employee AS E, Dependent AS D
		WHERE E.EmployeeID = D.DependentID
		      AND E.Gender = D.Gender

----------------------------------------

EXISTS và UNIQUE:

Là hai hàm trả về kết quả TRUE hoặc FALSE.

* EXISTS: Hàm dùng để kiểm tra kết quả của câu truy vấn lồng có rỗng (không có dòng nào) hay không. Kết quả là TRUE nếu có chứa ít nhất một dòng và FALSE nếu bảng rỗng.

* UNIQUE: Hàm dùng để kiểm tra kết quả của câu truy vấn lồng có phải là một tập hợp (không trùng) hay là một tập hợp đa phần tử (có trùng). Kết quả là TRUE nếu không có dòng nào trùng và FALSE nếu có một dòng trùng.

------------------------------------------------------------

[CÂU TRUY VẤN LỒNG TRONG MỆNH ĐỀ SELECT]

	Ví dụ: Lập danh sách nhân viên có mức lương cao hơn lương trung bình và cho biết nhân viên đó đã vượt bao nhiêu.

		-- Câu truy vấn phụ được lồng trong SELECT
		-- giúp tính mức lương chênh lệch của nhân viên
		-- so với mức lương trung bình
		SELECT EmployeeID, LastName, FirstName, Title,
		       Salary - (
					SELECT AVG(Salary)
					FROM Employees
				) AS 'Lương chênh lệch'
		FROM Employees
		WHERE Salary > (
					SELECT AVG(Salary)
					FROM Employees
			       )

------------------------------------------------------------

[CÂU TRUY VẤN LỒNG TRONG MỆNH ĐỀ FROM]

Vì mệnh đề FROM nhận vào một bảng, nên miễn là câu truy vấn SELECT có trả về kết quả là một bảng, thì có thể được lồng vào bên trong FROM.

	- Mệnh đề FROM yêu cầu một tên bảng. Vì vậy, sau khi thay thế bằng một câu truy vấn (được xem là một biểu thức tính toán và kết quả trả về là một bảng, nhưng lại chưa có tên), ta phải đặt một tên giả bằng câu lệnh AS để có thể tham chiếu trong mệnh đề WHERE ở phía sau.

	- Về mặt hiệu năng, câu truy vấn lồng thường sẽ chạy chậm hơn.
		+ Vì cơ bản thì đều là những câu lệnh độc lập, cần được tính toán trước và sau đó phối hợp với nhau.
		+ Vì vậy, nếu sử dụng những hàm có sẵn thì bộ lập lịch của Database Engine sẽ dễ dàng tính toán thuật toán để tối ưu và thay đổi giá trị khi đang hoàn toàn nằm trong một câu truy vấn.

	Ví dụ: Đếm số lượng thành phố xuất hiện (không trùng) của bảng nhân viên.

		-- Câu lệnh trả về kết quả là một cột thành phố không trùng nhau
		SELECT DISTINCT City
		FROM Employees

		-- Đếm số lượng thành phố dựa trên một biểu thức đã được đặt tên giả
		SELECT COUNT(*)
		FROM (
			SELECT DISTINCT City
			FROM Employees
		     ) AS Cities

==========================================================================================

[HÀM TẬP HỢP/ THỐNG KÊ - AGGREGATE FUNCTION]

	* Tập được sắp toàn phần (Total order): Còn được gọi là tập hợp so sánh được.
		- Là tập hợp mà mọi cặp phần tử đều có thể so sánh được với nhau.
		- Khi lấy hai giá trị bất kì trong miền, ta có thể xác định được thứ tự xuất hiện (trước-sau) của chúng.

Trong Database Engine, câu lệnh SELECT ngoài việc đảm nhận nhiệm vụ hiển thị, còn hỗ trợ một loạt các hàm với nhiệm vụ gom dữ liệu (theo một nhóm dòng - cột) và tính toán trên nhóm dữ liệu đã gom được.

	- Là những phép toán/ hình thức để thống kê/ tập hợp (aggregation) dữ liệu.
		+ Chỉ dùng được sau mệnh đề SELECT và HAVING.
		+ Tự động loại bỏ các giá trị NULL trong quá trình tính toán.
		+ Nhưng nếu không có dòng nào được trả về (vì tất cả giá trị trong cột đều NULL) thì kết quả trả về của các phép tính sẽ là NULL.

	- Bao gồm những hàm:

		+ Chỉ dùng được cho số:
			SUM()
			AVG()

		+ Dùng được cho cả những giá trị số và chuỗi (total order):
			COUNT()
			MIN()
			MAX()

------------------------------------------------------------

* Cú pháp chuẩn:
	SELECT <Danh sách cột>, HÀM-THỐNG-KÊ()
	FROM <Danh sách bảng>
	WHERE ...

* Cú pháp mở rộng: Sử dụng GROUP BY.
	SELECT <Danh sách cột>, HÀM-THỐNG-KÊ()
	FROM <Danh sách bảng>
	WHERE ...
	GROUP BY <Danh sách cột cần gom nhóm>

* Cú pháp mở rộng: Sử dụng HAVING.
	SELECT <Danh sách cột>, HÀM-THỐNG-KÊ()
	FROM <Danh sách bảng>
	WHERE ...
	GROUP BY <Danh sách cột cần gom nhóm>
	HAVING ..., HÀM-THỐNG-KÊ()

--------------------------------------------------------------------------------

	[HÀM ĐẾM - COUNT()]

COUNT <Tên cột>: Đếm trong phạm vi của một cột.

	- Được sử dụng để đếm số lần xuất hiện của các giá trị trong một cột.

		+ Nhận tham số là một cột, sau đó thực hiện đếm theo dạng cột (từ trên xuống dưới), thay vì dạng dòng (từ phải sang trái) như các phép toán thông thường.

		+ Trong quá trình đếm, không quan tâm dữ liệu có bị trùng hay không. Vì vậy, cần sử dụng thêm từ khoá DISTINCT (trong phần tham số của câu lệnh đếm) để loại bỏ đi những dòng giá trị bị trùng.

	- Nếu không có dòng nào được trả về (vì tất cả giá trị trong cột đều NULL) thì kết quả trả về sẽ là 0.

	Ví dụ: Đếm số lượng nhân viên làm việc trong các dự án, nhưng loại bỏ đi những nhân viên trùng.

		SELECT COUNT(DISTINCT EmployeeID)
		FROM WorksOn

COUNT(*): Đếm số dòng đang có trong bảng (không phải đếm riêng cho cột nào, vì dấu sao '*' đại diện cho tất cả các cột), không quan tâm đến tiêu chuẩn nào khác.

	- Là ngoại lệ duy nhất khi giá trị NULL cũng được tính.
		+ Trong khi với các phép toán gom nhóm khác (kể cả với hàm COUNT()), giá trị NULL sẽ được tự động loại bỏ trước khi thực hiện tính toán.
		+ Vì các tính toán đều phải dựa trên sự xuất hiện của giá trị và NULL lại không được xem là sự xuất hiện - không thể đếm được.

		-> NULL là thứ không thể đếm (và tính toán) được.

	- Nếu muốn đếm ô chứa trạng thái NULL, COUNT(*) là phép toán duy nhất làm được điều này.
		+ Kết quả trả về là cả một dòng chứ không phải cột chứa giá trị NULL.
		+ COUNT(*) vẫn tính là một dòng, miễn là có một cột nào đó trên dòng khác NULL.
		+ COUNT(*) chỉ không tính là một dòng khi toàn bộ giá trị trong dòng đều NULL.

		-> Đếm sự xuất hiện của cả dòng thay vì trực tiếp đếm NULL trong cột.

COUNT(*) FROM... WHERE...: Chọn ra những dòng thoả tiêu chí của bộ lọc WHERE trước rồi mới bắt đầu đếm (lọc rồi mới đếm).

--------------------------------------------------------------------------------

	[CÁC HÀM TÍNH TOÁN TRÊN SỐ - SUM() / MIN() / MAX() / AVG()]

Chỉ có thể sử dụng trên những số liệu có thể tính toán được.

Cách sử dụng tương tự COUNT() khi cũng tính toán các giá trị theo dạng cột (từ trên xuống dưới).

* Tìm giá trị nhỏ nhất - MIN().

	Ví dụ: Tìm trọng lượng nhẹ nhất trong cột trọng lượng
		SELECT MIN(Freight) AS [Smallest freight]
		FROM Orders

* Tìm giá trị lớn nhất - MAX().

	Ví dụ: Tìm trọng lượng nặng nhất trong cột trọng lượng
		SELECT MAX(Freight) AS [Highest freight]
		FROM Orders

* Tính tổng - SUM().

	Ví dụ: Tính tổng trọng lượng trong cột trọng lượng
		SELECT SUM(Freight) AS [Freight in total]
		FROM Orders

* Tính trung bình cộng - AVG().

	Ví dụ: Tính trọng lượng trung bình trong cột trọng lượng
		SELECT AVG(Freight) AS [Freight in average]
		FROM Orders

--------------------------------------------------------------------------------

[GROUP BY]

* Cú pháp:
	GROUP BY <Danh sách cột cần gom nhóm>

		- Là những phân vùng (partition) của một bảng, dữ liệu sẽ được phân chia và gom thành những nhóm khác nhau.

		- Sau đó thực hiện các thao tác thống kê lên từng nhóm dữ liệu.

		Ví dụ: Đếm xem MỖI thành phố có bao nhiêu nhân viên.

			-- 1. Chia nhóm
			GROUP BY City

			-- 2. Đếm số lượng xuất hiện trong mỗi nhóm,
			--    tăng biến đếm và sau đó đặt lại cho mỗi nhóm
			SELECT City, COUNT(City) AS [Number of employees]
			FROM Employees
			GROUP BY City

				---------------------------------------
				| City		| Number of employees |
				|---------------+---------------------|
				| Kirkland	|	1	      |
				| London	|	4	      |
				| Redmond	|	1	      |
				| Seattle	|	2	      |
				| Tacoma	|	1	      |
				---------------------------------------

Nếu trong câu hỏi có chứa từ khoá "mỗi (each)" thì cách viết phải có sự thay đổi.
	-> Chia để trị (chia cụm để gom và đếm).

	- Lấy giá trị trong cột ra để chia nhóm, sau đó đếm hoặc tính toán trên dòng.

		Ví dụ: Mỗi nhân viên tham gia nhiều dự án.
			-> Gom các mã nhân viên trùng nhau lại thành một nhóm.
				- Đếm số lượng nhân viên có tham gia dự án.
				- Đếm tổng số dự án mà một nhân viên tham gia.
				- ...

	- Có nhiệm vụ gom những thứ giống nhau của một cột vào cùng một nhóm, sau đó cho phép sử dụng hàm thống kê (ví dụ: COUNT()) để đếm và tính toán số lượng của mỗi nhóm vừa gom.

	- Mặc dù trạng thái NULL không phải là giá trị để có thể đếm hoặc tính toán, nhưng vẫn có thể chia nhóm được.

		Ví dụ: Đếm số quốc gia và gom nhóm theo vùng, miền trong bảng nhân viên.

			-------------------------
			| Region | TotalCountry	|
			|--------+--------------|
			| NULL	 |	4	|
			| WA	 |	5	|
			-------------------------

	- Nếu đã có GROUP BY thì mệnh đề SELECT không còn được phép sử dụng dấu sao '*' để đại diện cho tất cả các cột, lúc này, các cột trong bảng hoặc các hàm thống kê trên cột sẽ được liệt kê trong SELECT.

	- Trong mệnh đề SELECT có xuất hiện bất kì cột nào khác ngoài các hàm thống kê - nghĩa là sẽ thực hiện việc đếm trên các cột này.
		+ Trong mệnh đề GROUP BY cũng phải có những cột giống vậy (không bao gồm hàm thống kê).
		+ Điều này giúp đảm bảo tính hợp lý: gom và đếm theo số cột đang hiển thị, còn gom và đếm cột đang không hiển thị là vô nghĩa.
		+ Nhưng ngược lại, nếu trong mệnh đề GROUP BY có nhiều cột hơn trong mệnh đề SELECT thì vẫn được phép.

		Ví dụ: Đếm xem MỖI thành phố có bao nhiêu nhân viên.

			-- Gom những thành phố trùng nhau thành cùng một nhóm,
			-- sau đó tiến hành đếm số nhân viên của mỗi nhóm
			SELECT Country, City, COUNT(City) AS [Number of employees]
			FROM Employees
			GROUP BY Country, City

				-----------------------------------------------
				| Country | City	| Number of employees |
				|---------+-------------+---------------------|
				| USA	  | Kirkland	|	1	      |
				| UK	  | London	|	4	      |
				| USA	  | Redmond	|	1	      |
				| USA	  | Seattle	|	2	      |
				| USA	  | Tacoma	|	1	      |
				-----------------------------------------------

	- Cũng giống như ORDER BY, thứ tự các cột được liệt kê trong GROUP BY cũng sẽ ảnh hưởng đến kết quả hiển thị.
		+ Mệnh đề SELECT sẽ quyết định thứ tự kết quả được hiển thị ra.
		+ Mệnh đề GROUP BY quyết định thứ tự gom nhóm và thống kê.

		Ví dụ: Đếm xem MỖI thành phố có bao nhiêu nhân viên.

			-- SELECT Country, City
			-- GROUP BY Country, City
			SELECT Country, City, COUNT(City) AS [Number of employees]
			FROM Employees
			GROUP BY Country, City

				-----------------------------------------------
				| Country | City	| Number of employees |
				|---------+-------------+---------------------|
				| USA	  | Kirkland	|	1	      |
				| UK	  | London	|	4	      |
				| USA	  | Redmond	|	1	      |
				| USA	  | Seattle	|	2	      |
				| USA	  | Tacoma	|	1	      |
				-----------------------------------------------

			-- SELECT Country, City
			-- GROUP BY City, Country
			SELECT Country, City, COUNT(City) AS [Number of employees]
			FROM Employees
			GROUP BY City, Country

				-----------------------------------------------
				| Country | City	| Number of employees |
				|---------+-------------+---------------------|
				| UK	  | London	|	4	      |
				| USA	  | Kirkland	|	1	      |
				| USA	  | Redmond	|	1	      |
				| USA	  | Seattle	|	2	      |
				| USA	  | Tacoma	|	1	      |
				-----------------------------------------------

	- Việc gom nhóm theo cột khoá chính là vô nghĩa vì khoá chính đã đảm bảo mỗi dòng là một nhóm riêng. Vì vậy, chỉ nên đếm trên những cột có khả năng đếm.

		Ví dụ:
			- "Mã số nhân viên" -> Không có gì để đếm
			- "Mã chuyên ngành" -> Đếm số sinh viên thuộc chuyên ngành
			- "Mã quốc gia" -> Đếm số đơn hàng của tỉnh
			- "Điểm thi" -> Đếm số lượng sinh viên đạt được điểm cao

------------------------------------------------------------

[HAVING]

Nếu trong quá trình đếm và gom nhóm lại phát sinh nhu cầu lọc dữ liệu (cần lọc dữ liệu đến hai lần).

	- Những điều kiện lọc này chỉ áp dụng lên từng nhóm, nên ta không thể trực tiếp sử dụng WHERE như thông thường, mà phải sử dụng HAVING.

	- HAVING cũng là bộ lọc giống như WHERE, nhưng được đổi tên để tránh bị trùng, chỉ được sử dụng sau khi đã gom nhóm trong SELECT xong.

	- Có thể hiểu, sau khi gom nhóm bằng GROUP BY, kết quả trả về sẽ là một bảng đặc biệt và để lọc điều kiện từ bảng này thì ta bắt buộc phải sử dụng HAVING.

	- Vì là bộ lọc và có kết hợp với các toán tử so sánh, nên mệnh đề HAVING cũng được phép có những câu lệnh lồng bên trong.

		Ví dụ 1: Lọc ra những thành phố có từ hai nhân viên trở lên.

			-- Đếm số lượng nhân viên của mỗi thành phố
			SELECT Country, City, COUNT(City) AS [Number of employees]
			FROM Employees
			GROUP BY Country, City

			-- Bắt đầu lọc kết quả đếm
			SELECT Country, City, COUNT(City) AS [Number of employees]
			FROM Employees
			GROUP BY Country, City
			HAVING COUNT(City) >= 2

		Ví dụ 2: Thành phố nào có nhiều nhân viên nhất.

			-- Đếm số lượng nhân viên của mỗi thành phố
			SELECT Country, City, COUNT(City) AS [Total number of employees]
			FROM Employees
			GROUP BY Country, City

			-- Bắt đầu lọc kết quả đếm
			SELECT Country, City, COUNT(City) AS [Total number of employees]
			FROM Employees
			GROUP BY Country, City
			HAVING COUNT(City) >= ALL (
							SELECT COUNT(City)
							FROM Employees
							GROUP BY City
						  )

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	WHERE được dùng để kiểm tra điều kiện trước GROUP BY	│
│	HAVING được dùng để kiểm tra điều kiện sau GROUP BY	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[CÁC PHÉP TOÁN TRÊN TẬP HỢP]

Các phép toán trên tập hợp trong SQL cũng giống như trong ĐSQH khi sẽ tự động loại bỏ đi những dòng dữ liệu bị trùng.

--------------------------------------------------------------------------------

1. PHÉP HỘI (UNION):

	Ví dụ 1: Liệt kê tên các nhân viên thuộc đơn vị 1 hoặc 2.

		SELECT FirstName
		FROM Employees
		WHERE DNum = 1

		UNION

		SELECT FirstName
		FROM Employees
		WHERE DNum = 2

	Ví dụ 2: Liệt kê mã số nhân viên làm việc cho phòng CNTT hoặc tham gia đề án số 1812.

		SELECT NV.MaNV
		FROM NhanVien NV, PhongBan PB
		WHERE NV.MaPB = PB.MaPB AND TenPB = 'CNTT'

		UNION

		SELECT NV.MaNV
		FROM PhanCongCongViec
		WHERE MaDA = '1812'

--------------------------------------------------------------------------------

2. PHÉP GIAO (INTERSECT):

	Ví dụ 1: Liệt kê danh sách mã nhân viên tham gia cả hai dự án 1 và 2.

		SELECT EmployeeID
		FROM WorksOn
		WHERE PNum = 1

		INTERSECT

		SELECT EmployeeID
		FROM WorksOn
		WHERE PNum = 2

	Ví dụ 2: Liệt kê mã nhân viên của các quản lý là nam, có quản lý nhiều hơn 3 nhân viên.

		-- Lấy ra danh sách người quản lý (cả nam và nữ)
		-- có quản lý nhiều hơn 3 nhân viên
		SELECT MaNguoiQuanLy
		FROM NhanVien
		WHERE MaNguoiQuanLy IS NOT NULL
		GROUP BY MaNguoiQuanLy
		HAVING COUNT(*) > 3

		INTERSECT

		-- Danh sách những người quản lý là nam
		SELECT MaNV
		FROM NhanVien
		WHERE MaNV IN (
				SELECT MaNguoiQuanLy
				FROM NhanVien
				WHERE MaNguoiQuanLy IS NOT NULL
			      )
		      AND GioiTinh IN ('Nam')

--------------------------------------------------------------------------------

3. PHÉP TRỪ (EXCEPT):

	Ví dụ 1: Liệt kê tên mã số các nhân viên chỉ tham gia dự án 1 và không tham gia dự án 2.

		SELECT EmployeeID
		FROM WorksOn
		WHERE PNum = 1

		EXCEPT

		SELECT EmployeeID
		FROM WorksOn
		WHERE PNum = 2

	Ví dụ 2: Liệt kê mã nhân viên của những nhân viên chưa từng tham gia dự án nào (nhân viên mới).

		SELECT MaNV
		FROM NhanVien

		EXCEPT

		SELECT DISTINCT MaNV
		FROM PhanCongCongViec

--------------------------------------------------------------------------------

==========================================================================================

[KẾT NỐI CÁC BẢNG VỚI SQL JOIN]

Vì những kỹ thuật thiết kế mà dữ liệu sẽ được tách ra và nằm rải rác ở các bảng khác nhau. Vì vậy, ta cần sử dụng JOIN để có thể cùng một lúc tương tác trên những bảng có liên hệ với nhau.

	- Cần có một sự am hiểu nhất định về các bảng trước khi ghép.

	- Không ngại việc nhân bản thêm dữ liệu để ghép, miễn hợp nhau là được.

	- Việc quét chọn và thực thi hai câu lệnh SQL sẽ không được gọi là JOIN, vì đây mới chỉ là hai câu lệnh riêng biệt được thực thi cùng một lúc và sẽ cho ra hai tập kết quả riêng biệt nhau.
		+ Trong khi đó, JOIN là hợp/ gom tất cả dữ liệu về cùng một bảng.
		+ Toàn bộ các dòng dữ liệu từ các bảng sẽ được gom về cùng một bảng (bảng tạm) trong RAM của Database Engine, hợp lại thành một bảng duy nhất và không làm ảnh hưởng đến những dữ liệu gốc trong mỗi bảng.

	- Các dữ liệu sẽ được ghép ngang thay vì ghép dọc.

		* Ghép ngang: Để các dòng của các bảng sát vào nhau (kè kè / kế bên / song song với nhau) về bên trái hoặc phải.
			-> Thêm cột.

		* Ghép dọc: Dữ liệu sẽ được chèn vào đầu hoặc cuối bảng trong cùng một cột, giúp gia tăng thêm dữ liệu cho một bảng.
			-> Thêm dòng.

	-> Tạm thời ghép các bảng sát nhau theo chiều ngang để tổng hợp dữ liệu.
		(Việc SELECT cùng lúc được nhiều bảng.)

	- Việc sử dụng JOIN để ghép bảng chỉ khiến cho dữ liệu nhiều lên, chứ không làm thay đổi tư duy tính toán về SQL, nghĩa là ta có thể tận dụng lại toàn bộ kiến thức khi tương tác với một bảng.

	- Vì hai bảng khác nhau có quyền đặt tên cột trùng nhau, nên khi ghép lại sẽ có hiện tượng tên cột bị trùng và gây bối rối (ambiguous). Vì vậy, để tránh nhầm lẫn cũng như tránh bị trùng lặp, ta cần phải:

		+ Chỉ định cột thuộc bảng nào (tham chiếu cột qua tên bảng), giống như dấu chấm trong lập trình hướng đối tượng (OOP).

			Ví dụ: Ghép bảng bằng CROSS JOIN

				-- Sắp xếp theo cột Nmbr của bảng VnDict
				-- (tránh nhầm với cột Nmbr của bảng EnDict)
				SELECT *
				FROM VnDict, EnDict
				ORDER BY VnDict.Nmbr

		+ Đặt tên giả (Alias) cho bảng để tham chiếu cho các cột. Nên đặt một tên tắt, vì tên thật của bảng có thể rất dài và không tiện trong việc tham chiếu.

			Ví dụ: Ghép bảng bằng CROSS JOIN

				-- Có sử dụng AS
				SELECT vn.Nmbr, vn.VnDesc, en.EnDesc
				FROM VnDict AS vn, EnDict AS en
				ORDER BY vn.Nmbr
				
				-- Không sử dụng AS
				SELECT vn.Nmbr, vn.VnDesc, en.EnDesc
				FROM VnDict vn, EnDict en
				ORDER BY vn.Nmbr

	- Sau khi đã tìm ra được dữ liệu bao gồm cả phần chung và riêng, ta vẫn có quyền sử dụng thêm bộ lọc WHERE trên một ô nào đó như bình thường (HAVING chỉ sử dụng khi có gom nhóm - GROUP BY).

--------------------------------------------------------------------------------

* Các kỹ thuật ghép bảng:

------------------------------------------------------------

1. Ghép xả láng - CROSS JOIN.

	- Ghép bừa bãi và vô tội vạ, hay còn được gọi với tên khác là tích Đềcác (Cartesian product) - các phép toán về tập hợp.

	- Số cột = tổng hai bên, số dòng = tích 2 bên (hai bên nhân với nhau).
		
	- Trước khi chuyển sang dòng mới, một dòng bên này sẽ phải ghép với tất cả các dòng ở bên kia.

	- Bùng nổ "dân số" kết quả.

	-> Nguyên team đi vào hết.

	* Cú pháp chuẩn:
		SELECT *
		FROM [Tên bảng 1] CROSS JOIN [Tên bảng 2]
		-- Không được phép sử dụng WHERE

	* Cú pháp thực dụng:
		SELECT *
		FROM [Tên bảng 1], [Tên bảng 2]
		-- Được phép sử dụng WHERE

		Ví dụ:
			-- Sử dụng cú pháp chuẩn và tường Minh
			SELECT *
			FROM VnDict CROSS JOIN EnDict
			ORDER BY VnDict.Nmbr

			-- Sử dụng cú pháp nhanh và ngầm định
			SELECT *
			FROM VnDict, EnDict
			ORDER BY VnDict.Nmbr

	- Trong các cặp được ghép vô tội vạ, sẽ có những cặp ghép đúng và những gặp ghép sai.
		
		+ Những cặp đúng, nếu kết hợp với mệnh đề WHERE để tìm điểm chung sẽ được gọi là INNER JOIN hoặc OUTER JOIN (đôi khi còn được gọi là EQUI JOIN).
			* EQUI JOIN: Ghép có mục đích với dấu =
			* NON-EQUI JOIN: Ghép có mục đích, nhưng với dấu >, >=, <, <=, !=

		+ Mặc dù được viết dưới dạng tích Đềcác, nhưng thuật toán của Database Engine sẽ tính toán lại để ghép nhằm giúp tăng tốc độ.

		Ví dụ: Tìm điểm chung giữa hai bảng.

			-- Sử dụng tích Đềcác kết hợp với mệnh đề WHERE
			SELECT *
			FROM VnDict vn, EnDict en
			WHERE vn.Nmbr = en.Nmbr

------------------------------------------------------------

2. Ghép môn đương hộ đối - INNER JOIN.

	- Ghép có chọn lọc, dựa trên điểm chung / cột chung (tương quan và hợp lý) để ghép. Trên cột chung, chỉ đi tìm và ghép những dòng có điểm chung, những dòng chứa giá trị khác biệt sẽ tự động bị loại.

	- Ngắm nhìn cấu trúc bên trong bảng một hồi lâu rồi mới bắt đầu ghép.

	- Ghép khi thoả tiêu chí / điều kiện và ghép bằng toán tử = hoặc >=, <=,...

	-> Gió tầng nào gặp mây tầng đó.

	* Cú pháp chuẩn:
		-- Cách tường minh
		SELECT *
		FROM [Tên bảng 1] INNER JOIN [Tên bảng 2]
		ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
		WHERE...

		-- Cách ngầm định
		SELECT *
		FROM [Tên bảng 1] JOIN [Tên bảng 2]
		ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
		WHERE...

	* Cú pháp thực dụng:
		SELECT *
		FROM [Tên bảng 1], [Tên bảng 2]
		WHERE [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]

		Ví dụ: Từ điển Anh-Việt / Việt-Anh
			-- EQUI JOIN
			SELECT *
			FROM EnDict en INNER JOIN VnDict vn
			ON en.Nmbr = vn.Nmbr

			-- NON-EQUI JOIN
			SELECT *
			FROM EnDict en INNER JOIN VnDict vn
			ON en.Nmbr != vn.Nmbr

------------------------------------------------------------

3. Ghép dâng hiến - OUTER JOIN.

	- Cũng ghép có chọn lọc, nhưng ngoài phần chung thì còn cống hiến thêm phần riêng nếu đối phương không có.

	- Thường thấy trong hai cột giống nhau, nhưng lại có sự khác nhau đôi chút về dòng.

	- Tuỳ vào việc cột nào sẽ được lấy để làm chuẩn, mà cột còn lại sẽ được tự động gán trạng thái NULL.

	- Khi đã chấp nhận "ở bên nhau" nhưng lại không hoàn toàn "tìm được tiếng nói chung" thì "trời không chịu đất, đất phải chịu trời".

	- Thứ tự của các bảng được bố trí trong mệnh đề FROM và việc lấy vế bên nào làm mốc / làm chuẩn đều sẽ có ảnh hưởng đến kết quả (của LEFT / RIGHT OUTER JOIN).

	- Được sử dụng để phục vụ cho việc thống kê và đảm bảo việc ghép bảng sẽ không bị mất dữ liệu, trong khi INNER JOIN chỉ quan tâm đến duy nhất điểm chung của đôi bên.

	- Ngoài ra, cũng có kỹ thuật khác để chọn được những dòng khác nhau, được gọi là UNION.

	-> Chơi hết mình, phần còn lại phụ thuộc vào đối phương.

	* Có ba nhánh nhỏ:

----------------------------------------

		1. LEFT OUTER JOIN.

			- Lấy bảng bên trái để làm mốc / làm chuẩn.
				+ Chung của cả hai.
				+ Riêng của bên trái.
				+ Bên phải mặc định là NULL.

			* Cú pháp:
				-- Tường minh
				SELECT *
				FROM [Tên bảng 1] LEFT OUTER JOIN [Tên bảng 2]
				ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
				WHERE...
				
				-- Ngầm định
				SELECT *
				FROM [Tên bảng 1] LEFT JOIN [Tên bảng 2]
				ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
				WHERE...

				Ví dụ: Khi cột tiếng Anh có Four nhưng cột tiếng Việt lại chỉ có Năm.
					-- Lấy hết phần chung
					-- và lấy thêm phần riêng của EnDict
					SELECT *
					FROM EnDict e LEFT OUTER JOIN VnDict v
					ON e.Nmbr = v.Nmbr

----------------------------------------

		2. RIGHT OUTER JOIN.

			- Lấy bảng bên phải để làm mốc / làm chuẩn.
				+ Chung của cả hai.
				+ Riêng của bên phải.
				+ Bên trái mặc định là NULL.

			* Cú pháp:
				-- Tường minh
				SELECT *
				FROM [Tên bảng 1] RIGHT OUTER JOIN [Tên bảng 2]
				ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
				WHERE...
				
				-- Ngầm định
				SELECT *
				FROM [Tên bảng 1] RIGHT JOIN [Tên bảng 2]
				ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
				WHERE...

				Ví dụ: Khi cột tiếng Anh có Four nhưng cột tiếng Việt lại chỉ có Năm.
					-- Lấy hết phần chung
					-- và lấy thêm phần riêng của VnDict
					SELECT *
					FROM EnDict e RIGHT OUTER JOIN VnDict v
					ON e.Nmbr = v.Nmbr

----------------------------------------

		3. FULL OUTER JOIN

			- Không còn quan trọng bên nào làm mốc / làm chuẩn.
				+ Chung của cả hai.
				+ Riêng của mỗi bên.

			* Cú pháp:
				-- Tường minh
				SELECT *
				FROM [Tên bảng 1] FULL OUTER JOIN [Tên bảng 2]
				ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
				WHERE...
				
				-- Ngầm định
				SELECT *
				FROM [Tên bảng 1] FULL JOIN [Tên bảng 2]
				ON [Tên bảng 1].[Tên cột chung] = [Tên bảng 2].[Tên cột chung]
				WHERE...

				Ví dụ: Khi cột tiếng Anh có Four nhưng cột tiếng Việt lại chỉ có Năm.
					-- Lấy hết phần chung,
					-- lấy thêm phần riêng của cả EnDict và VnDict
					SELECT *
					FROM EnDict e FULL OUTER JOIN VnDict v
					ON e.Nmbr = v.Nmbr

----------------------------------------

		Khi ghép dâng hiến, nếu chỉ muốn lấy những phần riêng (của một bên), ta có thể kết hợp thêm điều kiện WHERE.

			Ví dụ: Hai bảng giống nhau, đều lưu thông tin về người.

				NameListsA		NameListsB
				------------------	--------------------
				| ID | Name      |	| ID | Name        |	
				|----+-----------|	|----+-------------|
				| 1  | Pirate    |	| 1  | Rutabaga    |
				| 2  | Monkey    |	| 2  | Pirate      |
				| 3  | Ninja     |	| 3  | Darth Vader |
				| 4  | Spaghetti |	| 4  | Ninja       |
				------------------	--------------------

				-- Chỉ lấy những phần riêng của bảng bên trái:
				--	(Monkey và Spaghetti),
				-- bằng cách lọc ra những dòng mà bên phải không có
				SELECT *
				FROM NameListsA AS A
					LEFT OUTER JOIN NameListsB AS B
					ON A.Name = B.Name
				WHERE B.ID IS NULL

					---------------------------------------
					| ID | Name      | ID   | Name        |	
					|----+-----------+------+-------------|
					| 2  | Monkey    | NULL | NULL        |
					| 4  | Spaghetti | NULL | NULL        |
					---------------------------------------

				-- Chỉ lấy những phần riêng của cả hai bảng:
				--	(Monkey và Spaghetti) của bảng A,
				--	(Rutabaga và Darth Vader) của bảng B,
				-- bằng cách lọc ra những dòng
				-- mà cả hai bên đều không có
				SELECT *
				FROM NameListsA AS A
					FULL OUTER JOIN NameListsB AS B
					ON A.Name = B.Name
				WHERE A.ID IS NULL OR B.ID IS NULL

					-----------------------------------------
					| ID   | Name      | ID   | Name        |
					|------+-----------+------+-------------|
					| 2    | Monkey    | NULL | NULL        |
					| 4    | Spaghetti | NULL | NULL        |
					| NULL | NULL      | 1    | Rutabaga    |
					| NULL | NULL      | 3    | Darth Vader |
					-----------------------------------------

------------------------------------------------------------

4. SELF JOIN

--------------------------------------------------------------------------------

Thứ tự thực hiện các mệnh đề truy vấn trong SQL:
	- https://www.sisense.com/blog/sql-query-order-of-operations/
	- https://laptrinhvb.net/bai-viet/co-so-du-lieu/--DATABASE---Thu-tu-thuc-hien-menh-de-truy-van-SELECT-trong-Sqlserver/060b94c58a5831db.html

==========================================================================================
==========================================================================================
==========================================================================================

[THAO TÁC CẬP NHẬT DỮ LIỆU VỚI NGÔN NGỮ SQL TRÊN SQL SERVER]

--------------------------------------------------------------------------------

[CHÈN / THÊM DỮ LIỆU - INSERT]

Có nhiều dạng khác nhau của câu lệnh INSERT.

	1. Thêm nguyên cả một dòng vào một bảng.
		- Không cần liệt kê danh sách tên cột, đổi lại, bắt buộc phải nhập đầy đủ giá trị cho tất cả các cột trong bảng.
		- Thứ tự nhập giá trị phải trùng với thứ tự của cột trong bảng.
		- Những giá trị nếu muốn mang trạng thái NULL thì phải ghi rõ NULL (không phải chuỗi NULL trong dấu nháy đơn).

		* Cú pháp:
			INSERT INTO <Tên bảng>
			VALUES (Danh sách giá trị theo thứ tự của cột trong bảng)

		Ví dụ: Thêm tất cả thông tin của một nhân viên mới vào trong bảng nhân viên.

			-- Lược đồ quan hệ của bảng nhân viên
			NhanVien(M̲a̲N̲V̲, HoTenNV, NgaySinh, GioiTinh, Luong, MaPB)

			-- Thêm toàn bộ thông tin của một nhân viên mới
			INSERT INTO NhanVien
			VALUES (00069, N'Nguyễn Hoàng Thuận', '2000-04-23', 'Nam', NULL, NULL)

	2. Chỉ định rõ những cột cần thêm giá trị.
		- Được sử dụng khi không muốn nhập tất cả các giá trị của một dòng.
		- Lúc này, thứ tự nhập chỉ cần tuân theo thứ tự của các cột được liệt kê trong câu lệnh INSERT INTO (không cần tuân theo cấu trúc của bảng).
		- Chỉ bắt buộc liệt kê những cột được thiết kế NOT NULL và không có giá trị mặc định.
		- Không cần liệt kê những cột cho phép NULL hoặc có giá trị mặc định vì chúng sẽ tự động được gán giá trị NULL hoặc giá trị mặc định.

		* Cú pháp:
			INSERT INTO <Tên bảng> (Danh sách cột cần thêm giá trị)
			VALUES (Danh sách giá trị theo thứ tự của cột trong câu lệnh INSERT INTO)

		Ví dụ: Thêm một số thông tin của một nhân viên mới vào trong bảng nhân viên.

			-- Lược đồ quan hệ của bảng nhân viên
			NhanVien(M̲a̲N̲V̲, HoTenNV, NgaySinh, GioiTinh, Luong, MaPB)

			-- Thêm một số thông tin của một nhân viên mới
			INSERT INTO NhanVien (MaNV, HoTenNV, NgaySinh, GioiTinh)
			VALUES (00069, N'Nguyễn Hoàng Thuận', '2000-04-23', 'Nam')

	3. Thêm nhiều dòng trên cùng một câu lệnh.

		* Cú pháp:
			INSERT INTO <Tên bảng> [(Danh sách cột cần thêm giá trị)]
			VALUES (Danh sách các dòng, được cách nhau bởi dấu phẩy)

		Ví dụ: Thêm nhiều nhân viên mới cùng một lúc.

			-- Lược đồ quan hệ của bảng nhân viên
			NhanVien(M̲a̲N̲V̲, HoTenNV, NgaySinh, GioiTinh, Luong, MaPB)

			-- Thên nhiều nhân viên mới cùng một lúc
			INSERT INTO NhanVien (MaNV, HoTenNV, NgaySinh, GioiTinh)
			VALUES (00069, N'Nguyễn Hoàng Thuận', '2000-04-23', 'Nam'),
			       (00096, N'Châu Hải My', '1966-12-06', 'Nữ'),
			       (00106, N'Nguyễn Phúc Định Lai', '2012-02-27', 'Nam'),
			       (00107, N'Nguyễn Phúc Định Luân', '2012-02-27', 'Nam')

	4.1. Thêm dữ liệu là kết quả của câu lệnh SELECT.
		- Không cần phải tự thêm (nhập tay) từng giá trị cho một hoặc nhiều dòng.
		- Thay vào đó, sử dụng một câu truy vấn trả về một hoặc nhiều dòng.
		- Yêu cần bảng trong câu lệnh SELECT phải tồn tại trước (có sẵn) để có thể lấy dữ liệu lên và đổ ngược trở lại vào câu lệnh INSERT.

		* Cú pháp:
			INSERT INTO <Tên bảng> [(Danh sách cột cần thêm giá trị)]
			SELECT ... FROM ... [WHERE ... GROUP BY ... HAVING ...]

	4.2. Tạo ra bảng (thật) rồi sau đó mới thêm dữ liệu là kết quả của câu lệnh SELECT.
		- Sử dụng câu lệnh CREATE TABLE trước khi chèn dữ liệu để tạo ra một bảng mới.
		- Bảng mới này vẫn là bảng thật và có thể truy vấn bình thường.
		- Nếu không cần sử dụng nữa, ta có thể được xoá đi bằng câu lệnh DROP TABLE.
		- Nếu thông tin của các bảng trong câu lệnh SELECT có thay đổi sau khi bảng mới được tạo ra, bảng mới này sẽ không được cập nhật; vì vậy, cần sử dụng view (khung nhìn) để giúp thông tin của bảng được cập nhật.

		* Cú pháp:
			CREATE TABLE <Tên bảng> (Tên-cột KIỂU-DỮ-LIỆU)
			INSERT INTO <Tên bảng> [(Danh sách cột cần thêm giá trị)]
			SELECT ... FROM ... [WHERE ... GROUP BY ... HAVING ...]

		Ví dụ: Tạo ra bảng mới để lưu thông tin về số giờ làm việc trong tuần của nhân viên.

			CREATE TABLE ThongTinLamViecTrongTuan
				(TenNV VARCHAR(15),
				 TenDA VARCHAR(15),
				 SoGioLamViecTrongTuan DECIMAL(3,1))

			INSERT INTO ThongTinLamViecTrongTuan (TenNV, TenDA, SoGioLamViecTrongTuan)

			SELECT NV.TenNV, DA.TenDA, LV.SoGioLamViecTrongTuan
			FROM DuAn DA, ThongTinLamViec LV, NhanVien NV
			WHERE DA.MaDA = LV.MaDA AND LV.MaNV = NV.MaNV

	4.3. [Ma đạo] Lấy kết quả của câu lệnh SELECT để tạo thành bảng mới.
		- Sử dụng câu lệnh SELECT INTO để sao chép dữ liệu từ một bảng sang bảng mới.
		- Bảng mới có cùng cấu trúc và dữ liệu với bảng kết quả của câu lệnh SELECT.
		- Bảng mới này vẫn là bảng thật và có thể truy vấn bình thường.

		* Cú pháp:
			SELECT ... INTO ...
			FROM ...
			[WHERE ... GROUP BY ... HAVING ...]

		Ví dụ: Tạo ra bảng mới để lưu thông tin về số lượng dự án đã tham gia của nhân viên.

			SELECT NV.MaNV, NV.TenNV, COUNT (MaDA) AS SoLuongDA
				INTO SoLuongDuAnCuaNhanVien
			FROM NhanVien NV, PhanCongCongViec PC
			WHERE NV.MaNV = PC.MaNV
			GROUP BY NV.MaNV, NV.TenNV

------------------------------------------------------------

Đây là lúc mà các ràng buộc toàn vẹn phát huy tác dụng.

	Ví dụ:
		- Thêm một giá trị vào cột khoá ngoại khi giá trị này không thuộc miền giá trị của khoá chính.
			-> Vi phạm ràng buộc tham chiếu.

		- Báo lỗi khi không nhập giá trị cho khoá chính.
			-> Vi phạm ràng buộc NOT NULL.		

--------------------------------------------------------------------------------

[SỬA / THAY ĐỔI DỮ LIỆU - UPDATE]

Được sử dụng để sửa/ thay đổi dữ liệu trong một bảng.
	- Mỗi câu lệnh UPDATE tương đương với một bảng, muốn cập nhật nhiều bảng thì sử dụng nhiều câu lệnh UPDATE.
	- Kết hợp với mệnh đề WHERE để chỉ định cách lọc ra những dòng cần sửa và mệnh đề SET để chỉ định tên cột và giá trị mới.
	- Có thể chỉ thay đổi một số giá trị trong một dòng hoặc tất cả các giá trị của một dòng (và sau đó là thay đổi nhiều dòng).
	- Việc thay đổi giá trị khoá chính có thể làm ảnh hưởng đến các giá trị khóa ngoại.

	* Cú pháp:
		UPDATE <Tên bảng>
		SET <Tên thuộc tính> = <Giá trị mới>
		[WHERE <Điều kiện để lọc ra các dòng cần sửa>]

	Ví dụ: Tăng lương cho nhân viên.

		-- Tăng 10% lương cho tất cả nhân viên
		UPDATE NhanVien
		SET Luong = Luong * 1.1

		-- Chỉ tăng 15% lương cho người quản lý
		UPDATE NhanVien
		SET Luong = Luong * 1.5
		WHERE ChucVu = N'Quản lý'

--------------------------------------------------------------------------------

[XOÁ / BỎ DỮ LIỆU - DELETE]

Được sử dụng để xoá các dòng khỏi bảng.
	- Kết hợp với mệnh đề FROM để chỉ định bảng cần xoá và mệnh đề WHERE để chỉ định cách lọc ra những dòng cần xoá.
	- Nếu khuyết mệnh đề WHERE thì tất cả các dòng sẽ bị xoá, nhưng vẫn sẽ chừa lại bảng (để loại bỏ bảng hoàn toàn, ta có thể sử dụng câu lệnh DROP TABLE).
	- Có thể xem đây giống như một câu lệnh truy vấn để lấy dữ liệu ra, nhưng có điều không phải lấy ra để xem mà là để xoá (bằng câu lệnh DELETE).
	- Tại một thời điểm, chỉ có thể xoá các dòng tại một bảng duy nhất.
	- Việc xoá dữ liệu trong một bảng có thể ảnh hưởng đến những bảng khác nếu chúng có các ràng buộc khoá chính-khoá ngoại.

	* Cú pháp:
		DELETE FROM <Tên bảng>
		[WHERE <Điều kiện để lọc ra các dòng cần xoá>]

	Ví dụ: Xoá một, nhiều hoặc tất cả các dữ liệu trong bảng.

		-- Xoá một dòng dữ liệu
		DELETE FROM NhanVien
		WHERE MaNV = '00069'

		-- (Có thể) Xoá nhiều dòng dữ liệu
		DELETE FROM NhanVien
		WHERE TenNV LIKE '%An%'

		-- Xoá tất cả các dòng dữ liệu
		DELETE FROM NhanVien

==========================================================================================
==========================================================================================
==========================================================================================

[THIẾT KẾ CƠ SỞ DỮ LIỆU - DATABASE DESIGN]

==========================================================================================

	[VẼ SƠ ĐỒ Ý NIỆM BẰNG VISUAL PARADIGM]

Bước 01: Tạo mới dự án trong Visual Paradigm.

	Tab Project > New
		Data type set: UML

	Chuyển đổi mức độ sơ đồ:
		Chuột phải > Open Specification...

Bước 02: Tạo sơ đồ.

	Tab Diagram > New
		Tìm (Search): Entity Relationship Diagram
		Mẫu (Template): Blank
		Tên sơ đồ (Diagram Name): ConceptualLevel.Student
			Thư mục (Folder): ConceptualLevel

Bước 03: Thiết kế sơ đồ ở mức ý niệm (ERD)

	Entity > Chuột phải > New Column
		- Dấu + tương đương với khoá chính.
		- Chữ 'N' đại diện cho việc được phép NULL.
			+ Chuột phải vào cột > Bỏ chọn 'Nullable'

Bước 04: Chuyển đổi từ mức ý niệm sang mức luận lý (Logical).

	Chuột phải > Ultilities > Synchronize to Logical ERD...
		> Chọn lại Project > Tạo mới thư mục LogicalLevel

Bước 05: Chuyển từ mức luận lý sang mức vật lý (Physical).

	Chuột phải > Ultilities > Synchronize to Physical ERD...
		> Chọn lại Project > Tạo mới thư mục PhysicalLevel
		> Giữa nguyên toàn bộ tên đã đặt trong quá trình thiết kế

Bước 06: Chuyển thành những câu lệnh SQL.

	Tab Tools > DB > Database Configuration...
		> Chuột phải > Ultilities > Generate SQL...

==========================================================================================

	[TRIẾT LÝ THIẾT KẾ BẢNG]



==========================================================================================
==========================================================================================
==========================================================================================

[DẠNG CHUẨN - NORMAL FORM / DATABASE NORMALIZATION]

-- Tại sao lại tách dữ liệu thành nhiều bảng?

-- Ưu và nhược điểm của việc tách bảng?

-- Cần bao nhiêu bảng là đủ?

==========================================================================================
==========================================================================================
==========================================================================================

* Tham khảo thêm:

	- Cách viết các chỉ số trên và dưới:
		+ Chỉ số trên (Superscript): https://lingojam.com/SuperscriptGenerator
		+ Chỉ số dưới (Underscript / Subscript): https://lingojam.com/SubscriptGenerator

	- eBook tiếng Anh:
		+ https://opendsa-server.cs.vt.edu/ODSA/Books/Database/html/
		+ https://opentextbc.ca/dbdesign01/front-matter/preface/

	- Học cách viết SQL: https://viblo.asia/s/tu-con-ga-den-master-sql-GyZJZlY2Vjm

	- Thực hành SQL - Tran Huong CNTT: https://www.youtube.com/playlist?list=PLLXCN-2OVrTsciN96pCFXMtD3OwA3XMJF

	- Video bài giảng KMA: https://youtube.com/playlist?list=PLSe6_C9mboBDG8wVFZfSycRQnS51T0H3M&si=JAZKPaot1Fp3egHN

	- ĐH Kinh tế Đà Nẵng: https://www.youtube.com/playlist?list=PLPmbtynBsWO6XdduvLW2U0kLHM2gS6DDA

	- UET-VNU: https://youtube.com/playlist?list=PLe1PkMlDihehJmeTYx9WWI3mhoCHu6jyx&si=T0XQGRF4f-Vc0OPy

	- UIT: https://www.youtube.com/watch?v=Xk2zPvDCWPU&list=PL9Crvl2mNSur7gCYgfrpE4DXsNfM9Wu5O&index=3

	- Ôn tập (HUFLIT): https://www.youtube.com/playlist?list=PL58ota9C8kWTdpGIlbOKeaNhT2MTtp-VN

	- CSDL - PTIT:
		+ https://youtube.com/playlist?list=PLMPM2docCU5izIGBKXugspYApt3J0_mLu&si=oZtEf-XxntLgEeN-
		+ https://youtube.com/playlist?list=PLwrMEg5Wges6U8QcNIUrr_P-AtKWSiC3S&si=FJX3Rlu-595tu2AW

	- Dạng chuẩn (Tiếng Anh) - Studytonight with Abhishek: https://youtube.com/playlist?list=PLLGlmW7jT-nTr1ory9o2MgsOmmx2w8FB3&si=sZmFvmD2TA7T-oD-

	- Dạng chuẩn (Tiếng Anh) - Decomplexify: https://www.youtube.com/playlist?list=PLNITTkCQVxeXryTQvY0JBWTyN9ynxxPH8

	- Ôn tập nhanh (Tiếng Anh) - CS 105: https://www.youtube.com/playlist?list=PLiwphLky56kCx_ir3wMiEbWSK6K6hklrd

	- Blog về lược đồ quan hệ: https://nthnhung.wordpress.com/2020/11/11/bai-2-relational-schemas-la-gi-ma-dan-tinh-thi-nhau-hoi-info-hoa-ra-con-hot-con-hon-ca-erd/

	- Database Design Crash Course for Beginners: https://www.youtube.com/playlist?list=PL9YxAB0kJj9lUpg-kWt2MfZ7K7sX7mh8X

==========================================================================================

==========================================================================================

--------------------------------------------------------------------------------

------------------------------------------------------------

----------------------------------------

--------------------

----------





















